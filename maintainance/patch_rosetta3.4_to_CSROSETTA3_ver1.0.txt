diff -rupN vanilla/rosetta_source/src/apps/public/boinc/minirosetta.cc patched/rosetta_source/src/apps/public/boinc/minirosetta.cc
--- vanilla/rosetta_source/src/apps/public/boinc/minirosetta.cc	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/apps/public/boinc/minirosetta.cc	2012-06-06 11:00:59.741041210 +0200
@@ -104,7 +104,7 @@ main( int argc, char * argv [] )
 	protocols::abinitio::IterativeAbrelax::register_options();
 	protocols::jd2::archive::ArchiveManager::register_options();
 	//protocols::canonical_sampling::register_options();
-	protocols::canonical_sampling::CanonicalSamplingMover::register_options();
+	//protocols::canonical_sampling::CanonicalSamplingMover::register_options();
 
 
 #ifdef BOINC // BOINC STUFF
@@ -196,42 +196,41 @@ main( int argc, char * argv [] )
 			protocols::abinitio::AbrelaxApplication abrelax;
 			abrelax.run();
 		}	else if ( option[ run::protocol ]() == "symdock" ) {
-      protocols::symmetric_docking::SymDock_main();
+  //    protocols::symmetric_docking::SymDock_main();
     }	else if ( option[ run::protocol ]() == "broker" ) {
-			protocols::abinitio::Broker_main();
+		protocols::abinitio::Broker_main();
 		}	else if ( option[ run::protocol ]() == "loophash" ) {
-			protocols::loophash::loophash_main();
-		}	else if ( option[ run::protocol ]() == "ligand_dock" ) {
-			ligand_dock_main();
+	//	protocols::loophash::loophash_main();
+		}	else if ( option[ run::protocol ]() == "ligand_dock" ) {		//	ligand_dock_main();
 		} else if ( option[ run::protocol ]() == "relax" ) {
-			protocols::relax::Relax_main( true );
+//			protocols::relax::Relax_main( true );
 		} else if ( option[ run::protocol ]() == "looprelax" ) {
-			protocols::loop_build::LoopBuild_main( true );
+	//		protocols::loop_build::LoopBuild_main( true );
 		} else if ( option[ run::protocol ]() == "threading" ) {
-			protocols::comparative_modeling::cm_main();
+	//		protocols::comparative_modeling::cm_main();
 		} else if ( option[ run::protocol ]() == "medal" ) {
-			protocols::medal::Medal_main(NULL);
+	//		protocols::medal::Medal_main(NULL);
 		} else if ( option[ run::protocol ]() == "medal_exchange" ) {
-			protocols::medal::MedalExchange_main(NULL);
+//			protocols::medal::MedalExchange_main(NULL);
 		} else if ( option[ run::protocol ]() == "star" ) {
-			protocols::star::StarAbinitio_main(NULL);
+	//		protocols::star::StarAbinitio_main(NULL);
 		} else if ( option[ run::protocol ]() == "rbsegmentrelax" ) {
-			protocols::RBSegmentRelax_main( true );
+		//	protocols::RBSegmentRelax_main( true );
 		} else if ( option[ run::protocol ]() == "boinc_debug" ) {
-			protocols::abinitio::run_boinc_debug();
+	//		protocols::abinitio::run_boinc_debug();
 		} else if ( option[ run::protocol ]() == "flxbb" ) {
-			protocols::flxbb::FlxbbDesign_main();
+	//		protocols::flxbb::FlxbbDesign_main();
 		} else if ( option[ run::protocol ]() == "jd2_scripting" ){
-			protocols::moves::MoverOP mover;
+	//		protocols::moves::MoverOP mover;
 			option[ jd2::dd_parser ].value( true ); // This option MUST be set true if we're using rosetta_scripts.
 																							// To avoid accidental crashes, we'll do so programatically
-			protocols::jd2::BOINCJobDistributor::get_instance()->go( mover );
+//			protocols::jd2::BOINCJobDistributor::get_instance()->go( mover );
 		} else if ( option[run::protocol]() == "ddg"){
-			protocols::ddG_main();
+	//		protocols::ddG_main();
 		} else if ( option[run::protocol]() == "canonical_sampling") {
-			protocols::canonical_sampling::canonical_sampling_main();
+		//	protocols::canonical_sampling::canonical_sampling_main();
 		} else if ( option[run::protocol]() == "nonlocal_frags") {
-			protocols::frag_picker::nonlocal::NonlocalFrags_main();
+		//	protocols::frag_picker::nonlocal::NonlocalFrags_main();
 		}
 		else {
 			utility_exit_with_message(
diff -rupN vanilla/rosetta_source/src/apps.src.settings patched/rosetta_source/src/apps.src.settings
--- vanilla/rosetta_source/src/apps.src.settings	2012-03-21 09:06:01.000000000 +0100
+++ patched/rosetta_source/src/apps.src.settings	2012-06-08 12:02:25.386040963 +0200
@@ -29,140 +29,140 @@ sources = {
 	"": [
 	],
 	"benchmark": [
-		"benchmark",
+#		"benchmark",
 	],
 	"benchmark/scientific": [
-		"ddg_benchmark",
-		"design_contrast_and_statistic",
-		"rotamer_recovery",
+#		"ddg_benchmark",
+#		"design_contrast_and_statistic",
+#		"rotamer_recovery",
 	],
 	#"curated": [
 	#],
 	"public": [
 		"AbinitioRelax",
-		"backrub",
+#		"backrub",
 		"cluster",
-		"combine_silent",
+#		"combine_silent",
 		"extract_pdbs",
 		"fragment_picker",
 		"idealize",
 		"idealize_jd2",
 		"relax",
-		"sequence_tolerance",
-		"SymDock",
-		"vip",
+#		"sequence_tolerance",
+#		"SymDock",
+#		"vip",
 	],
 	"public/analysis": [
-		"InterfaceAnalyzer",
+#		"InterfaceAnalyzer",
 		"score",
 		"score_jd2",
 	],
 	"public/antibody": [
-		"antibody_mode",
+#		"antibody_mode",
 	],
 	"public/boinc": [
 		"minirosetta",
-		"minirosetta_graphics",
+#		"minirosetta_graphics",
 	],
 	"public/comparative_modeling": [
-		"cluster_alns",
+#		"cluster_alns",
 		#"fast_cm",
-		"fix_alignment_to_match_pdb",
-		"full_length_model",
-		"score_aln",
-		"score_aln2",
-		"super_aln",
+#		"fix_alignment_to_match_pdb",
+#		"full_length_model",
+#		"score_aln",
+#		"score_aln2",
+#		"super_aln",
 	],
 	"public/ddg": [
-		"ddg_monomer",
-		"minimize_with_cst",
+#		"ddg_monomer",
+#		"minimize_with_cst",
 	],
 	"public/design": [
-		"fixbb",
-		"mpi_msd",
-		"pmut_scan_parallel",
-		"sequence_recovery",
+#		"fixbb",
+#		"mpi_msd",
+#		"pmut_scan_parallel",
+#		"sequence_recovery",
 	],
 	"public/docking": [
-		"docking_prepack_protocol",
-		"docking_protocol",
+#		"docking_prepack_protocol",
+#		"docking_protocol",
 	],
 	"public/electron_density": [
-		"loops_from_density",
-		"mr_protocols",
+#		"loops_from_density",
+#		"mr_protocols",
 	],
 	"public/enzdes": [
-		"CstfileToTheozymePDB",
-		"enzyme_design",
+#		"CstfileToTheozymePDB",
+#		"enzyme_design",
 	],
 	"public/flexpep_docking": [
-		"BuildPeptide",
-		"FlexPepDocking", # /* Barak,doc/public/flexpep_docking/barak/FlexPepDocking.dox, test/integration/tests/flexpepdock/ */
+#		"BuildPeptide",
+#		"FlexPepDocking", # /* Barak,doc/public/flexpep_docking/barak/FlexPepDocking.dox, test/integration/tests/flexpepdock/ */
 	],
 	"public/interface_design/anchored_design": [
-		"AnchoredDesign", # /* Steven Lewis, doc/apps/pilot/smlewis/anchored_design.dox, test/integration/tests/anchored_design/ */
-		"AnchoredPDBCreator", # /* Steven Lewis, doc/apps/pilot/smlewis/AnchoredPDBCreator.dox, test/integration/tests/AnchoredPDBCreator/ */
-		"AnchorFinder", # /* Steven Lewis, doc/apps/pilot/smlewis/AnchorFinder.dox, test/integration/tests/AnchorFinder/ */
+#		"AnchoredDesign", # /* Steven Lewis, doc/apps/pilot/smlewis/anchored_design.dox, test/integration/tests/anchored_design/ */
+#		"AnchoredPDBCreator", # /* Steven Lewis, doc/apps/pilot/smlewis/AnchoredPDBCreator.dox, test/integration/tests/AnchoredPDBCreator/ */
+#		"AnchorFinder", # /* Steven Lewis, doc/apps/pilot/smlewis/AnchorFinder.dox, test/integration/tests/AnchorFinder/ */
 	],
 	"public/ligand_docking": [
-		"extract_atomtree_diffs",
-		"ligand_dock",
-		"ligand_rpkmin",
-                "select_best_unique_ligand_poses", # /* Ian Davis/Rocco Moretti, doc/apps/public/ligand_dock.dox, test/integration/tests/select_best_unique_ligand_poses/ */
+#		"extract_atomtree_diffs",
+#		"ligand_dock",
+#		"ligand_rpkmin",
+ #               "select_best_unique_ligand_poses", # /* Ian Davis/Rocco Moretti, doc/apps/public/ligand_dock.dox, test/integration/tests/select_best_unique_ligand_poses/ */
 	],
 	"public/loop_modeling": [
-		"loopmodel",
+#		"loopmodel",
 	],
 	"public/match": [
-		"gen_apo_grids",
-		"gen_lig_grids",
-		"match",
+#		"gen_apo_grids",
+#		"gen_lig_grids",
+#		"match",
 	],
 	"public/membrane_abinitio": [
-		"membrane_abinitio2",
+#		"membrane_abinitio2",
 	],
 	"public/ncaa_utilities": [
-		"make_rot_lib",
-		"UnfoldedStateEnergyCalculator",
+#		"make_rot_lib",
+#		"UnfoldedStateEnergyCalculator",
 	],
 	"public/pepspec": [
-		"pepspec",
-		"pepspec_anchor_dock",
+#		"pepspec",
+#		"pepspec_anchor_dock",
 	],
 	"public/rna": [
-		"rna_cluster",
-		"rna_database",
-		"rna_denovo",
-		"rna_design",
-		"rna_extract",
-		"rna_helix",
-		"rna_minimize",
-		"rna_score",
-		"erraser_minimizer",
+#		"rna_cluster",
+#		"rna_database",
+#		"rna_denovo",
+#		"rna_design",
+#		"rna_extract",
+#		"rna_helix",
+#		"rna_minimize",
+#		"rna_score",
+#		"erraser_minimizer",
 	],
 	"public/swa_rna": [
-		"swa_rna_analytical_closure", 
-		"swa_rna_main", 
-		"swa_rna_util", 
+#		"swa_rna_analytical_closure", 
+#		"swa_rna_main", 
+#		"swa_rna_util", 
 	],
 	"public/rosetta_scripts": [
-		"revert_design_to_native",
-		"rosetta_scripts",
+#		"revert_design_to_native",
+#		"rosetta_scripts",
 	],
 	"public/rosettaDNA": [
-		"rosettaDNA",
+#		"rosettaDNA",
 	],
 	"public/scenarios": [
-		"beta_strand_homodimer_design/exposed_strand_finder",
-		"beta_strand_homodimer_design/homodimer_design",
-		"beta_strand_homodimer_design/homodimer_maker",
-		"ca_to_allatom", # /* Frank DiMaio, doc/apps/public/scenarios/ca_to_allatom.dox */
-		"doug_dock_design_min_mod2_cal_cal",
-		"FloppyTail", # /* Steven Lewis, doc/apps/public/scenarios/FloppyTail.dox, test/integration/tests/FloppyTail/ */
-		"chemically_conjugated_docking/UBQ_E2_thioester", # /* Steven Lewis, doc/apps/public/scenarios/UBQ_conjugated.dox, test/integration/tests/UBQ_E2_thioester/ */
-                "chemically_conjugated_docking/UBQ_Gp_CYD-CYD"  , # /* Steven Lewis, doc/apps/public/scenarios/UBQ_conjugated.dox, test/integration/tests/UBQ_Gp_CYD-CYD/   */
-                "chemically_conjugated_docking/UBQ_Gp_CYX-Cterm", # /* Steven Lewis, doc/apps/public/scenarios/UBQ_conjugated.dox, test/integration/tests/UBQ_Gp_CYX-Cterm/ */
-                "chemically_conjugated_docking/UBQ_Gp_LYX-Cterm", # /* Steven Lewis, doc/apps/public/scenarios/UBQ_conjugated.dox, test/integration/tests/UBQ_Gp_LYX-Cterm/ */
+#		"beta_strand_homodimer_design/exposed_strand_finder",
+#		"beta_strand_homodimer_design/homodimer_design",
+#		"beta_strand_homodimer_design/homodimer_maker",
+#		"ca_to_allatom", # /* Frank DiMaio, doc/apps/public/scenarios/ca_to_allatom.dox */
+#		"doug_dock_design_min_mod2_cal_cal",
+#		"FloppyTail", # /* Steven Lewis, doc/apps/public/scenarios/FloppyTail.dox, test/integration/tests/FloppyTail/ */
+#		"chemically_conjugated_docking/UBQ_E2_thioester", # /* Steven Lewis, doc/apps/public/scenarios/UBQ_conjugated.dox, test/integration/tests/UBQ_E2_thioester/ */
+#               "chemically_conjugated_docking/UBQ_Gp_CYD-CYD"  , # /* Steven Lewis, doc/apps/public/scenarios/UBQ_conjugated.dox, test/integration/tests/UBQ_Gp_CYD-CYD/   */
+#               "chemically_conjugated_docking/UBQ_Gp_CYX-Cterm", # /* Steven Lewis, doc/apps/public/scenarios/UBQ_conjugated.dox, test/integration/tests/UBQ_Gp_CYX-Cterm/ */
+#                "chemically_conjugated_docking/UBQ_Gp_LYX-Cterm", # /* Steven Lewis, doc/apps/public/scenarios/UBQ_conjugated.dox, test/integration/tests/UBQ_Gp_LYX-Cterm/ */
                 ],
 }
 include_path = [
diff -rupN vanilla/rosetta_source/src/basic/options/keys/antibody.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/antibody.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/antibody.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/antibody.OptionKeys.gen.hh	2012-06-10 16:12:40.672039548 +0200
@@ -36,6 +36,16 @@ namespace antibody { extern BooleanOptio
 namespace antibody { extern StringOptionKey const h3_template; }
 namespace antibody { extern BooleanOptionKey const model_h3; }
 namespace antibody { extern BooleanOptionKey const snugfit; }
+namespace antibody { extern BooleanOptionKey const refine_h3; }
+namespace antibody { extern BooleanOptionKey const h3_filter; }
+namespace antibody { extern RealOptionKey const h3_filter_tolerance; }
+namespace antibody { extern BooleanOptionKey const cter_insert; }
+namespace antibody { extern BooleanOptionKey const flank_residue_min; }
+namespace antibody { extern BooleanOptionKey const sc_min; }
+namespace antibody { extern BooleanOptionKey const rt_min; }
+namespace antibody { extern BooleanOptionKey const bad_nter; }
+namespace antibody { extern StringOptionKey const remodel; }
+namespace antibody { extern StringOptionKey const refine; }
 namespace antibody { extern BooleanOptionKey const snug_loops; }
 namespace antibody { extern FileOptionKey const input_fv; }
 namespace antibody { extern BooleanOptionKey const camelid; }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/chemical.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/chemical.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/chemical.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/chemical.OptionKeys.gen.hh	2012-06-10 16:12:40.674077164 +0200
@@ -23,6 +23,7 @@ namespace OptionKeys {
 
 namespace chemical { extern BooleanOptionKey const chemical; }
 namespace chemical { extern StringVectorOptionKey const exclude_patches; }
+namespace chemical { extern StringVectorOptionKey const include_patches; }
 
 } // namespace OptionKeys
 } // namespace options
diff -rupN vanilla/rosetta_source/src/basic/options/keys/cluster.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/cluster.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/cluster.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/cluster.OptionKeys.gen.hh	2012-06-10 16:12:40.677041158 +0200
@@ -30,6 +30,8 @@ namespace cluster { extern RealOptionKey
 namespace cluster { extern IntegerOptionKey const max_cluster_seeds; }
 namespace cluster { extern RealOptionKey const radius; }
 namespace cluster { extern IntegerOptionKey const limit_cluster_size; }
+namespace cluster { extern RealOptionKey const limit_cluster_size_percent; }
+namespace cluster { extern RealOptionKey const random_limit_cluster_size_percent; }
 namespace cluster { extern IntegerOptionKey const limit_clusters; }
 namespace cluster { extern IntegerOptionKey const limit_total_structures; }
 namespace cluster { extern IntegerOptionKey const max_total_cluster; }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/cmiles.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/cmiles.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/cmiles.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/cmiles.OptionKeys.gen.hh	2012-06-10 16:12:40.679074740 +0200
@@ -24,6 +24,9 @@ namespace OptionKeys {
 namespace cmiles { extern BooleanOptionKey const cmiles; }
 namespace cmiles { namespace kcluster { extern BooleanOptionKey const kcluster; } }
 namespace cmiles { namespace kcluster { extern IntegerOptionKey const num_clusters; } }
+namespace cmiles { namespace jumping { extern BooleanOptionKey const jumping; } }
+namespace cmiles { namespace jumping { extern IntegerOptionKey const resi; } }
+namespace cmiles { namespace jumping { extern IntegerOptionKey const resj; } }
 
 } // namespace OptionKeys
 } // namespace options
diff -rupN vanilla/rosetta_source/src/basic/options/keys/cm.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/cm.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/cm.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/cm.OptionKeys.gen.hh	2012-06-10 16:12:40.682039788 +0200
@@ -55,6 +55,7 @@ namespace cm { namespace hybridize { ext
 namespace cm { namespace hybridize { extern FileVectorOptionKey const templates; } }
 namespace cm { namespace hybridize { extern FileOptionKey const template_list; } }
 namespace cm { namespace hybridize { extern IntegerVectorOptionKey const starting_template; } }
+namespace cm { namespace hybridize { extern BooleanOptionKey const realign_domains; } }
 namespace cm { namespace hybridize { extern BooleanOptionKey const add_non_init_chunks; } }
 namespace cm { namespace hybridize { extern StringOptionKey const ss; } }
 namespace cm { namespace hybridize { extern RealOptionKey const stage1_increase_cycles; } }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/corrections.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/corrections.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/corrections.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/corrections.OptionKeys.gen.hh	2012-06-10 16:12:40.684040695 +0200
@@ -25,6 +25,7 @@ namespace corrections { extern BooleanOp
 namespace corrections { extern BooleanOptionKey const correct; }
 namespace corrections { namespace score { extern BooleanOptionKey const score; } }
 namespace corrections { namespace score { extern BooleanOptionKey const no_his_his_pairE; } }
+namespace corrections { namespace score { extern BooleanOptionKey const no_his_DE_pairE; } }
 namespace corrections { namespace score { extern BooleanOptionKey const hbond_His_Phil_fix; } }
 namespace corrections { namespace score { extern BooleanOptionKey const helix_hb_06_2009; } }
 namespace corrections { namespace score { extern BooleanOptionKey const use_incorrect_hbond_deriv; } }
@@ -51,6 +52,8 @@ namespace corrections { namespace score 
 namespace corrections { namespace score { extern RealOptionKey const hb_sp2_amp; } }
 namespace corrections { namespace score { extern RealOptionKey const hb_sp2_peak_heigh_above_trough; } }
 namespace corrections { namespace score { extern BooleanOptionKey const hbond_measure_sp3acc_BAH_from_hvy; } }
+namespace corrections { namespace score { extern BooleanOptionKey const use_bicubic_interpolation; } }
+namespace corrections { namespace score { extern BooleanOptionKey const dun_normsd; } }
 namespace corrections { namespace chemical { extern BooleanOptionKey const chemical; } }
 namespace corrections { namespace chemical { extern BooleanOptionKey const icoor_05_2009; } }
 namespace corrections { namespace chemical { extern BooleanOptionKey const parse_charge; } }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/csa.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/csa.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/csa.OptionKeys.gen.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/csa.OptionKeys.gen.hh	2012-06-10 16:12:40.687040225 +0200
@@ -0,0 +1,31 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   basic/options/keys/csa.OptionKeys.gen.hh
+/// @brief  basic::options::OptionKeys collection
+/// @author Stuart G. Mentzer (Stuart_Mentzer@objexx.com)
+/// @author James M. Thompson (tex@u.washington.edu)
+
+#ifndef INCLUDED_basic_options_keys_csa_OptionKeys_gen_HH
+#define INCLUDED_basic_options_keys_csa_OptionKeys_gen_HH
+
+// Unit headers
+#include <basic/options/keys/OptionKeys.hh>
+
+namespace basic {
+namespace options {
+namespace OptionKeys {
+
+namespace csa { extern BooleanOptionKey const csa; }
+namespace csa { extern BooleanOptionKey const useZ; }
+
+} // namespace OptionKeys
+} // namespace options
+} // namespace basic
+
+#endif
diff -rupN vanilla/rosetta_source/src/basic/options/keys/dc.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/dc.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/dc.OptionKeys.gen.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/dc.OptionKeys.gen.hh	2012-06-10 16:12:40.689074643 +0200
@@ -0,0 +1,31 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   basic/options/keys/dc.OptionKeys.gen.hh
+/// @brief  basic::options::OptionKeys collection
+/// @author Stuart G. Mentzer (Stuart_Mentzer@objexx.com)
+/// @author James M. Thompson (tex@u.washington.edu)
+
+#ifndef INCLUDED_basic_options_keys_dc_OptionKeys_gen_HH
+#define INCLUDED_basic_options_keys_dc_OptionKeys_gen_HH
+
+// Unit headers
+#include <basic/options/keys/OptionKeys.hh>
+
+namespace basic {
+namespace options {
+namespace OptionKeys {
+
+namespace dc { extern BooleanOptionKey const dc; }
+namespace dc { extern BooleanOptionKey const useZ; }
+
+} // namespace OptionKeys
+} // namespace options
+} // namespace basic
+
+#endif
diff -rupN vanilla/rosetta_source/src/basic/options/keys/in.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/in.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/in.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/in.OptionKeys.gen.hh	2012-06-10 16:12:40.692041179 +0200
@@ -29,6 +29,7 @@ namespace in { extern BooleanOptionKey c
 namespace in { extern BooleanOptionKey const remember_unrecognized_res; }
 namespace in { extern BooleanOptionKey const remember_unrecognized_water; }
 namespace in { extern BooleanOptionKey const detect_disulf; }
+namespace in { extern RealOptionKey const detect_disulf_tolerance; }
 namespace in { extern FileOptionKey const fix_disulf; }
 namespace in { extern BooleanOptionKey const use_stupid_foldtree_format; }
 namespace in { extern IntegerVectorOptionKey const target_residues; }
@@ -65,6 +66,8 @@ namespace in { namespace file { extern S
 namespace in { namespace file { extern FileOptionKey const extra_res_database_resname_list; } }
 namespace in { namespace file { extern FileVectorOptionKey const extra_res_cen; } }
 namespace in { namespace file { extern PathVectorOptionKey const extra_res_path; } }
+namespace in { namespace file { extern FileVectorOptionKey const extra_patch_fa; } }
+namespace in { namespace file { extern FileVectorOptionKey const extra_patch_cen; } }
 namespace in { namespace file { extern StringOptionKey const frag3; } }
 namespace in { namespace file { extern StringOptionKey const frag9; } }
 namespace in { namespace file { extern StringOptionKey const fragA; } }
@@ -91,6 +94,7 @@ namespace in { namespace file { extern S
 namespace in { namespace file { extern BooleanOptionKey const silent_read_through_errors; } }
 namespace in { namespace file { extern StringOptionKey const silent_score_prefix; } }
 namespace in { namespace file { extern IntegerOptionKey const silent_select_random; } }
+namespace in { namespace file { extern BooleanOptionKey const skip_failed_simulations; } }
 namespace in { namespace file { extern StringVectorOptionKey const silent_scores_wanted; } }
 namespace in { namespace file { extern FileVectorOptionKey const fasta; } }
 namespace in { namespace file { extern FileVectorOptionKey const pssm; } }
@@ -109,6 +113,8 @@ namespace in { namespace file { extern I
 namespace in { namespace file { extern FileVectorOptionKey const template_pdb; } }
 namespace in { namespace file { extern FileOptionKey const template_silent; } }
 namespace in { namespace file { extern FileVectorOptionKey const rdc; } }
+namespace in { namespace file { extern FileVectorOptionKey const csa; } }
+namespace in { namespace file { extern FileVectorOptionKey const dc; } }
 namespace in { namespace file { extern FileVectorOptionKey const burial; } }
 namespace in { namespace file { extern FileVectorOptionKey const vall; } }
 namespace in { namespace file { extern BooleanOptionKey const rescore; } }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/lh.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/lh.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/lh.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/lh.OptionKeys.gen.hh	2012-06-10 16:12:40.694077287 +0200
@@ -27,6 +27,7 @@ namespace lh { extern IntegerVectorOptio
 namespace lh { extern IntegerOptionKey const num_partitions; }
 namespace lh { extern PathOptionKey const db_path; }
 namespace lh { extern BooleanOptionKey const exclude_homo; }
+namespace lh { extern BooleanOptionKey const bss; }
 namespace lh { extern StringOptionKey const refstruct; }
 namespace lh { extern StringOptionKey const homo_file; }
 namespace lh { extern RealVectorOptionKey const createdb_rms_cutoff; }
@@ -62,6 +63,7 @@ namespace lh { extern IntegerOptionKey c
 namespace lh { extern RealOptionKey const rms_limit; }
 namespace lh { extern BooleanOptionKey const centroid_only; }
 namespace lh { extern BooleanOptionKey const write_centroid_structs; }
+namespace lh { extern BooleanOptionKey const write_all_fa_structs; }
 namespace lh { extern BooleanOptionKey const sandbox; }
 namespace lh { extern BooleanOptionKey const create_db; }
 namespace lh { extern FileOptionKey const sample_weight_file; }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/mc.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/mc.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/mc.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/mc.OptionKeys.gen.hh	2012-06-10 16:12:40.697040876 +0200
@@ -27,6 +27,7 @@ namespace mc { extern FileOptionKey cons
 namespace mc { extern IntegerOptionKey const convergence_check_frequency; }
 namespace mc { extern FileOptionKey const known_structures; }
 namespace mc { extern RealOptionKey const max_rmsd_against_known_structures; }
+namespace mc { extern IntegerVectorOptionKey const excluded_residues_from_rmsd; }
 namespace mc { extern IntegerOptionKey const heat_convergence_check; }
 
 } // namespace OptionKeys
diff -rupN vanilla/rosetta_source/src/basic/options/keys/optE.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/optE.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/optE.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/optE.OptionKeys.gen.hh	2012-06-10 16:12:40.699040081 +0200
@@ -78,6 +78,7 @@ namespace optE { extern BooleanOptionKey
 namespace optE { extern FileOptionKey const starting_refEs; }
 namespace optE { extern BooleanOptionKey const repeat_swarm_optimization_until_fitness_improves; }
 namespace optE { extern BooleanOptionKey const design_with_minpack; }
+namespace optE { extern BooleanOptionKey const limit_bad_scores; }
 namespace optE { namespace rescore { extern BooleanOptionKey const rescore; } }
 namespace optE { namespace rescore { extern FileOptionKey const weights; } }
 namespace optE { namespace rescore { extern IntegerOptionKey const context_round; } }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen0.hh patched/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen0.hh
--- vanilla/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen0.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen0.hh	2012-06-10 16:12:40.702039727 +0200
@@ -24,6 +24,7 @@ namespace in { BooleanOptionKey const ad
 namespace in { BooleanOptionKey const remember_unrecognized_res( "in:remember_unrecognized_res" );  }
 namespace in { BooleanOptionKey const remember_unrecognized_water( "in:remember_unrecognized_water" );  }
 namespace in { BooleanOptionKey const detect_disulf( "in:detect_disulf" );  }
+namespace in { RealOptionKey const detect_disulf_tolerance( "in:detect_disulf_tolerance" );  }
 namespace in { FileOptionKey const fix_disulf( "in:fix_disulf" );  }
 namespace in { BooleanOptionKey const use_stupid_foldtree_format( "in:use_stupid_foldtree_format" );  }
 namespace in { IntegerVectorOptionKey const target_residues( "in:target_residues" );  }
@@ -60,6 +61,8 @@ namespace in { namespace file { StringOp
 namespace in { namespace file { FileOptionKey const extra_res_database_resname_list( "in:file:extra_res_database_resname_list" );  } }
 namespace in { namespace file { FileVectorOptionKey const extra_res_cen( "in:file:extra_res_cen" );  } }
 namespace in { namespace file { PathVectorOptionKey const extra_res_path( "in:file:extra_res_path" );  } }
+namespace in { namespace file { FileVectorOptionKey const extra_patch_fa( "in:file:extra_patch_fa" );  } }
+namespace in { namespace file { FileVectorOptionKey const extra_patch_cen( "in:file:extra_patch_cen" );  } }
 namespace in { namespace file { StringOptionKey const frag3( "in:file:frag3" );  } }
 namespace in { namespace file { StringOptionKey const frag9( "in:file:frag9" );  } }
 namespace in { namespace file { StringOptionKey const fragA( "in:file:fragA" );  } }
@@ -86,6 +89,7 @@ namespace in { namespace file { StringOp
 namespace in { namespace file { BooleanOptionKey const silent_read_through_errors( "in:file:silent_read_through_errors" );  } }
 namespace in { namespace file { StringOptionKey const silent_score_prefix( "in:file:silent_score_prefix" );  } }
 namespace in { namespace file { IntegerOptionKey const silent_select_random( "in:file:silent_select_random" );  } }
+namespace in { namespace file { BooleanOptionKey const skip_failed_simulations( "in:file:skip_failed_simulations" );  } }
 namespace in { namespace file { StringVectorOptionKey const silent_scores_wanted( "in:file:silent_scores_wanted" );  } }
 namespace in { namespace file { FileVectorOptionKey const fasta( "in:file:fasta" );  } }
 namespace in { namespace file { FileVectorOptionKey const pssm( "in:file:pssm" );  } }
@@ -104,6 +108,8 @@ namespace in { namespace file { IntegerO
 namespace in { namespace file { FileVectorOptionKey const template_pdb( "in:file:template_pdb" );  } }
 namespace in { namespace file { FileOptionKey const template_silent( "in:file:template_silent" );  } }
 namespace in { namespace file { FileVectorOptionKey const rdc( "in:file:rdc" );  } }
+namespace in { namespace file { FileVectorOptionKey const csa( "in:file:csa" );  } }
+namespace in { namespace file { FileVectorOptionKey const dc( "in:file:dc" );  } }
 namespace in { namespace file { FileVectorOptionKey const burial( "in:file:burial" );  } }
 namespace in { namespace file { FileVectorOptionKey const vall( "in:file:vall" );  } }
 namespace in { namespace file { BooleanOptionKey const rescore( "in:file:rescore" );  } }
@@ -125,6 +131,7 @@ namespace mysql { StringOptionKey const 
 namespace mysql { IntegerOptionKey const port( "mysql:port" );  }
 namespace qsar { BooleanOptionKey const qsar( "qsar" );  }
 namespace qsar { StringOptionKey const weights( "qsar:weights" );  }
+namespace qsar { StringOptionKey const grid_dir( "qsar:grid_dir" );  }
 namespace residues { BooleanOptionKey const residues( "residues" );  }
 namespace residues { StringVectorOptionKey const patch_selectors( "residues:patch_selectors" );  }
 namespace PCS { BooleanOptionKey const PCS( "PCS" );  }
@@ -160,6 +167,7 @@ namespace out { IntegerOptionKey const s
 namespace out { StringVectorOptionKey const mute_warning( "out:mute_warning" );  }
 namespace out { StringVectorOptionKey const mute_info( "out:mute_info" );  }
 namespace out { StringVectorOptionKey const mute_debug( "out:mute_debug" );  }
+namespace out { StringVectorOptionKey const mute_trace( "out:mute_trace" );  }
 namespace out { StringVectorOptionKey const unmute_error( "out:unmute_error" );  }
 namespace out { StringVectorOptionKey const unmute_warning( "out:unmute_warning" );  }
 namespace out { StringVectorOptionKey const unmute_info( "out:unmute_info" );  }
@@ -392,6 +400,7 @@ namespace run { IntegerOptionKey const n
 namespace run { IntegerOptionKey const proc_id( "run:proc_id" );  }
 namespace run { BooleanOptionKey const exit_if_missing_heavy_atoms( "run:exit_if_missing_heavy_atoms" );  }
 namespace run { RealOptionKey const show_simulation_in_pymol( "run:show_simulation_in_pymol" );  }
+namespace run { BooleanOptionKey const keep_pymol_simulation_history( "run:keep_pymol_simulation_history" );  }
 namespace jd2 { BooleanOptionKey const jd2( "jd2" );  }
 namespace jd2 { BooleanOptionKey const pose_input_stream( "jd2:pose_input_stream" );  }
 namespace jd2 { BooleanOptionKey const lazy_silent_file_reader( "jd2:lazy_silent_file_reader" );  }
@@ -601,3 +610,7 @@ namespace abinitio { FileOptionKey const
 namespace abinitio { RealOptionKey const HD_penalty( "abinitio:HD_penalty" );  }
 namespace abinitio { RealOptionKey const HD_fa_penalty( "abinitio:HD_fa_penalty" );  }
 namespace abinitio { FileOptionKey const sheet_edge_pred( "abinitio:sheet_edge_pred" );  }
+namespace abinitio { RealOptionKey const SEP_score_scalling( "abinitio:SEP_score_scalling" );  }
+namespace fold_cst { BooleanOptionKey const fold_cst( "fold_cst" );  }
+namespace fold_cst { RealOptionKey const constraint_skip_rate( "fold_cst:constraint_skip_rate" );  }
+namespace fold_cst { IntegerOptionKey const violation_skip_basis( "fold_cst:violation_skip_basis" );  }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen1.hh patched/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen1.hh
--- vanilla/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen1.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen1.hh	2012-06-10 16:12:40.706039693 +0200
@@ -1,7 +1,3 @@
-namespace abinitio { RealOptionKey const SEP_score_scalling( "abinitio:SEP_score_scalling" );  }
-namespace fold_cst { BooleanOptionKey const fold_cst( "fold_cst" );  }
-namespace fold_cst { RealOptionKey const constraint_skip_rate( "fold_cst:constraint_skip_rate" );  }
-namespace fold_cst { IntegerOptionKey const violation_skip_basis( "fold_cst:violation_skip_basis" );  }
 namespace fold_cst { IntegerOptionKey const violation_skip_ignore( "fold_cst:violation_skip_ignore" );  }
 namespace fold_cst { BooleanOptionKey const keep_skipped_csts( "fold_cst:keep_skipped_csts" );  }
 namespace fold_cst { BooleanOptionKey const no_minimize( "fold_cst:no_minimize" );  }
@@ -99,6 +95,7 @@ namespace abrelax { BooleanOptionKey con
 namespace abrelax { BooleanOptionKey const fail_unclosed( "abrelax:fail_unclosed" );  }
 namespace chemical { BooleanOptionKey const chemical( "chemical" );  }
 namespace chemical { StringVectorOptionKey const exclude_patches( "chemical:exclude_patches" );  }
+namespace chemical { StringVectorOptionKey const include_patches( "chemical:include_patches" );  }
 namespace score { BooleanOptionKey const score_pose_cutpoint_variants( "score:score_pose_cutpoint_variants" );  }
 namespace score { BooleanOptionKey const score( "score" );  }
 namespace score { StringOptionKey const weights( "score:weights" );  }
@@ -106,7 +103,7 @@ namespace score { StringOptionKey const 
 namespace score { StringOptionKey const soft_wts( "score:soft_wts" );  }
 namespace score { BooleanOptionKey const docking_interface_score( "score:docking_interface_score" );  }
 namespace score { StringOptionKey const custom_atom_pair( "score:custom_atom_pair" );  }
-namespace score { StringOptionKey const patch( "score:patch" );  }
+namespace score { FileVectorOptionKey const patch( "score:patch" );  }
 namespace score { BooleanOptionKey const empty( "score:empty" );  }
 namespace score { RealOptionKey const fa_max_dis( "score:fa_max_dis" );  }
 namespace score { BooleanOptionKey const fa_Hatr( "score:fa_Hatr" );  }
@@ -145,6 +142,8 @@ namespace score { BooleanOptionKey const
 namespace score { StringOptionKey const fa_custom_pair_distance_file( "score:fa_custom_pair_distance_file" );  }
 namespace score { RealOptionKey const disulf_matching_probe( "score:disulf_matching_probe" );  }
 namespace score { RealVectorOptionKey const bonded_params( "score:bonded_params" );  }
+namespace score { BooleanOptionKey const bonded_params_CHARMM_angle( "score:bonded_params_CHARMM_angle" );  }
+namespace score { BooleanOptionKey const bonded_params_CHARMM_length( "score:bonded_params_CHARMM_length" );  }
 namespace score { RealOptionKey const pro_close_planar_constraint( "score:pro_close_planar_constraint" );  }
 namespace score { BooleanOptionKey const linear_bonded_potential( "score:linear_bonded_potential" );  }
 namespace score { namespace saxs { BooleanOptionKey const saxs( "score:saxs" );  } }
@@ -169,10 +168,16 @@ namespace score { RealOptionKey const ha
 namespace score { RealOptionKey const hackelec_max_dis( "score:hackelec_max_dis" );  }
 namespace score { RealOptionKey const hackelec_die( "score:hackelec_die" );  }
 namespace score { BooleanOptionKey const hackelec_r_option( "score:hackelec_r_option" );  }
+namespace score { StringOptionKey const nmer_ref_energies( "score:nmer_ref_energies" );  }
+namespace score { StringOptionKey const nmer_pssm( "score:nmer_pssm" );  }
+namespace score { StringOptionKey const nmer_pssm_list( "score:nmer_pssm_list" );  }
+namespace score { RealOptionKey const nmer_pssm_scorecut( "score:nmer_pssm_scorecut" );  }
+namespace score { IntegerOptionKey const nmer_ref_seq_length( "score:nmer_ref_seq_length" );  }
 namespace corrections { BooleanOptionKey const corrections( "corrections" );  }
 namespace corrections { BooleanOptionKey const correct( "corrections:correct" );  }
 namespace corrections { namespace score { BooleanOptionKey const score( "corrections:score" );  } }
 namespace corrections { namespace score { BooleanOptionKey const no_his_his_pairE( "corrections:score:no_his_his_pairE" );  } }
+namespace corrections { namespace score { BooleanOptionKey const no_his_DE_pairE( "corrections:score:no_his_DE_pairE" );  } }
 namespace corrections { namespace score { BooleanOptionKey const hbond_His_Phil_fix( "corrections:score:hbond_His_Phil_fix" );  } }
 namespace corrections { namespace score { BooleanOptionKey const helix_hb_06_2009( "corrections:score:helix_hb_06_2009" );  } }
 namespace corrections { namespace score { BooleanOptionKey const use_incorrect_hbond_deriv( "corrections:score:use_incorrect_hbond_deriv" );  } }
@@ -199,6 +204,8 @@ namespace corrections { namespace score 
 namespace corrections { namespace score { RealOptionKey const hb_sp2_amp( "corrections:score:hb_sp2_amp" );  } }
 namespace corrections { namespace score { RealOptionKey const hb_sp2_peak_heigh_above_trough( "corrections:score:hb_sp2_peak_heigh_above_trough" );  } }
 namespace corrections { namespace score { BooleanOptionKey const hbond_measure_sp3acc_BAH_from_hvy( "corrections:score:hbond_measure_sp3acc_BAH_from_hvy" );  } }
+namespace corrections { namespace score { BooleanOptionKey const use_bicubic_interpolation( "corrections:score:use_bicubic_interpolation" );  } }
+namespace corrections { namespace score { BooleanOptionKey const dun_normsd( "corrections:score:dun_normsd" );  } }
 namespace corrections { namespace chemical { BooleanOptionKey const chemical( "corrections:chemical" );  } }
 namespace corrections { namespace chemical { BooleanOptionKey const icoor_05_2009( "corrections:chemical:icoor_05_2009" );  } }
 namespace corrections { namespace chemical { BooleanOptionKey const parse_charge( "corrections:chemical:parse_charge" );  } }
@@ -346,6 +353,8 @@ namespace cluster { RealOptionKey const 
 namespace cluster { IntegerOptionKey const max_cluster_seeds( "cluster:max_cluster_seeds" );  }
 namespace cluster { RealOptionKey const radius( "cluster:radius" );  }
 namespace cluster { IntegerOptionKey const limit_cluster_size( "cluster:limit_cluster_size" );  }
+namespace cluster { RealOptionKey const limit_cluster_size_percent( "cluster:limit_cluster_size_percent" );  }
+namespace cluster { RealOptionKey const random_limit_cluster_size_percent( "cluster:random_limit_cluster_size_percent" );  }
 namespace cluster { IntegerOptionKey const limit_clusters( "cluster:limit_clusters" );  }
 namespace cluster { IntegerOptionKey const limit_total_structures( "cluster:limit_total_structures" );  }
 namespace cluster { IntegerOptionKey const max_total_cluster( "cluster:max_total_cluster" );  }
@@ -384,6 +393,7 @@ namespace mc { FileOptionKey const read_
 namespace mc { IntegerOptionKey const convergence_check_frequency( "mc:convergence_check_frequency" );  }
 namespace mc { FileOptionKey const known_structures( "mc:known_structures" );  }
 namespace mc { RealOptionKey const max_rmsd_against_known_structures( "mc:max_rmsd_against_known_structures" );  }
+namespace mc { IntegerVectorOptionKey const excluded_residues_from_rmsd( "mc:excluded_residues_from_rmsd" );  }
 namespace mc { IntegerOptionKey const heat_convergence_check( "mc:heat_convergence_check" );  }
 namespace batch_relax { BooleanOptionKey const batch_relax( "batch_relax" );  }
 namespace batch_relax { IntegerOptionKey const batch_size( "batch_relax:batch_size" );  }
@@ -584,6 +594,7 @@ namespace lh { IntegerVectorOptionKey co
 namespace lh { IntegerOptionKey const num_partitions( "lh:num_partitions" );  }
 namespace lh { PathOptionKey const db_path( "lh:db_path" );  }
 namespace lh { BooleanOptionKey const exclude_homo( "lh:exclude_homo" );  }
+namespace lh { BooleanOptionKey const bss( "lh:bss" );  }
 namespace lh { StringOptionKey const refstruct( "lh:refstruct" );  }
 namespace lh { StringOptionKey const homo_file( "lh:homo_file" );  }
 namespace lh { RealVectorOptionKey const createdb_rms_cutoff( "lh:createdb_rms_cutoff" );  }
@@ -601,3 +612,5 @@ namespace lh { IntegerOptionKey const sk
 namespace lh { IntegerOptionKey const rounds( "lh:rounds" );  }
 namespace lh { StringOptionKey const jobname( "lh:jobname" );  }
 namespace lh { IntegerOptionKey const max_lib_size( "lh:max_lib_size" );  }
+namespace lh { IntegerOptionKey const max_emperor_lib_size( "lh:max_emperor_lib_size" );  }
+namespace lh { IntegerOptionKey const max_emperor_lib_round( "lh:max_emperor_lib_round" );  }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen2.hh patched/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen2.hh
--- vanilla/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen2.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen2.hh	2012-06-10 16:12:40.709057861 +0200
@@ -1,5 +1,3 @@
-namespace lh { IntegerOptionKey const max_emperor_lib_size( "lh:max_emperor_lib_size" );  }
-namespace lh { IntegerOptionKey const max_emperor_lib_round( "lh:max_emperor_lib_round" );  }
 namespace lh { IntegerOptionKey const library_expiry_time( "lh:library_expiry_time" );  }
 namespace lh { StringOptionKey const objective_function( "lh:objective_function" );  }
 namespace lh { IntegerOptionKey const expire_after_rounds( "lh:expire_after_rounds" );  }
@@ -16,6 +14,7 @@ namespace lh { IntegerOptionKey const ma
 namespace lh { RealOptionKey const rms_limit( "lh:rms_limit" );  }
 namespace lh { BooleanOptionKey const centroid_only( "lh:centroid_only" );  }
 namespace lh { BooleanOptionKey const write_centroid_structs( "lh:write_centroid_structs" );  }
+namespace lh { BooleanOptionKey const write_all_fa_structs( "lh:write_all_fa_structs" );  }
 namespace lh { BooleanOptionKey const sandbox( "lh:sandbox" );  }
 namespace lh { BooleanOptionKey const create_db( "lh:create_db" );  }
 namespace lh { FileOptionKey const sample_weight_file( "lh:sample_weight_file" );  }
@@ -51,6 +50,9 @@ namespace robert { BooleanOptionKey cons
 namespace cmiles { BooleanOptionKey const cmiles( "cmiles" );  }
 namespace cmiles { namespace kcluster { BooleanOptionKey const kcluster( "cmiles:kcluster" );  } }
 namespace cmiles { namespace kcluster { IntegerOptionKey const num_clusters( "cmiles:kcluster:num_clusters" );  } }
+namespace cmiles { namespace jumping { BooleanOptionKey const jumping( "cmiles:jumping" );  } }
+namespace cmiles { namespace jumping { IntegerOptionKey const resi( "cmiles:jumping:resi" );  } }
+namespace cmiles { namespace jumping { IntegerOptionKey const resj( "cmiles:jumping:resj" );  } }
 namespace james { BooleanOptionKey const james( "james" );  }
 namespace james { IntegerOptionKey const min_seqsep( "james:min_seqsep" );  }
 namespace james { StringVectorOptionKey const atom_names( "james:atom_names" );  }
@@ -363,6 +365,7 @@ namespace cm { namespace hybridize { Boo
 namespace cm { namespace hybridize { FileVectorOptionKey const templates( "cm:hybridize:templates" );  } }
 namespace cm { namespace hybridize { FileOptionKey const template_list( "cm:hybridize:template_list" );  } }
 namespace cm { namespace hybridize { IntegerVectorOptionKey const starting_template( "cm:hybridize:starting_template" );  } }
+namespace cm { namespace hybridize { BooleanOptionKey const realign_domains( "cm:hybridize:realign_domains" );  } }
 namespace cm { namespace hybridize { BooleanOptionKey const add_non_init_chunks( "cm:hybridize:add_non_init_chunks" );  } }
 namespace cm { namespace hybridize { StringOptionKey const ss( "cm:hybridize:ss" );  } }
 namespace cm { namespace hybridize { RealOptionKey const stage1_increase_cycles( "cm:hybridize:stage1_increase_cycles" );  } }
@@ -601,3 +604,13 @@ namespace DenovoProteinDesign { BooleanO
 namespace DenovoProteinDesign { FileOptionKey const secondary_structure_file( "DenovoProteinDesign:secondary_structure_file" );  }
 namespace DenovoProteinDesign { FileOptionKey const hydrophobic_polar_pattern( "DenovoProteinDesign:hydrophobic_polar_pattern" );  }
 namespace DenovoProteinDesign { BooleanOptionKey const use_template_sequence( "DenovoProteinDesign:use_template_sequence" );  }
+namespace DenovoProteinDesign { BooleanOptionKey const use_template_topology( "DenovoProteinDesign:use_template_topology" );  }
+namespace DenovoProteinDesign { FileOptionKey const create_from_template_pdb( "DenovoProteinDesign:create_from_template_pdb" );  }
+namespace DenovoProteinDesign { BooleanOptionKey const create_from_secondary_structure( "DenovoProteinDesign:create_from_secondary_structure" );  }
+namespace RBSegmentRelax { BooleanOptionKey const RBSegmentRelax( "RBSegmentRelax" );  }
+namespace RBSegmentRelax { FileOptionKey const input_pdb( "RBSegmentRelax:input_pdb" );  }
+namespace RBSegmentRelax { FileOptionKey const rb_file( "RBSegmentRelax:rb_file" );  }
+namespace RBSegmentRelax { RealOptionKey const cst_wt( "RBSegmentRelax:cst_wt" );  }
+namespace RBSegmentRelax { RealOptionKey const cst_width( "RBSegmentRelax:cst_width" );  }
+namespace RBSegmentRelax { StringOptionKey const cst_pdb( "RBSegmentRelax:cst_pdb" );  }
+namespace RBSegmentRelax { IntegerOptionKey const nrbmoves( "RBSegmentRelax:nrbmoves" );  }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen3.hh patched/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen3.hh
--- vanilla/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen3.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/OptionKeys.cc.gen3.hh	2012-06-10 16:12:40.712042014 +0200
@@ -1,13 +1,3 @@
-namespace DenovoProteinDesign { BooleanOptionKey const use_template_topology( "DenovoProteinDesign:use_template_topology" );  }
-namespace DenovoProteinDesign { FileOptionKey const create_from_template_pdb( "DenovoProteinDesign:create_from_template_pdb" );  }
-namespace DenovoProteinDesign { BooleanOptionKey const create_from_secondary_structure( "DenovoProteinDesign:create_from_secondary_structure" );  }
-namespace RBSegmentRelax { BooleanOptionKey const RBSegmentRelax( "RBSegmentRelax" );  }
-namespace RBSegmentRelax { FileOptionKey const input_pdb( "RBSegmentRelax:input_pdb" );  }
-namespace RBSegmentRelax { FileOptionKey const rb_file( "RBSegmentRelax:rb_file" );  }
-namespace RBSegmentRelax { RealOptionKey const cst_wt( "RBSegmentRelax:cst_wt" );  }
-namespace RBSegmentRelax { RealOptionKey const cst_width( "RBSegmentRelax:cst_width" );  }
-namespace RBSegmentRelax { StringOptionKey const cst_pdb( "RBSegmentRelax:cst_pdb" );  }
-namespace RBSegmentRelax { IntegerOptionKey const nrbmoves( "RBSegmentRelax:nrbmoves" );  }
 namespace RBSegmentRelax { IntegerOptionKey const nrboutercycles( "RBSegmentRelax:nrboutercycles" );  }
 namespace RBSegmentRelax { StringOptionKey const rb_scorefxn( "RBSegmentRelax:rb_scorefxn" );  }
 namespace RBSegmentRelax { BooleanOptionKey const skip_fragment_moves( "RBSegmentRelax:skip_fragment_moves" );  }
@@ -111,6 +101,7 @@ namespace optE { BooleanOptionKey const 
 namespace optE { FileOptionKey const starting_refEs( "optE:starting_refEs" );  }
 namespace optE { BooleanOptionKey const repeat_swarm_optimization_until_fitness_improves( "optE:repeat_swarm_optimization_until_fitness_improves" );  }
 namespace optE { BooleanOptionKey const design_with_minpack( "optE:design_with_minpack" );  }
+namespace optE { BooleanOptionKey const limit_bad_scores( "optE:limit_bad_scores" );  }
 namespace optE { namespace rescore { BooleanOptionKey const rescore( "optE:rescore" );  } }
 namespace optE { namespace rescore { FileOptionKey const weights( "optE:rescore:weights" );  } }
 namespace optE { namespace rescore { IntegerOptionKey const context_round( "optE:rescore:context_round" );  } }
@@ -208,7 +199,10 @@ namespace remodel { IntegerOptionKey con
 namespace remodel { IntegerOptionKey const dr_cycles( "remodel:dr_cycles" );  }
 namespace remodel { IntegerOptionKey const two_chain_tree( "remodel:two_chain_tree" );  }
 namespace remodel { IntegerOptionKey const repeat_structure( "remodel:repeat_structure" );  }
+namespace remodel { IntegerOptionKey const lh_ex_limit( "remodel:lh_ex_limit" );  }
 namespace remodel { BooleanOptionKey const cen_minimize( "remodel:cen_minimize" );  }
+namespace remodel { IntegerOptionKey const core_cutoff( "remodel:core_cutoff" );  }
+namespace remodel { IntegerOptionKey const boundary_cutoff( "remodel:boundary_cutoff" );  }
 namespace remodel { namespace domainFusion { BooleanOptionKey const domainFusion( "remodel:domainFusion" );  } }
 namespace remodel { namespace domainFusion { FileOptionKey const insert_segment_from_pdb( "remodel:domainFusion:insert_segment_from_pdb" );  } }
 namespace remodel { RealOptionKey const vdw( "remodel:vdw" );  }
@@ -235,6 +229,7 @@ namespace remodel { BooleanOptionKey con
 namespace remodel { namespace RemodelLoopMover { BooleanOptionKey const RemodelLoopMover( "remodel:RemodelLoopMover" );  } }
 namespace remodel { namespace RemodelLoopMover { IntegerOptionKey const max_linear_chainbreak( "remodel:RemodelLoopMover:max_linear_chainbreak" );  } }
 namespace remodel { namespace RemodelLoopMover { BooleanOptionKey const randomize_loops( "remodel:RemodelLoopMover:randomize_loops" );  } }
+namespace remodel { namespace RemodelLoopMover { BooleanOptionKey const use_loop_hash( "remodel:RemodelLoopMover:use_loop_hash" );  } }
 namespace remodel { namespace RemodelLoopMover { IntegerOptionKey const allowed_closure_attempts( "remodel:RemodelLoopMover:allowed_closure_attempts" );  } }
 namespace remodel { namespace RemodelLoopMover { IntegerOptionKey const simultaneous_cycles( "remodel:RemodelLoopMover:simultaneous_cycles" );  } }
 namespace remodel { namespace RemodelLoopMover { IntegerOptionKey const independent_cycles( "remodel:RemodelLoopMover:independent_cycles" );  } }
@@ -358,6 +353,10 @@ namespace rdc { FileOptionKey const sele
 namespace rdc { StringOptionKey const fit_method( "rdc:fit_method" );  }
 namespace rdc { RealVectorOptionKey const fixDa( "rdc:fixDa" );  }
 namespace rdc { RealVectorOptionKey const fixR( "rdc:fixR" );  }
+namespace csa { BooleanOptionKey const csa( "csa" );  }
+namespace csa { BooleanOptionKey const useZ( "csa:useZ" );  }
+namespace dc { BooleanOptionKey const dc( "dc" );  }
+namespace dc { BooleanOptionKey const useZ( "dc:useZ" );  }
 namespace antibody { BooleanOptionKey const antibody( "antibody" );  }
 namespace antibody { BooleanOptionKey const graft_l1( "antibody:graft_l1" );  }
 namespace antibody { StringOptionKey const l1_template( "antibody:l1_template" );  }
@@ -373,6 +372,16 @@ namespace antibody { BooleanOptionKey co
 namespace antibody { StringOptionKey const h3_template( "antibody:h3_template" );  }
 namespace antibody { BooleanOptionKey const model_h3( "antibody:model_h3" );  }
 namespace antibody { BooleanOptionKey const snugfit( "antibody:snugfit" );  }
+namespace antibody { BooleanOptionKey const refine_h3( "antibody:refine_h3" );  }
+namespace antibody { BooleanOptionKey const h3_filter( "antibody:h3_filter" );  }
+namespace antibody { RealOptionKey const h3_filter_tolerance( "antibody:h3_filter_tolerance" );  }
+namespace antibody { BooleanOptionKey const cter_insert( "antibody:cter_insert" );  }
+namespace antibody { BooleanOptionKey const flank_residue_min( "antibody:flank_residue_min" );  }
+namespace antibody { BooleanOptionKey const sc_min( "antibody:sc_min" );  }
+namespace antibody { BooleanOptionKey const rt_min( "antibody:rt_min" );  }
+namespace antibody { BooleanOptionKey const bad_nter( "antibody:bad_nter" );  }
+namespace antibody { StringOptionKey const remodel( "antibody:remodel" );  }
+namespace antibody { StringOptionKey const refine( "antibody:refine" );  }
 namespace antibody { BooleanOptionKey const snug_loops( "antibody:snug_loops" );  }
 namespace antibody { FileOptionKey const input_fv( "antibody:input_fv" );  }
 namespace antibody { BooleanOptionKey const camelid( "antibody:camelid" );  }
@@ -563,6 +572,12 @@ namespace pepspec { RealOptionKey const 
 namespace pepspec { RealOptionKey const prep_rot_std_dev( "pepspec:prep_rot_std_dev" );  }
 namespace pepspec { BooleanOptionKey const seq_align( "pepspec:seq_align" );  }
 namespace pepspec { StringOptionKey const prep_align_prot_to( "pepspec:prep_align_prot_to" );  }
+namespace sicdock { BooleanOptionKey const sicdock( "sicdock" );  }
+namespace sicdock { RealOptionKey const clash_dis( "sicdock:clash_dis" );  }
+namespace sicdock { RealOptionKey const contact_dis( "sicdock:contact_dis" );  }
+namespace sicdock { RealOptionKey const hash_2D_vs_3D( "sicdock:hash_2D_vs_3D" );  }
+namespace sicdock { RealOptionKey const term_min_expose( "sicdock:term_min_expose" );  }
+namespace sicdock { RealOptionKey const term_max_angle( "sicdock:term_max_angle" );  }
 namespace orbitals { BooleanOptionKey const orbitals( "orbitals" );  }
 namespace orbitals { BooleanOptionKey const Hpol( "orbitals:Hpol" );  }
 namespace orbitals { BooleanOptionKey const Haro( "orbitals:Haro" );  }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/out.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/out.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/out.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/out.OptionKeys.gen.hh	2012-06-10 16:12:40.715040986 +0200
@@ -46,6 +46,7 @@ namespace out { extern IntegerOptionKey 
 namespace out { extern StringVectorOptionKey const mute_warning; }
 namespace out { extern StringVectorOptionKey const mute_info; }
 namespace out { extern StringVectorOptionKey const mute_debug; }
+namespace out { extern StringVectorOptionKey const mute_trace; }
 namespace out { extern StringVectorOptionKey const unmute_error; }
 namespace out { extern StringVectorOptionKey const unmute_warning; }
 namespace out { extern StringVectorOptionKey const unmute_info; }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/qsar.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/qsar.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/qsar.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/qsar.OptionKeys.gen.hh	2012-06-10 16:12:40.717066822 +0200
@@ -23,6 +23,7 @@ namespace OptionKeys {
 
 namespace qsar { extern BooleanOptionKey const qsar; }
 namespace qsar { extern StringOptionKey const weights; }
+namespace qsar { extern StringOptionKey const grid_dir; }
 
 } // namespace OptionKeys
 } // namespace options
diff -rupN vanilla/rosetta_source/src/basic/options/keys/remodel.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/remodel.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/remodel.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/remodel.OptionKeys.gen.hh	2012-06-10 16:12:40.720040816 +0200
@@ -56,7 +56,10 @@ namespace remodel { extern IntegerOption
 namespace remodel { extern IntegerOptionKey const dr_cycles; }
 namespace remodel { extern IntegerOptionKey const two_chain_tree; }
 namespace remodel { extern IntegerOptionKey const repeat_structure; }
+namespace remodel { extern IntegerOptionKey const lh_ex_limit; }
 namespace remodel { extern BooleanOptionKey const cen_minimize; }
+namespace remodel { extern IntegerOptionKey const core_cutoff; }
+namespace remodel { extern IntegerOptionKey const boundary_cutoff; }
 namespace remodel { namespace domainFusion { extern BooleanOptionKey const domainFusion; } }
 namespace remodel { namespace domainFusion { extern FileOptionKey const insert_segment_from_pdb; } }
 namespace remodel { extern RealOptionKey const vdw; }
@@ -83,6 +86,7 @@ namespace remodel { extern BooleanOption
 namespace remodel { namespace RemodelLoopMover { extern BooleanOptionKey const RemodelLoopMover; } }
 namespace remodel { namespace RemodelLoopMover { extern IntegerOptionKey const max_linear_chainbreak; } }
 namespace remodel { namespace RemodelLoopMover { extern BooleanOptionKey const randomize_loops; } }
+namespace remodel { namespace RemodelLoopMover { extern BooleanOptionKey const use_loop_hash; } }
 namespace remodel { namespace RemodelLoopMover { extern IntegerOptionKey const allowed_closure_attempts; } }
 namespace remodel { namespace RemodelLoopMover { extern IntegerOptionKey const simultaneous_cycles; } }
 namespace remodel { namespace RemodelLoopMover { extern IntegerOptionKey const independent_cycles; } }
diff -rupN vanilla/rosetta_source/src/basic/options/keys/run.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/run.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/run.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/run.OptionKeys.gen.hh	2012-06-10 16:12:40.722040132 +0200
@@ -105,6 +105,7 @@ namespace run { extern IntegerOptionKey 
 namespace run { extern IntegerOptionKey const proc_id; }
 namespace run { extern BooleanOptionKey const exit_if_missing_heavy_atoms; }
 namespace run { extern RealOptionKey const show_simulation_in_pymol; }
+namespace run { extern BooleanOptionKey const keep_pymol_simulation_history; }
 
 } // namespace OptionKeys
 } // namespace options
diff -rupN vanilla/rosetta_source/src/basic/options/keys/score.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/score.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/score.OptionKeys.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/score.OptionKeys.gen.hh	2012-06-10 16:12:40.724069141 +0200
@@ -28,7 +28,7 @@ namespace score { extern StringOptionKey
 namespace score { extern StringOptionKey const soft_wts; }
 namespace score { extern BooleanOptionKey const docking_interface_score; }
 namespace score { extern StringOptionKey const custom_atom_pair; }
-namespace score { extern StringOptionKey const patch; }
+namespace score { extern FileVectorOptionKey const patch; }
 namespace score { extern BooleanOptionKey const empty; }
 namespace score { extern RealOptionKey const fa_max_dis; }
 namespace score { extern BooleanOptionKey const fa_Hatr; }
@@ -67,6 +67,8 @@ namespace score { extern BooleanOptionKe
 namespace score { extern StringOptionKey const fa_custom_pair_distance_file; }
 namespace score { extern RealOptionKey const disulf_matching_probe; }
 namespace score { extern RealVectorOptionKey const bonded_params; }
+namespace score { extern BooleanOptionKey const bonded_params_CHARMM_angle; }
+namespace score { extern BooleanOptionKey const bonded_params_CHARMM_length; }
 namespace score { extern RealOptionKey const pro_close_planar_constraint; }
 namespace score { extern BooleanOptionKey const linear_bonded_potential; }
 namespace score { namespace saxs { extern BooleanOptionKey const saxs; } }
@@ -91,6 +93,11 @@ namespace score { extern RealOptionKey c
 namespace score { extern RealOptionKey const hackelec_max_dis; }
 namespace score { extern RealOptionKey const hackelec_die; }
 namespace score { extern BooleanOptionKey const hackelec_r_option; }
+namespace score { extern StringOptionKey const nmer_ref_energies; }
+namespace score { extern StringOptionKey const nmer_pssm; }
+namespace score { extern StringOptionKey const nmer_pssm_list; }
+namespace score { extern RealOptionKey const nmer_pssm_scorecut; }
+namespace score { extern IntegerOptionKey const nmer_ref_seq_length; }
 
 } // namespace OptionKeys
 } // namespace options
diff -rupN vanilla/rosetta_source/src/basic/options/keys/sicdock.OptionKeys.gen.hh patched/rosetta_source/src/basic/options/keys/sicdock.OptionKeys.gen.hh
--- vanilla/rosetta_source/src/basic/options/keys/sicdock.OptionKeys.gen.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/basic/options/keys/sicdock.OptionKeys.gen.hh	2012-06-10 16:12:40.727040326 +0200
@@ -0,0 +1,35 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   basic/options/keys/sicdock.OptionKeys.gen.hh
+/// @brief  basic::options::OptionKeys collection
+/// @author Stuart G. Mentzer (Stuart_Mentzer@objexx.com)
+/// @author James M. Thompson (tex@u.washington.edu)
+
+#ifndef INCLUDED_basic_options_keys_sicdock_OptionKeys_gen_HH
+#define INCLUDED_basic_options_keys_sicdock_OptionKeys_gen_HH
+
+// Unit headers
+#include <basic/options/keys/OptionKeys.hh>
+
+namespace basic {
+namespace options {
+namespace OptionKeys {
+
+namespace sicdock { extern BooleanOptionKey const sicdock; }
+namespace sicdock { extern RealOptionKey const clash_dis; }
+namespace sicdock { extern RealOptionKey const contact_dis; }
+namespace sicdock { extern RealOptionKey const hash_2D_vs_3D; }
+namespace sicdock { extern RealOptionKey const term_min_expose; }
+namespace sicdock { extern RealOptionKey const term_max_angle; }
+
+} // namespace OptionKeys
+} // namespace options
+} // namespace basic
+
+#endif
diff -rupN vanilla/rosetta_source/src/basic/options/option.cc.gen.hh patched/rosetta_source/src/basic/options/option.cc.gen.hh
--- vanilla/rosetta_source/src/basic/options/option.cc.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/option.cc.gen.hh	2012-06-10 16:12:40.758041165 +0200
@@ -29,6 +29,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::in::remember_unrecognized_res, "Ignore unrecognized residues, but remember them in PDBInfo." ).def(false);
 option.add( basic::options::OptionKeys::in::remember_unrecognized_water, "Remember waters along with other unrecognized residues." ).def(false);
 option.add( basic::options::OptionKeys::in::detect_disulf, "Forcably enable or disable disulfide detection. When unspecified, rosetta conservatively detects disulfides in full atom input based on SG distance, but will not form centroid disulfides. Setting `-detect_disulf true` will force  aggressive disulfide detection in centroid poses based on CB distance. Setting `-detect_disulf false` disables all detection, even in full atom poses. Note that disabling disulfides causes severe clashes for native disulfides." ).legal(true).legal(false);
+option.add( basic::options::OptionKeys::in::detect_disulf_tolerance, "disulf tolerance" ).def(0.5);
 option.add( basic::options::OptionKeys::in::fix_disulf, "Specify disulfide connectivity via a file. Disulfides are specified as two whitespace-seperated residue indicies per line. This option replaces the old '-run:fix_disulf' option." );
 option.add( basic::options::OptionKeys::in::use_stupid_foldtree_format, "use the fold-tree format that existed for one week after revision 21447" ).def(false);
 option.add( basic::options::OptionKeys::in::target_residues, "which residue numbers to pass for getDistConstraints" );
@@ -65,6 +66,8 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::in::file::extra_res_database_resname_list, "Path to a list of residue names to be read in from the residue database.  The list should have one residue name per line" );
 option.add( basic::options::OptionKeys::in::file::extra_res_cen, ".params file(s) for new centroid residue types (e.g. ligands)" );
 option.add( basic::options::OptionKeys::in::file::extra_res_path, "directories with .params files.  Only files containing 'param' will be chosen" );
+option.add( basic::options::OptionKeys::in::file::extra_patch_fa, "patch files for full atom variants not specified in the database" );
+option.add( basic::options::OptionKeys::in::file::extra_patch_cen, "patch files for centroid atom variants not specified in the database" );
 option.add( basic::options::OptionKeys::in::file::frag3, "No description" );
 option.add( basic::options::OptionKeys::in::file::frag9, "No description" );
 option.add( basic::options::OptionKeys::in::file::fragA, "No description" );
@@ -91,6 +94,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::in::file::silent_read_through_errors, "will ignore decoys with errors and continue reading" ).def(false);
 option.add( basic::options::OptionKeys::in::file::silent_score_prefix, "Prefix that is appended to all scores read in from a silent-file" ).def("");
 option.add( basic::options::OptionKeys::in::file::silent_select_random, "Select a random subset of this number of decoys from every silent-file read" ).def(0);
+option.add( basic::options::OptionKeys::in::file::skip_failed_simulations, "Ignore failed simulations (prefixed by W_) during silent file input. Existing behavior is preserved by default." ).def(false);
 option.add( basic::options::OptionKeys::in::file::silent_scores_wanted, "Only put these silent-scores into the Pose." );
 option.add( basic::options::OptionKeys::in::file::fasta, "Fasta-formatted sequence file" );
 option.add( basic::options::OptionKeys::in::file::pssm, "NCBI BLAST formatted position-specific scoring matrix" );
@@ -109,6 +113,8 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::in::file::template_pdb, "Name of input template PDB files for comparative modeling" );
 option.add( basic::options::OptionKeys::in::file::template_silent, "input templates for comparative modeling -- tag needs to fit alignment id" );
 option.add( basic::options::OptionKeys::in::file::rdc, "Experimental NMR Residual Dipolar Coupling File --- one file per alignment medium" );
+option.add( basic::options::OptionKeys::in::file::csa, "Experimental NMR Chemical Shift Anisotropy File" );
+option.add( basic::options::OptionKeys::in::file::dc, "Experimental NMR Dipolar Coupling File" );
 option.add( basic::options::OptionKeys::in::file::burial, "WESA-formatted burial prediction" );
 option.add( basic::options::OptionKeys::in::file::vall, "Fragment database file, e.g vall.dat.2006-05-05" ).def("/sampling/filtered.vall.dat.2006-05-05");
 option.add( basic::options::OptionKeys::in::file::rescore, "Governs whether input poses are rescored or not in not_universal_main, defaults to false." ).def(false);
@@ -130,6 +136,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::mysql::port, "mySQL database port" );
 option.add( basic::options::OptionKeys::qsar::qsar, "qsar option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::qsar::weights, "select qsar weight set to use" ).def("standard");
+option.add( basic::options::OptionKeys::qsar::grid_dir, "Directory to store grids in" );
 option.add( basic::options::OptionKeys::residues::residues, "residues option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::residues::patch_selectors, "allow patch files that have CMDLINE_SELECTOR tags can be switched on with this option" );
 option.add( basic::options::OptionKeys::PCS::PCS, "PCS option group" ).legal(true).def(true);
@@ -165,6 +172,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::out::mute_warning, "Mute specified Tracer chanels for msgs with priority warning and less" );
 option.add( basic::options::OptionKeys::out::mute_info, "Mute specified Tracer channels for msgs with priority info and less" );
 option.add( basic::options::OptionKeys::out::mute_debug, "Mute specified Tracer channels for msgs with priority debug and less" );
+option.add( basic::options::OptionKeys::out::mute_trace, "Mute specified Tracer channels for msgs with priority debug and less" );
 option.add( basic::options::OptionKeys::out::unmute_error, "Unmute specified Tracer channels for msgs of priority ERROR and more" );
 option.add( basic::options::OptionKeys::out::unmute_warning, "Unmute specified Tracer chanels for msgs with priority warning and more" );
 option.add( basic::options::OptionKeys::out::unmute_info, "Unmute specified Tracer channels for msgs with priority info and more" );
@@ -397,6 +405,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::run::proc_id, "give process number... Jobdistributor will only work on proc_id mod nproc part of work " ).def(0);
 option.add( basic::options::OptionKeys::run::exit_if_missing_heavy_atoms, "quit if heavy atoms missing in pdb" ).def(false);
 option.add( basic::options::OptionKeys::run::show_simulation_in_pymol, "Attach PyMOL observer to pose at the beginning of the simulation. Refreshes pose every [argument] seconds, default 5.  Don't forget to run the PyMOLPyRosettaServer.py script within PyMOL!" ).def(5.0);
+option.add( basic::options::OptionKeys::run::keep_pymol_simulation_history, "Keep history when using show_simulation_in_pymol flag?" ).def(false);
 option.add( basic::options::OptionKeys::jd2::jd2, "jd2 option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::jd2::pose_input_stream, "Use PoseInputStream classes for Pose input" ).def(false);
 option.add( basic::options::OptionKeys::jd2::lazy_silent_file_reader, "use lazy silent file reader in job distributor, read in a structure only when you need to" ).def(false);
@@ -606,13 +615,13 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::abinitio::HD_penalty, "penatlty for each inconsistent pairing with HD data " ).def(0.1);
 option.add( basic::options::OptionKeys::abinitio::HD_fa_penalty, "penalty for each Hbond donor inconsistent with HD donor" ).def(0.1);
 option.add( basic::options::OptionKeys::abinitio::sheet_edge_pred, "file with interior/exterior predictions for strands" );
-
-}
-inline void add_rosetta_options_1( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::abinitio::SEP_score_scalling, "scalling factor" ).def(1.0);
+option.add( basic::options::OptionKeys::abinitio::SEP_score_scalling, "scalling factor" ).def(1.0);
 option.add( basic::options::OptionKeys::fold_cst::fold_cst, "fold_cst option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::fold_cst::constraint_skip_rate, "if e.g., 0.95 it will randomly select 5% if the constraints each round -- full-cst score in  extra column" ).def(0);
 option.add( basic::options::OptionKeys::fold_cst::violation_skip_basis, "local skip_rate is viol/base" ).def(100);
-option.add( basic::options::OptionKeys::fold_cst::violation_skip_ignore, "no skip for numbers below this level" ).def(10);
+
+}
+inline void add_rosetta_options_1( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::fold_cst::violation_skip_ignore, "no skip for numbers below this level" ).def(10);
 option.add( basic::options::OptionKeys::fold_cst::keep_skipped_csts, "final score only with active constraints" ).def(false);
 option.add( basic::options::OptionKeys::fold_cst::no_minimize, "No minimization moves in fold_constraints protocol. Useful for testing wheather fragment moves alone can recapitulate a given structure." ).def(false);
 option.add( basic::options::OptionKeys::fold_cst::force_minimize, "Minimization moves in fold_constraints protocol also if no constraints present" ).def(false);
@@ -709,6 +718,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::abrelax::fail_unclosed, "structures which don't close loops are reported as FAIL_DO_NOT_RETRY" ).def(false);
 option.add( basic::options::OptionKeys::chemical::chemical, "chemical option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::chemical::exclude_patches, "Names of the residue-type-set patches which should not be applied; if you know which patches you do not need for a particular run, this flag can reduce your memory use" );
+option.add( basic::options::OptionKeys::chemical::include_patches, "Names of the residue-type-set patches which should be applied even if excluded/commented out in patches.txt; useful for testing non-default patches" );
 option.add( basic::options::OptionKeys::score::score_pose_cutpoint_variants, "Include cutpoint variants in the pose during linear chainbreak" ).def(false);
 option.add( basic::options::OptionKeys::score::score, "scorefunction option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::score::weights, "Name of weights file (without extension .wts)" ).def("standard");
@@ -755,6 +765,8 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::score::fa_custom_pair_distance_file, "Name of custom pair distance energy file" ).def("");
 option.add( basic::options::OptionKeys::score::disulf_matching_probe, "Size of probe to use in disulfide matching score" ).def(2.5);
 option.add( basic::options::OptionKeys::score::bonded_params, "Spring constants for bonded parameters [length,angle,torsion,proton-torsion] (default 600,300,300,60)" );
+option.add( basic::options::OptionKeys::score::bonded_params_CHARMM_angle, "use CHARMM spring constants" );
+option.add( basic::options::OptionKeys::score::bonded_params_CHARMM_length, "use CHARMM spring constants" );
 option.add( basic::options::OptionKeys::score::pro_close_planar_constraint, "stdev of CD,N,CA,prevC trigonal planar constraint in pro_close energy method" ).def(0.1);
 option.add( basic::options::OptionKeys::score::linear_bonded_potential, "use linear (instead of quadratic) bonded potential" ).def(false);
 option.add( basic::options::OptionKeys::score::saxs::saxs, "saxs option group" ).legal(true).def(true);
@@ -779,10 +791,16 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::score::hackelec_max_dis, "changes the maximum distance cut-off for hack-elec energy" ).def(5.5);
 option.add( basic::options::OptionKeys::score::hackelec_die, "changes the dielectric constant for hack-elec energy" ).def(10.0);
 option.add( basic::options::OptionKeys::score::hackelec_r_option, "changes the dielectric from distance dependent to distance independent" ).def(false);
+option.add( basic::options::OptionKeys::score::nmer_ref_energies, "nmer ref energies database filename" );
+option.add( basic::options::OptionKeys::score::nmer_pssm, "nmer pssm database filename" );
+option.add( basic::options::OptionKeys::score::nmer_pssm_list, "nmer pssm database filename" );
+option.add( basic::options::OptionKeys::score::nmer_pssm_scorecut, "nmer pssm scorecut gate for ignoring lowscore nmers" ).def(0.0);
+option.add( basic::options::OptionKeys::score::nmer_ref_seq_length, "length of nmers in nmer_ref score" ).def(9);
 option.add( basic::options::OptionKeys::corrections::corrections, "corrections option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::corrections::correct, "turn on default corrections:-corrections::chemical:icoor_05_2009-corrections::score:p_aa_pp scoring/score_functions/P_AA_pp/P_AA_pp_08.2009-corrections::score:p_aa_pp_nogridshift-corrections::score:p_aa_pp_nogridshift-corrections::score:rama_not_squared-corrections::score:rama_map scoring/score_functions/rama/Rama.10.2009.yfsong.dat-scoring::hbond_params helix_hb_06_2009-corrections::score:hbond_fade 1.9 2.3 2.3 2.6 0.3 0.7 0.0 0.05-corrections::score:ch_o_bond_potential scoring/score_functions/carbon_hbond/ch_o_bond_potential_near_min_yf.dat" ).def(false);
 option.add( basic::options::OptionKeys::corrections::score::score, "score option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::corrections::score::no_his_his_pairE, "Set pair term for His-His to zero" );
+option.add( basic::options::OptionKeys::corrections::score::no_his_DE_pairE, "Set pair term for His-Glu and His-Asp to zero" );
 option.add( basic::options::OptionKeys::corrections::score::hbond_His_Phil_fix, "Phil's fix on Histidine interaction angular dependence" );
 option.add( basic::options::OptionKeys::corrections::score::helix_hb_06_2009, "Helix backbone-backbone hbond potential with a different angular dependence" );
 option.add( basic::options::OptionKeys::corrections::score::use_incorrect_hbond_deriv, "Use deprecated hbond derivative calculation." ).def(false);
@@ -809,6 +827,8 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::corrections::score::hb_sp2_amp, "Experimental term for hydrogen bonds to sp2 acceptors: sets the amplitude of the sp2 hydrogen bond (greater than 1 upweights sp2 hydrogen bonds)" ).def(2.0);
 option.add( basic::options::OptionKeys::corrections::score::hb_sp2_peak_heigh_above_trough, "Experimental term for hydrogen bonds to sp2 acceptors: sets the dynamic range between the most potent sp2 hydrogen bonds and the least potent" ).def(3.0);
 option.add( basic::options::OptionKeys::corrections::score::hbond_measure_sp3acc_BAH_from_hvy, "If true, then the BAH angle for sp3 (aka hydroxyl) acceptors is measured donor-hydrogen--acceptor-heavyatom--heavyatom-base instead of donor-hydrogen--accptor-heavyatom--hydroxyl-hydrogen" ).def(false);
+option.add( basic::options::OptionKeys::corrections::score::use_bicubic_interpolation, "Instead of using bilinear interpolation to evaluate the Ramachandran, P_AA_pp and Dunbrack potentials, use bicubic interpolation.  Avoids pile-ups at the grid boundaries where discontinuities in the derivatives frustrate the minimizer" ).def(false);
+option.add( basic::options::OptionKeys::corrections::score::dun_normsd, "Use height-normalized guassian distributions to model p(chi|phi,psi) instead of height-unnormalized gaussians" ).def(false);
 option.add( basic::options::OptionKeys::corrections::chemical::chemical, "chemical option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::corrections::chemical::icoor_05_2009, "New set of idealized coordinates for full atom, 05-2009" );
 option.add( basic::options::OptionKeys::corrections::chemical::parse_charge, "Use PARSE charge set." );
@@ -956,6 +976,8 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::cluster::max_cluster_seeds, "Do not calculate initial cluster centers for more then this many structuers" ).def(500);
 option.add( basic::options::OptionKeys::cluster::radius, "Cluster radius" ).def(3.0);
 option.add( basic::options::OptionKeys::cluster::limit_cluster_size, "For each cluster only retain top N " ).def(-1);
+option.add( basic::options::OptionKeys::cluster::limit_cluster_size_percent, "0 to 1. For each cluster only retain top N % " );
+option.add( basic::options::OptionKeys::cluster::random_limit_cluster_size_percent, "0 to 1. For each cluster only retain random N % " );
 option.add( basic::options::OptionKeys::cluster::limit_clusters, "Only retain largest N clusters" ).def(100);
 option.add( basic::options::OptionKeys::cluster::limit_total_structures, "Only retain the first N structures (ordered by cluster number)" ).def(-1);
 option.add( basic::options::OptionKeys::cluster::max_total_cluster, "Only ever make N clusters or less" ).def(1000);
@@ -994,6 +1016,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::mc::convergence_check_frequency, "how often check for convergences in MC object?" ).def(100);
 option.add( basic::options::OptionKeys::mc::known_structures, "specify a filename of a silent-file containing known structures" ).def("known_structs.in");
 option.add( basic::options::OptionKeys::mc::max_rmsd_against_known_structures, "stop sampling if rmsd to a known-structure is lower than X" ).def(1.5);
+option.add( basic::options::OptionKeys::mc::excluded_residues_from_rmsd, "residues that are not used for RMSD computation in pool" );
 option.add( basic::options::OptionKeys::mc::heat_convergence_check, "jump out of current abinitio run if X unsuccesful mc-trials reached" ).def(0);
 option.add( basic::options::OptionKeys::batch_relax::batch_relax, "batch_relax option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::batch_relax::batch_size, "Size of batches - note that thsie affects memory usage significantly" ).def(100);
@@ -1194,13 +1217,14 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::lh::num_partitions, "Number of partitions to split the database into" ).def(1);
 option.add( basic::options::OptionKeys::lh::db_path, "Path to database" ).def("");
 option.add( basic::options::OptionKeys::lh::exclude_homo, "Use a homolog exclusion filter" ).def(false);
+option.add( basic::options::OptionKeys::lh::bss, "Use BinaryProteinSilentStruct instead of ProteinSilentStruct (needed for nonideal)" ).def(false);
 option.add( basic::options::OptionKeys::lh::refstruct, "File with a target reference structure" ).def("");
 option.add( basic::options::OptionKeys::lh::homo_file, "File containing homologs to exclude" ).def("");
 option.add( basic::options::OptionKeys::lh::createdb_rms_cutoff, "RMS cutoff used for throwing out similar fragments." ).def(0).def(0).def(0);
-option.add( basic::options::OptionKeys::lh::min_bbrms, "No description" ).def(0.0);
-option.add( basic::options::OptionKeys::lh::max_bbrms, "No description" ).def(100000.0);
-option.add( basic::options::OptionKeys::lh::min_rms, "No description" ).def(0.0);
-option.add( basic::options::OptionKeys::lh::max_rms, "No description" ).def(100.0);
+option.add( basic::options::OptionKeys::lh::min_bbrms, "No description" ).def(20.0);
+option.add( basic::options::OptionKeys::lh::max_bbrms, "No description" ).def(1400.0);
+option.add( basic::options::OptionKeys::lh::min_rms, "No description" ).def(0.5);
+option.add( basic::options::OptionKeys::lh::max_rms, "No description" ).def(4.0);
 option.add( basic::options::OptionKeys::lh::filter_by_phipsi, "No description" ).def(true);
 option.add( basic::options::OptionKeys::lh::max_radius, "No description" ).def(4);
 option.add( basic::options::OptionKeys::lh::max_struct, "No description" ).def(10);
@@ -1211,11 +1235,11 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::lh::rounds, "No description" ).def(100);
 option.add( basic::options::OptionKeys::lh::jobname, "Prefix (Ident string) !" ).def("default");
 option.add( basic::options::OptionKeys::lh::max_lib_size, "No description" ).def(2);
+option.add( basic::options::OptionKeys::lh::max_emperor_lib_size, "No description" ).def(25);
+option.add( basic::options::OptionKeys::lh::max_emperor_lib_round, "No description" ).def(0);
 
 }
-inline void add_rosetta_options_2( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::lh::max_emperor_lib_size, "No description" ).def(25);
-option.add( basic::options::OptionKeys::lh::max_emperor_lib_round, "No description" ).def(0);
-option.add( basic::options::OptionKeys::lh::library_expiry_time, "No description" ).def(2400);
+inline void add_rosetta_options_2( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::lh::library_expiry_time, "No description" ).def(2400);
 option.add( basic::options::OptionKeys::lh::objective_function, "What to use as the objective function" ).def("score");
 option.add( basic::options::OptionKeys::lh::expire_after_rounds, "If set to > 0 this causes the Master to expire a structure after it has gone through this many cycles" ).def(0);
 option.add( basic::options::OptionKeys::lh::mpi_resume, "Prefix (Ident string) for resuming a previous job!" );
@@ -1231,6 +1255,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::lh::rms_limit, "How to deal with returned relaxed structures" ).def(2.0);
 option.add( basic::options::OptionKeys::lh::centroid_only, "false" ).def(false);
 option.add( basic::options::OptionKeys::lh::write_centroid_structs, "Output raw loophashed decoys as well as relaxed ones" ).def(false);
+option.add( basic::options::OptionKeys::lh::write_all_fa_structs, "Write out all structures returned from batch relax" ).def(false);
 option.add( basic::options::OptionKeys::lh::sandbox, "Sand box mode" ).def(false);
 option.add( basic::options::OptionKeys::lh::create_db, "Make database with this loopsize" ).def(false);
 option.add( basic::options::OptionKeys::lh::sample_weight_file, "Holds the initial per residue sample weights" );
@@ -1266,6 +1291,9 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::cmiles::cmiles, "cmiles option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::cmiles::kcluster::kcluster, "kcluster option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::cmiles::kcluster::num_clusters, "Number of clusters to use during k clustering" );
+option.add( basic::options::OptionKeys::cmiles::jumping::jumping, "jumping option group" ).legal(true).def(true);
+option.add( basic::options::OptionKeys::cmiles::jumping::resi, "Residue i" );
+option.add( basic::options::OptionKeys::cmiles::jumping::resj, "Residue j" );
 option.add( basic::options::OptionKeys::james::james, "james option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::james::min_seqsep, "No description" ).def(0);
 option.add( basic::options::OptionKeys::james::atom_names, "No description" ).def(utility::vector1<std::string>());
@@ -1578,6 +1606,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::cm::hybridize::templates, "Input list of template files" );
 option.add( basic::options::OptionKeys::cm::hybridize::template_list, "Input list of templates, constaints, cluster, and weights" );
 option.add( basic::options::OptionKeys::cm::hybridize::starting_template, "Define starting templates" );
+option.add( basic::options::OptionKeys::cm::hybridize::realign_domains, "domain parse and realign the starting templates" ).def(true);
 option.add( basic::options::OptionKeys::cm::hybridize::add_non_init_chunks, "non chunks from templates other than the initial one" ).def(false);
 option.add( basic::options::OptionKeys::cm::hybridize::ss, "secondary structure elements used to split the pose" ).def("HE");
 option.add( basic::options::OptionKeys::cm::hybridize::stage1_increase_cycles, "Scale stage 1 cycles" ).def(1.0);
@@ -1666,7 +1695,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::loops::kic_recover_last, "If true, do not recover lowest scoring pose after each outer cycle and at end of protocol in kic remodel and refine" ).def(false);
 option.add( basic::options::OptionKeys::loops::kic_min_after_repack, "Should the kinematic closure refine protocol minimize after repacking steps" ).def(false);
 option.add( basic::options::OptionKeys::loops::optimize_only_kic_region_sidechains_after_move, "Should we perform rotamer trials and minimization after every KIC move but only within the loops:neighbor_dist of the residues in the moved KIC segment. Useful to speed up when using very large loop definitions (like when whole chains are used for ensemble generation)." ).def(false);
-option.add( basic::options::OptionKeys::loops::max_kic_build_attempts, "Number of attempts at initial kinematic closure loop building" ).def(100);
+option.add( basic::options::OptionKeys::loops::max_kic_build_attempts, "Number of attempts at initial kinematic closure loop building" ).def(10000);
 option.add( basic::options::OptionKeys::loops::remodel_kic_attempts, "Number of kic attempts per inner cycle during perturb_kic protocol" ).def(300);
 option.add( basic::options::OptionKeys::loops::max_kic_perturber_samples, "Maximum number of kinematic perturber samples" ).def(2000);
 option.add( basic::options::OptionKeys::loops::nonpivot_torsion_sampling, "enables sampling of non-pivot residue torsions when the kinematic loop closure segment length is > 3" ).legal(true).legal(false).def(true);
@@ -1816,9 +1845,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::DenovoProteinDesign::secondary_structure_file, "has fasta file format - describes secondary structure of desired target with H/C/E" );
 option.add( basic::options::OptionKeys::DenovoProteinDesign::hydrophobic_polar_pattern, "has fasta file format - describes hydrophobic(B) polar(P) pattern" );
 option.add( basic::options::OptionKeys::DenovoProteinDesign::use_template_sequence, "use the template pdbs sequence when creating starting structures" ).def(false);
-
-}
-inline void add_rosetta_options_3( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::DenovoProteinDesign::use_template_topology, "use templates phi/psi in loops and begin/end helix/sheet generate only template like starting structures" ).def(false);
+option.add( basic::options::OptionKeys::DenovoProteinDesign::use_template_topology, "use templates phi/psi in loops and begin/end helix/sheet generate only template like starting structures" ).def(false);
 option.add( basic::options::OptionKeys::DenovoProteinDesign::create_from_template_pdb, "create starting structure from a template pdb, follow with pdb name" );
 option.add( basic::options::OptionKeys::DenovoProteinDesign::create_from_secondary_structure, "create starting structure from a file that contains H/C/E to describe topology or B/P pattern, has fasta file format" ).def(false);
 option.add( basic::options::OptionKeys::RBSegmentRelax::RBSegmentRelax, "RBSegmentRelax option group" ).legal(true).def(true);
@@ -1828,7 +1855,9 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::RBSegmentRelax::cst_width, "Width of harmonic constraints on csts" ).def(1.0);
 option.add( basic::options::OptionKeys::RBSegmentRelax::cst_pdb, "PDB file from which to draw constraints" ).def("--");
 option.add( basic::options::OptionKeys::RBSegmentRelax::nrbmoves, "number of rigid-body moves" ).def(100);
-option.add( basic::options::OptionKeys::RBSegmentRelax::nrboutercycles, "number of rigid-body moves" ).def(5);
+
+}
+inline void add_rosetta_options_3( utility::options::OptionCollection &option ) {option.add( basic::options::OptionKeys::RBSegmentRelax::nrboutercycles, "number of rigid-body moves" ).def(5);
 option.add( basic::options::OptionKeys::RBSegmentRelax::rb_scorefxn, "number of rigid-body moves" ).def("score5");
 option.add( basic::options::OptionKeys::RBSegmentRelax::skip_fragment_moves, "omit fragment insertions (in SS elements)" ).def(false);
 option.add( basic::options::OptionKeys::RBSegmentRelax::skip_seqshift_moves, "omit sequence shifting moves" ).def(false);
@@ -1931,6 +1960,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::optE::starting_refEs, "IterativeOptEDriver flag: specify a weights file to read reference energies from; do not optimize reference energies in the first round of weight fitting" );
 option.add( basic::options::OptionKeys::optE::repeat_swarm_optimization_until_fitness_improves, "After the first time though the particle swarm optimization phase, if the end fitness is not better than the start fitness, recreate the swarm around the start dofs and repeat the swarm optimization." ).def(false);
 option.add( basic::options::OptionKeys::optE::design_with_minpack, "Use the min-packer to design in the sequence recovery stages." ).def(false);
+option.add( basic::options::OptionKeys::optE::limit_bad_scores, "Quit after 100,000 inf or NaN errors in optE objective function" );
 option.add( basic::options::OptionKeys::optE::rescore::rescore, "rescore option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::optE::rescore::weights, "Weight set to use when rescoring optE partition functions" );
 option.add( basic::options::OptionKeys::optE::rescore::context_round, "Integer of the context PDBs generated during design to use to measure the pNatAA" );
@@ -2028,7 +2058,10 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::remodel::dr_cycles, "number of design-refine cycles to use" ).def(3);
 option.add( basic::options::OptionKeys::remodel::two_chain_tree, "label the start of the second chain" );
 option.add( basic::options::OptionKeys::remodel::repeat_structure, "build identical repeats this many times" ).def(1);
+option.add( basic::options::OptionKeys::remodel::lh_ex_limit, "loophasing neighboring bin expansion limit" ).def(5);
 option.add( basic::options::OptionKeys::remodel::cen_minimize, "centroid minimization after fragment building" ).def(false);
+option.add( basic::options::OptionKeys::remodel::core_cutoff, "number of neighbors required to consider core in auto design" ).def(15);
+option.add( basic::options::OptionKeys::remodel::boundary_cutoff, "number of neighbors required to consider boundary in auto design" ).def(10);
 option.add( basic::options::OptionKeys::remodel::domainFusion::domainFusion, "domainFusion option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::remodel::domainFusion::insert_segment_from_pdb, "segment pdb file to be inserted [insert pdb file name]." ).def("");
 option.add( basic::options::OptionKeys::remodel::vdw, "set vdw weight" ).def(1.0);
@@ -2055,6 +2088,7 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::RemodelLoopMover, "RemodelLoopMover option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::max_linear_chainbreak, "linear chainbreak is <= this value, loop is considered closed (default 0.07) " );
 option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::randomize_loops, "randomize loops prior to running main protocol (default false)" );
+option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::use_loop_hash, "centroid build with loop hash (default false)" );
 option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::allowed_closure_attempts, "the allowed number of overall closure attempts (default 1)" );
 option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::simultaneous_cycles, "the number of simultaneous closure cycles to perform (default 2)" );
 option.add( basic::options::OptionKeys::remodel::RemodelLoopMover::independent_cycles, "the number of independent closure cycles to perform (default 8)" );
@@ -2161,8 +2195,8 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::canonical_sampling::out::out, "out option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::canonical_sampling::out::new_structures, "" ).def("discovered_decoys.out");
 option.add( basic::options::OptionKeys::rdc::rdc, "rdc option group" ).legal(true).def(true);
-option.add( basic::options::OptionKeys::rdc::correct_NH_length, "fix N-H bond-vector to 1.04 as measured in ottiger&bax 98" );
-option.add( basic::options::OptionKeys::rdc::reduced_couplings, "gives more equal weights to different bond-vectors" );
+option.add( basic::options::OptionKeys::rdc::correct_NH_length, "fix N-H bond-vector to 1.04 as measured in ottiger&bax 98" ).def(false);
+option.add( basic::options::OptionKeys::rdc::reduced_couplings, "gives more equal weights to different bond-vectors" ).def(false);
 option.add( basic::options::OptionKeys::rdc::weights, "specify weights for individual residues ( works for all couplings at this reside)" );
 option.add( basic::options::OptionKeys::rdc::iterate_weights, "do a wRDC computation, i.e., iterate tensor calculation until weights are ~exp ( -dev2/sigma )" ).def(1);
 option.add( basic::options::OptionKeys::rdc::segment_file, "Definition of rigid segments for alignment tensor optimization" );
@@ -2178,6 +2212,10 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::rdc::fit_method, "No description" ).legal("svd").legal("nls").def("svd");
 option.add( basic::options::OptionKeys::rdc::fixDa, "No description" );
 option.add( basic::options::OptionKeys::rdc::fixR, "No description" );
+option.add( basic::options::OptionKeys::csa::csa, "csa option group" ).legal(true).def(true);
+option.add( basic::options::OptionKeys::csa::useZ, "Use absolute zaxis for scoring csa" );
+option.add( basic::options::OptionKeys::dc::dc, "dc option group" ).legal(true).def(true);
+option.add( basic::options::OptionKeys::dc::useZ, "Use absolute zaxis for scoring dc" );
 option.add( basic::options::OptionKeys::antibody::antibody, "Antibody option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::antibody::graft_l1, "Graft CDR L1 from template" ).def(false);
 option.add( basic::options::OptionKeys::antibody::l1_template, "Choose specified template for CDR L1 grafting" ).def("l1.pdb");
@@ -2193,6 +2231,16 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::antibody::h3_template, "Choose specified template for CDR H3 grafting" ).def("h3.pdb");
 option.add( basic::options::OptionKeys::antibody::model_h3, "Model CDR H3 from scratch using fragments" ).def(false);
 option.add( basic::options::OptionKeys::antibody::snugfit, "Adjust relative orientation of VL-VH" ).def(false);
+option.add( basic::options::OptionKeys::antibody::refine_h3, "Refine CDR H3 in high resolution" ).def(true);
+option.add( basic::options::OptionKeys::antibody::h3_filter, "filter decoys having neither kink nor extend form" ).def(true);
+option.add( basic::options::OptionKeys::antibody::h3_filter_tolerance, "maximum number of tries for the filter" ).def(5);
+option.add( basic::options::OptionKeys::antibody::cter_insert, "insert kind or extend Ab fragments to CDR H3" ).def(true);
+option.add( basic::options::OptionKeys::antibody::flank_residue_min, "minimize flank residues of CDR H3 during high-reso refinement" ).def(true);
+option.add( basic::options::OptionKeys::antibody::sc_min, "minimize the side chain after finishing the rotamer packing" ).def(false);
+option.add( basic::options::OptionKeys::antibody::rt_min, "minimize the rotamer each packing" ).def(false);
+option.add( basic::options::OptionKeys::antibody::bad_nter, "the n-terminal is bad because of bad H3 grafting" ).def(true);
+option.add( basic::options::OptionKeys::antibody::remodel, "Choose a perturb method to model H3 in centroid mode" ).def("legacy_perturb_ccd");
+option.add( basic::options::OptionKeys::antibody::refine, "Choose a refine method to model H3 in high-resol model" ).def("legacy_perturb_ccd");
 option.add( basic::options::OptionKeys::antibody::snug_loops, "Allow CDR loop backbone flexibility during minimization" ).def(false);
 option.add( basic::options::OptionKeys::antibody::input_fv, "input antibody variable (Fv) region" ).def("FR02.pdb");
 option.add( basic::options::OptionKeys::antibody::camelid, "Camelid input with only heavy (VH) chain" ).def(false);
@@ -2383,6 +2431,12 @@ option.add( basic::options::OptionKeys::
 option.add( basic::options::OptionKeys::pepspec::prep_rot_std_dev, "No description" ).def(10.0);
 option.add( basic::options::OptionKeys::pepspec::seq_align, "No description" ).def(false);
 option.add( basic::options::OptionKeys::pepspec::prep_align_prot_to, "No description" );
+option.add( basic::options::OptionKeys::sicdock::sicdock, "sicdock option group" ).legal(true).def(true);
+option.add( basic::options::OptionKeys::sicdock::clash_dis, "max acceptable clash dis" ).def(3.5);
+option.add( basic::options::OptionKeys::sicdock::contact_dis, "max acceptable contact dis" ).def(12.0);
+option.add( basic::options::OptionKeys::sicdock::hash_2D_vs_3D, "grid spacing top 2D hash" ).def(1.3);
+option.add( basic::options::OptionKeys::sicdock::term_min_expose, "terminus at least X exposed" ).def(0.1);
+option.add( basic::options::OptionKeys::sicdock::term_max_angle, "terminus at most X degrees from XY plane" ).def(45.0);
 option.add( basic::options::OptionKeys::orbitals::orbitals, "orbitals option group" ).legal(true).def(true);
 option.add( basic::options::OptionKeys::orbitals::Hpol, "look at only polar hydrogen interactions" ).def(false);
 option.add( basic::options::OptionKeys::orbitals::Haro, "look at only aromatic hydrogen interactions" ).def(false);
diff -rupN vanilla/rosetta_source/src/basic/options/option.cc.include.gen.hh patched/rosetta_source/src/basic/options/option.cc.include.gen.hh
--- vanilla/rosetta_source/src/basic/options/option.cc.include.gen.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/option.cc.include.gen.hh	2012-06-10 16:12:40.761039915 +0200
@@ -68,6 +68,7 @@
 #include <basic/options/keys/bbg.OptionKeys.gen.hh>
 #include <basic/options/keys/flxbb.OptionKeys.gen.hh>
 #include <basic/options/keys/rescore.OptionKeys.gen.hh>
+#include <basic/options/keys/sicdock.OptionKeys.gen.hh>
 #include <basic/options/keys/gpu.OptionKeys.gen.hh>
 #include <basic/options/keys/jd2.OptionKeys.gen.hh>
 #include <basic/options/keys/murphp.OptionKeys.gen.hh>
@@ -94,6 +95,7 @@
 #include <basic/options/keys/remodel.OptionKeys.gen.hh>
 #include <basic/options/keys/fold_from_loops.OptionKeys.gen.hh>
 #include <basic/options/keys/docking.OptionKeys.gen.hh>
+#include <basic/options/keys/csa.OptionKeys.gen.hh>
 #include <basic/options/keys/hotspot.OptionKeys.gen.hh>
 #include <basic/options/keys/archive.OptionKeys.gen.hh>
 #include <basic/options/keys/chemical.OptionKeys.gen.hh>
@@ -102,6 +104,7 @@
 #include <basic/options/keys/patterson.OptionKeys.gen.hh>
 #include <basic/options/keys/optE.OptionKeys.gen.hh>
 #include <basic/options/keys/residues.OptionKeys.gen.hh>
+#include <basic/options/keys/dc.OptionKeys.gen.hh>
 #include <basic/options/keys/phil.OptionKeys.gen.hh>
 #include <basic/options/keys/holes.OptionKeys.gen.hh>
 #include <basic/options/keys/enzdes.OptionKeys.gen.hh>
diff -rupN vanilla/rosetta_source/src/basic/options/option.hh patched/rosetta_source/src/basic/options/option.hh
--- vanilla/rosetta_source/src/basic/options/option.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/option.hh	2012-06-10 16:12:40.763039721 +0200
@@ -11,6 +11,9 @@
 /// @brief  Program options global and initialization function
 /// @author Stuart G. Mentzer (Stuart_Mentzer@objexx.com)
 
+#ifndef INCLUDED_basic_options_option_hh
+#define INCLUDED_basic_options_option_hh
+
 // Utility headers
 #include <utility/options/OptionCollection.hh>
 
@@ -143,9 +146,6 @@
 #include <utility>
 #include <vector>
 
-#ifndef INCLUDED_basic_options_option_hh
-#define INCLUDED_basic_options_option_hh
-
 namespace basic {
 namespace options {
 
diff -rupN vanilla/rosetta_source/src/basic/options/option_macros.hh patched/rosetta_source/src/basic/options/option_macros.hh
--- vanilla/rosetta_source/src/basic/options/option_macros.hh	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/option_macros.hh	2012-06-10 16:12:40.765074673 +0200
@@ -15,6 +15,9 @@
 ///
 /// @author Oliver Lange
 
+#ifndef INCLUDED_basic_options_option_macros_hh
+#define INCLUDED_basic_options_option_macros_hh
+
 #include <basic/options/option.hh>
 #include <basic/options/keys/OptionKeys.hh>
 #include <basic/options/after_opts.hh>
@@ -206,3 +209,5 @@
   namespace basic { 	namespace options {	namespace OptionKeys { namespace grp1 { namespace grp2 { namespace grp3 { \
 	    basic::options::type##OptionKey const key( #grp1":"#grp2":"#grp3":"#key ); \
 	  }}}}}}
+
+#endif
diff -rupN vanilla/rosetta_source/src/basic/options/options_class.py patched/rosetta_source/src/basic/options/options_class.py
--- vanilla/rosetta_source/src/basic/options/options_class.py	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/options_class.py	2012-06-10 16:12:40.768039578 +0200
@@ -211,7 +211,7 @@ def printWikiTable(opt_list):
 
 
 def getDoxygenPage(opt_list):
-    s = "/*!\n@page options\nMini rosetta command line option descriptions. <i>(This is automatically generated file, do not edit!)</i>\n"
+    s = "/*!\n@page full_options_list\nMini rosetta command line option descriptions. <i>(This is automatically generated file, do not edit!)</i>\n"
     s += "<ul>\n"
     prevGroup = None
     for o in opt_list:
diff -rupN vanilla/rosetta_source/src/basic/options/options_rosetta.py patched/rosetta_source/src/basic/options/options_rosetta.py
--- vanilla/rosetta_source/src/basic/options/options_rosetta.py	2012-03-20 19:43:04.000000000 +0100
+++ patched/rosetta_source/src/basic/options/options_rosetta.py	2012-06-10 16:12:40.774041765 +0200
@@ -127,6 +127,7 @@ Options = Option_Group( '',
 			legal=['true','false'],
 			# default depends on the residue type.
 			),
+		Option( 'detect_disulf_tolerance', 'Real', desc='disulf tolerance', default="0.5" ),
 		Option( 'fix_disulf', 'File',
 			desc="Specify disulfide connectivity via a file. Disulfides are "
 				"specified as two whitespace-seperated residue indicies per line. "
@@ -171,8 +172,10 @@ Options = Option_Group( '',
 			Option( 'extra_res_database','String',desc="the name of a database containing fullatom residue types (e.g. ligands)"),
 			Option( 'extra_res_database_mode','String',desc="The type of database driver to use for -in:file:extra_res_database.  Acceptable values are 'mysql' or 'sqlite3'",default='sqlite3'),
 			Option( 'extra_res_database_resname_list','File',desc="Path to a list of residue names to be read in from the residue database.  The list should have one residue name per line"),
-            Option( 'extra_res_cen', 'FileVector', desc=".params file(s) for new centroid residue types (e.g. ligands)" ),
+			Option( 'extra_res_cen', 'FileVector', desc=".params file(s) for new centroid residue types (e.g. ligands)" ),
 			Option( 'extra_res_path', 'PathVector', desc="directories with .params files.  Only files containing 'param' will be chosen" ),
+			Option( 'extra_patch_fa', 'FileVector', desc="patch files for full atom variants not specified in the database" ),
+			Option( 'extra_patch_cen', 'FileVector', desc="patch files for centroid atom variants not specified in the database" ),
 			Option( 'frag3', 'String' ),
 			Option( 'frag9', 'String' ),
 			Option( 'fragA', 'String' ),
@@ -216,6 +219,7 @@ Options = Option_Group( '',
 				desc='Select a random subset of this number of decoys from every silent-file read',
 				default = '0'
 			),
+		  Option( 'skip_failed_simulations', 'Boolean', default = 'false', desc = 'Ignore failed simulations (prefixed by W_) during silent file input. Existing behavior is preserved by default.'),
 			Option(
 				'silent_scores_wanted', 'StringVector',
 				desc = 'Only put these silent-scores into the Pose.',
@@ -238,6 +242,8 @@ Options = Option_Group( '',
 			Option( 'template_pdb', 'FileVector', desc = 'Name of input template PDB files for comparative modeling' ),
 			Option( 'template_silent', 'File', desc = 'input templates for comparative modeling -- tag needs to fit alignment id' ),
 			Option( 'rdc', 'FileVector', desc='Experimental NMR Residual Dipolar Coupling File --- one file per alignment medium' ),
+			Option( 'csa', 'FileVector', desc='Experimental NMR Chemical Shift Anisotropy File' ),
+			Option( 'dc', 'FileVector', desc='Experimental NMR Dipolar Coupling File' ),
 			Option( 'burial', 'FileVector', desc='WESA-formatted burial prediction' ),
 			Option( 'vall', 'FileVector', desc='Fragment database file, e.g vall.dat.2006-05-05', default='/sampling/filtered.vall.dat.2006-05-05' ),
 			Option( 'rescore', 'Boolean', desc = 'Governs whether input poses are rescored or not in not_universal_main, defaults to false.', default = 'false' ),
@@ -270,7 +276,8 @@ Options = Option_Group( '',
 	    Option('port','Integer',desc="mySQL database port"),
 	),
 	Option_Group( 'qsar',
-		Option( 'weights','String',default='standard',desc = 'select qsar weight set to use')
+		Option( 'weights','String',default='standard',desc = 'select qsar weight set to use'),
+		Option( 'grid_dir','String',desc = 'Directory to store grids in'),
 	),
 	Option_Group( 'residues',
 		Option( 'patch_selectors', 'StringVector', desc = 'allow patch files that have CMDLINE_SELECTOR tags can be switched on with this option' ),
@@ -345,6 +352,7 @@ Options = Option_Group( '',
 		Option( 'mute_warning', 'StringVector', desc="Mute specified Tracer chanels for msgs with priority warning and less"),
 		Option( 'mute_info', 'StringVector', desc="Mute specified Tracer channels for msgs with priority info and less"),
 		Option( 'mute_debug', 'StringVector', desc="Mute specified Tracer channels for msgs with priority debug and less"),
+		Option( 'mute_trace', 'StringVector', desc="Mute specified Tracer channels for msgs with priority debug and less"),
 		Option( 'unmute_error', 'StringVector', desc="Unmute specified Tracer channels for msgs of priority ERROR and more"),
 		Option( 'unmute_warning', 'StringVector', desc="Unmute specified Tracer chanels for msgs with priority warning and more"),
 		Option( 'unmute_info', 'StringVector', desc="Unmute specified Tracer channels for msgs with priority info and more"),
@@ -1061,7 +1069,8 @@ Options = Option_Group( '',
 		Option( 'nproc',    'Integer',      desc='number of process... needed if proc_id is specified',     default='0' ),
 		Option( 'proc_id',  'Integer',      desc='give process number... Jobdistributor will only work on proc_id mod nproc part of work ',     default='0' ),
 		Option( 'exit_if_missing_heavy_atoms', 'Boolean', default='false', desc="quit if heavy atoms missing in pdb"),
-    Option( 'show_simulation_in_pymol', 'Real', default='5.0', desc="Attach PyMOL observer to pose at the beginning of the simulation. Refreshes pose every [argument] seconds, default 5.  Don't forget to run the PyMOLPyRosettaServer.py script within PyMOL!"),
+    		Option( 'show_simulation_in_pymol', 'Real', default='5.0', desc="Attach PyMOL observer to pose at the beginning of the simulation. Refreshes pose every [argument] seconds, default 5.  Don't forget to run the PyMOLPyRosettaServer.py script within PyMOL!"),
+		Option( 'keep_pymol_simulation_history', 'Boolean', desc='Keep history when using show_simulation_in_pymol flag?', default='false' ),
 
 	), # run
 
@@ -1682,6 +1691,7 @@ Options = Option_Group( '',
 	# chemical settings -----------------------------------------------------------
 	Option_Group( 'chemical',
 		Option( 'exclude_patches', 'StringVector', desc="Names of the residue-type-set patches which should not be applied; if you know which patches you do not need for a particular run, this flag can reduce your memory use" ),
+		Option( 'include_patches', 'StringVector', desc="Names of the residue-type-set patches which should be applied even if excluded/commented out in patches.txt; useful for testing non-default patches", ),
 	),
 	# score function settings  -----------------------------------------------------------
 	Option_Group( 'score',
@@ -1692,7 +1702,7 @@ Options = Option_Group( '',
 		Option( 'soft_wts', 'String', desc="Name of the 'soft' weights file, for protocols which use it." , default="soft_rep" ),
 		Option( 'docking_interface_score','Boolean',desc="the score is computed as difference between bound and unbound pose", default='false'),
 		Option( 'custom_atom_pair', 'String', desc='filename for custom atom pair constraints', default = 'empty' ),
-		Option( 'patch',   'String', desc="Name of patch file (without extension)" , default="" ),
+		Option( 'patch',   'FileVector', desc="Name of patch file (without extension)",default="" ),
 		Option( 'empty',   'Boolean', desc="Make an empty score - i.e. NO scoring"  ),
 		Option( 'fa_max_dis', 'Real', desc='How far does the FA pair potential go out to ?', default='6.0', ),
 		Option( 'fa_Hatr', 'Boolean', desc='Turn on Lennard Jones attractive term for hydrogen atoms'),
@@ -1730,7 +1740,9 @@ Options = Option_Group( '',
 		Option( 'output_residue_energies', "Boolean", desc="Output the energy for each residue", default='false' ),
 		Option( 'fa_custom_pair_distance_file', 'String', desc="Name of custom pair distance energy file", default=""),
 		Option( 'disulf_matching_probe', 'Real', desc="Size of probe to use in disulfide matching score", default='2.5'),
-		Option( 'bonded_params', 'RealVector', desc="Spring constants for bonded parameters [length,angle,torsion,proton-torsion] (default 600,300,300,60)"),	
+		Option( 'bonded_params', 'RealVector', desc="Spring constants for bonded parameters [length,angle,torsion,proton-torsion] (default 600,300,300,60)"),
+		Option( 'bonded_params_CHARMM_angle', 'Boolean', desc="use CHARMM spring constants"),
+		Option( 'bonded_params_CHARMM_length', 'Boolean', desc="use CHARMM spring constants"),
 		Option( 'pro_close_planar_constraint', 'Real', desc="stdev of CD,N,CA,prevC trigonal planar constraint in pro_close energy method", default='0.1' ),
 		Option( 'linear_bonded_potential', 'Boolean', desc="use linear (instead of quadratic) bonded potential", default='false'),
 		Option_Group( 'saxs',
@@ -1757,6 +1769,11 @@ Options = Option_Group( '',
 		Option( 'hackelec_max_dis', 'Real', desc='changes the maximum distance cut-off for hack-elec energy', default='5.5'),
 		Option( 'hackelec_die', 'Real', desc='changes the dielectric constant for hack-elec energy', default='10.0'),
 		Option( 'hackelec_r_option', 'Boolean', desc='changes the dielectric from distance dependent to distance independent', default='false'),
+    Option( 'nmer_ref_energies', 'String', desc='nmer ref energies database filename' ),
+    Option( 'nmer_pssm', 'String', desc='nmer pssm database filename' ),
+    Option( 'nmer_pssm_list', 'String', desc='nmer pssm database filename' ),
+    Option( 'nmer_pssm_scorecut', 'Real', desc='nmer pssm scorecut gate for ignoring lowscore nmers', default='0.0' ),
+    Option( 'nmer_ref_seq_length', 'Integer', desc='length of nmers in nmer_ref score', default='9' ),
 	),
 
 	# correction for testing ------------------------------------------------------------
@@ -1777,6 +1794,7 @@ Options = Option_Group( '',
 			default="false"),
 		Option_Group( 'score',
 			Option( 'no_his_his_pairE', 'Boolean', desc="Set pair term for His-His to zero", ),
+			Option( 'no_his_DE_pairE', 'Boolean', desc="Set pair term for His-Glu and His-Asp to zero", ),
 			Option( 'hbond_His_Phil_fix', 'Boolean', desc="Phil's fix on Histidine interaction angular dependence"),
 			Option( 'helix_hb_06_2009',   'Boolean', desc="Helix backbone-backbone hbond potential with a different angular dependence"),
 			Option( 'use_incorrect_hbond_deriv',   'Boolean', desc="Use deprecated hbond derivative calculation.", default="false"),
@@ -1803,6 +1821,8 @@ Options = Option_Group( '',
 			Option( 'hb_sp2_amp', 'Real', desc="Experimental term for hydrogen bonds to sp2 acceptors: sets the amplitude of the sp2 hydrogen bond (greater than 1 upweights sp2 hydrogen bonds)", default="2.0" ),
 			Option( 'hb_sp2_peak_heigh_above_trough', 'Real', desc="Experimental term for hydrogen bonds to sp2 acceptors: sets the dynamic range between the most potent sp2 hydrogen bonds and the least potent", default="3.0" ),
 			Option( 'hbond_measure_sp3acc_BAH_from_hvy', 'Boolean', desc="If true, then the BAH angle for sp3 (aka hydroxyl) acceptors is measured donor-hydrogen--acceptor-heavyatom--heavyatom-base instead of donor-hydrogen--accptor-heavyatom--hydroxyl-hydrogen", default="false" ),
+			Option( 'use_bicubic_interpolation', 'Boolean', desc="Instead of using bilinear interpolation to evaluate the Ramachandran, P_AA_pp and Dunbrack potentials, use bicubic interpolation.  Avoids pile-ups at the grid boundaries where discontinuities in the derivatives frustrate the minimizer", default="false" ),
+			Option( 'dun_normsd', 'Boolean', desc="Use height-normalized guassian distributions to model p(chi|phi,psi) instead of height-unnormalized gaussians", default="false" ),
 		),
 		Option_Group( 'chemical',
 			Option( 'icoor_05_2009', 'Boolean', desc="New set of idealized coordinates for full atom, 05-2009" ),
@@ -1978,6 +1998,8 @@ Options = Option_Group( '',
 		Option( 'max_cluster_seeds', 'Integer', desc="Do not calculate initial cluster centers for more then this many structuers", default = '500' ),
 		Option( 'radius', 'Real', desc="Cluster radius", default = '3.0' ),
 		Option( 'limit_cluster_size', 'Integer', desc="For each cluster only retain top N ", default = '-1' ),
+		Option( 'limit_cluster_size_percent', 'Real', desc="0 to 1. For each cluster only retain top N % " ),
+		Option( 'random_limit_cluster_size_percent', 'Real', desc="0 to 1. For each cluster only retain random N % " ),
 		Option( 'limit_clusters', 'Integer', desc="Only retain largest N clusters", default = '100' ),
 		Option( 'limit_total_structures', 'Integer', desc="Only retain the first N structures (ordered by cluster number)", default = '-1' ),
 		Option( 'max_total_cluster','Integer', desc="Only ever make N clusters or less", default = '1000'),
@@ -2028,6 +2050,7 @@ Options = Option_Group( '',
 			default='known_structs.in'
 		), ##using this option will cause that tag of nearest structure to sampled decoys is reported
 		Option( 'max_rmsd_against_known_structures', 'Real', desc='stop sampling if rmsd to a known-structure is lower than X',default='1.5' ),
+		Option( 'excluded_residues_from_rmsd', 'IntegerVector', desc='residues that are not used for RMSD computation in pool' ),
 		Option( 'heat_convergence_check', 'Integer',
 			desc ="jump out of current abinitio run if X unsuccesful mc-trials reached", default='0'),
 	), # mc
@@ -2059,7 +2082,7 @@ Options = Option_Group( '',
 		Option( 'superimpose_to_file',     'File', desc='Superimpose input structure to file', default='false' ),
 		Option( 'constrain_relax_to_native_coords', 'Boolean', desc = "For relax and fastrelax, tether backbone coordinates of the pdbs being relaxed to the coordinates in the xtal native", default="false" ),
 		Option( 'constrain_relax_to_start_coords', 'Boolean', desc = "For relax and fastrelax, tether backbone coordinates of the pdbs being relaxed to the coordinates in the xtal native", default="false" ),
-                Option( 'coord_constrain_sidechains', 'Boolean', desc = "For relax and fastrelax, also tether sidechain heavy atom coordinates (requires either -constrain_relax_to_native_coords or -constrain_relax_to_start_coords)", default="false" ),
+		Option( 'coord_constrain_sidechains', 'Boolean', desc = "For relax and fastrelax, also tether sidechain heavy atom coordinates (requires either -constrain_relax_to_native_coords or -constrain_relax_to_start_coords)", default="false" ),
 		Option( 'sc_cst_maxdist', 'Real', default='0.0', desc='Use distance constraints between pairs of input side-chains atoms which are closer than the given upper distance cutoff (0 => no sc-sc restraints)' ),
 		Option( 'limit_aroma_chi2', 'Boolean', desc = "limit chi2 rotamer of PHE,TYR, and HIS around 90 ", default="false" ),
 
@@ -2710,13 +2733,14 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 		Option( 'num_partitions', 'Integer', default = '1', desc='Number of partitions to split the database into'),
 		Option( 'db_path', 'Path', default = '', desc = 'Path to database' ),
 		Option( 'exclude_homo', 'Boolean', default = 'false', desc = 'Use a homolog exclusion filter' ),
+		Option( 'bss', 'Boolean', default = 'false', desc = 'Use BinaryProteinSilentStruct instead of ProteinSilentStruct (needed for nonideal)' ),
 		Option( 'refstruct', 'String', default = '', desc = 'File with a target reference structure' ),
 		Option( 'homo_file', 'String', default = '', desc = 'File containing homologs to exclude' ),
 		Option( 'createdb_rms_cutoff', 'RealVector', default = ['0','0','0'], desc = 'RMS cutoff used for throwing out similar fragments.' ),
-		Option( 'min_bbrms', 'Real', default='0.0' ),
-		Option( 'max_bbrms', 'Real', default='100000.0' ),
-		Option( 'min_rms'  , 'Real', default='0.0' ),
-		Option( 'max_rms'  , 'Real', default='100.0' ),
+		Option( 'min_bbrms', 'Real', default='20.0' ),
+		Option( 'max_bbrms', 'Real', default='1400.0' ),
+		Option( 'min_rms'  , 'Real', default='0.5' ),
+		Option( 'max_rms'  , 'Real', default='4.0' ),
 		Option( 'filter_by_phipsi',  'Boolean', default = 'true' ),
 		Option( 'max_radius'  , 'Integer', default='4' ),
 		Option( 'max_struct'  , 'Integer', default='10' ),
@@ -2746,6 +2770,7 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 		Option( 'rms_limit', 'Real', default='2.0', desc = 'How to deal with returned relaxed structures' ),
 		Option( 'centroid_only',     'Boolean', default = 'false', desc = 'false' ),
 		Option( 'write_centroid_structs',   'Boolean', default = 'false', desc = 'Output raw loophashed decoys as well as relaxed ones' ),
+		Option( 'write_all_fa_structs',   'Boolean', default = 'false', desc = 'Write out all structures returned from batch relax' ),
 		Option( 'sandbox',   'Boolean', default = 'false', desc = 'Sand box mode' ),
 		Option( 'create_db', 'Boolean', default = 'false', desc = 'Make database with this loopsize' ),
 		Option( 'sample_weight_file', 'File', desc = 'Holds the initial per residue sample weights' ),
@@ -2803,6 +2828,10 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 	  Option_Group('kcluster',
       Option('num_clusters', 'Integer', desc = 'Number of clusters to use during k clustering')
     ),
+		Option_Group('jumping',
+      Option('resi', 'Integer', desc = 'Residue i'),
+			Option('resj', 'Integer', desc = 'Residue j'),
+    ),
   ),
 
 	##options for liz
@@ -3277,6 +3306,7 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 			Option( 'templates',                      'FileVector', desc='Input list of template files'),
 			Option( 'template_list',                  'File', desc='Input list of templates, constaints, cluster, and weights'),
 			Option( 'starting_template',              'IntegerVector',    desc='Define starting templates' ),
+			Option( 'realign_domains',                'Boolean',     desc='domain parse and realign the starting templates', default='true' ),
 			Option( 'add_non_init_chunks',            'Boolean',     desc='non chunks from templates other than the initial one', default='false' ),
 			Option( 'ss',                             'String',     desc='secondary structure elements used to split the pose', default='HE' ),
 			Option( 'stage1_increase_cycles',         'Real',     desc='Scale stage 1 cycles', default='1.0' ),
@@ -3468,7 +3498,7 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
       ),
     Option( 'max_kic_build_attempts', 'Integer',
       desc='Number of attempts at initial kinematic closure loop building',
-      default='100'
+      default='10000'
       ),
     Option( 'remodel_kic_attempts', 'Integer',
       desc='Number of kic attempts per inner cycle during perturb_kic protocol',
@@ -3811,7 +3841,7 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 
 	Option_Group( 'optE',
 		Option( 'optE', 'Boolean', desc="optE option group", legal='true', default='true' ),
-		Option( 'load_from_silent', 'String', default='pdb_set.silent', desc='load from silent instead of pdb - uses path of requested pdb to find silent file, each PDB needs to have all of its structures in its own folder (ie: 1agy/pdb_set.silent) - only works in optimize_decoy_discrimination' ), 
+		Option( 'load_from_silent', 'String', default='pdb_set.silent', desc='load from silent instead of pdb - uses path of requested pdb to find silent file, each PDB needs to have all of its structures in its own folder (ie: 1agy/pdb_set.silent) - only works in optimize_decoy_discrimination' ),
 		Option( 'data_in', 'String', default='optE.data', desc='file from which to read in optE data' ),
 		Option( 'data_out', 'String', default='optE.data.out', desc='file to which to write optE data' ),
 		Option( 'weights', 'String', desc='a conventional weightfile that optE will use to determine which weights will be counted.  All non-zero weights in the file will contribute to rotamer energies and be fit; use the -optE::fix option to fix any of these weights.  Weight values will also be used as starting values for optimization.' ),
@@ -3868,6 +3898,7 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 		Option( 'starting_refEs', 'File', desc='IterativeOptEDriver flag: specify a weights file to read reference energies from; do not optimize reference energies in the first round of weight fitting'),
 		Option( 'repeat_swarm_optimization_until_fitness_improves', 'Boolean', desc='After the first time though the particle swarm optimization phase, if the end fitness is not better than the start fitness, recreate the swarm around the start dofs and repeat the swarm optimization.', default='false'),
 		Option( 'design_with_minpack', 'Boolean', desc='Use the min-packer to design in the sequence recovery stages.', default='false'),
+		Option( 'limit_bad_scores',  'Boolean', desc='Quit after 100,000 inf or NaN errors in optE objective function'),
 		Option_Group( 'rescore',
 			Option( 'weights', 'File', desc='Weight set to use when rescoring optE partition functions' ),
 			Option( 'context_round', 'Integer', desc='Integer of the context PDBs generated during design to use to measure the pNatAA'),
@@ -3987,7 +4018,10 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 		Option(  'dr_cycles', 'Integer', desc='number of design-refine cycles to use', default = '3'),
 		Option(  'two_chain_tree', 'Integer', desc='label the start of the second chain'),
                 Option(  'repeat_structure', 'Integer', desc='build identical repeats this many times', default='1'),
+                Option(  'lh_ex_limit', 'Integer', desc='loophasing neighboring bin expansion limit', default='5'),
                 Option(  'cen_minimize', 'Boolean' , desc= 'centroid minimization after fragment building', default = 'false'),
+		Option(  'core_cutoff', 'Integer', desc='number of neighbors required to consider core in auto design', default = '15'),
+		Option(  'boundary_cutoff', 'Integer', desc='number of neighbors required to consider boundary in auto design', default = '10'),
 		Option_Group( 'domainFusion',
                 Option(  'insert_segment_from_pdb', 'File', desc='segment pdb file to be inserted [insert pdb file name].', default=''),
                         #Option(  'rigid_segment_in_refinement', 'Boolean', desc=' rigid segment in refinement.'),
@@ -4019,6 +4053,7 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
     Option_Group( 'RemodelLoopMover',
       Option( 'max_linear_chainbreak', 'Integer', desc="linear chainbreak is <= this value, loop is considered closed (default 0.07) " ),
       Option( 'randomize_loops', 'Boolean', desc="randomize loops prior to running main protocol (default false)" ),
+      Option( 'use_loop_hash', 'Boolean', desc="centroid build with loop hash (default false)" ),
 			Option( 'allowed_closure_attempts', 'Integer', desc="the allowed number of overall closure attempts (default 1)" ),
 			Option( 'simultaneous_cycles', 'Integer', desc="the number of simultaneous closure cycles to perform (default 2)" ),
       Option( 'independent_cycles', 'Integer', desc="the number of independent closure cycles to perform (default 8)" ),
@@ -4181,8 +4216,8 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 ############################################################################
 # CS-Rosetta options
    Option_Group('rdc',
-	Option( 'correct_NH_length', 'Boolean', desc='fix N-H bond-vector to 1.04 as measured in ottiger&bax 98'),
-        Option( 'reduced_couplings', 'Boolean', desc='gives more equal weights to different bond-vectors'),
+	Option( 'correct_NH_length', 'Boolean', desc='fix N-H bond-vector to 1.04 as measured in ottiger&bax 98', default='false'),
+	Option( 'reduced_couplings', 'Boolean', desc='gives more equal weights to different bond-vectors', default='false'),
 	Option( 'weights', 'File', desc='specify weights for individual residues ( works for all couplings at this reside)' ),
 	Option( 'iterate_weights', 'Real', desc='do a wRDC computation, i.e., iterate tensor calculation until weights are ~exp ( -dev2/sigma )', default='1' ),
 	Option( 'segment_file','File',desc='Definition of rigid segments for alignment tensor optimization'),
@@ -4205,6 +4240,15 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
         Option( 'fixR', 'RealVector'),
     ),
 
+############################################################################
+# Solid state NMR orientational constraints
+   Option_Group('csa',
+        Option( 'useZ', 'Boolean', desc='Use absolute zaxis for scoring csa'),
+   ),
+   Option_Group('dc',
+        Option( 'useZ', 'Boolean', desc='Use absolute zaxis for scoring dc'),
+   ),
+
 	##############################################################################
 	# Rosetta Antibody Options -----------------------------------------------
 	Option_Group('antibody',
@@ -4268,6 +4312,46 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 			desc='Adjust relative orientation of VL-VH',
 			default='false'
 			),
+		Option( 'refine_h3', 'Boolean',
+			desc='Refine CDR H3 in high resolution',
+			default='true'
+			),
+		Option( 'h3_filter', 'Boolean',
+			desc='filter decoys having neither kink nor extend form',
+			default='true'
+			),
+		Option( 'h3_filter_tolerance', 'Real',
+			desc='maximum number of tries for the filter',
+			default='5'
+			),
+		Option( 'cter_insert', 'Boolean',
+			desc='insert kind or extend Ab fragments to CDR H3',
+			default='true'
+			),
+		Option( 'flank_residue_min', 'Boolean',
+			desc='minimize flank residues of CDR H3 during high-reso refinement',
+			default='true'
+			),
+		Option( 'sc_min', 'Boolean',
+			desc='minimize the side chain after finishing the rotamer packing',
+			default='false'
+			),
+		Option( 'rt_min', 'Boolean',
+			desc='minimize the rotamer each packing',
+			default='false'
+			),
+		Option( 'bad_nter', 'Boolean',
+			desc='the n-terminal is bad because of bad H3 grafting',
+			default='true'
+			),
+		Option('remodel', 'String',
+			desc='Choose a perturb method to model H3 in centroid mode',
+			default='legacy_perturb_ccd'
+			),
+		Option('refine', 'String',
+			desc='Choose a refine method to model H3 in high-resol model',
+			default='legacy_perturb_ccd'
+			),
 		Option( 'snug_loops', 'Boolean',
 			desc='Allow CDR loop backbone flexibility during minimization',
 			default='false'
@@ -4637,6 +4721,15 @@ EX_SIX_QUARTER_STEP_STDDEVS   7         
 
 	),
 
+	###############################################################################
+	## peptide specificity / flexible backbone design options (chrisk)
+	Option_Group( 'sicdock',
+		Option( 'clash_dis'    ,    'Real', default='3.5' , desc="max acceptable clash dis"),
+		Option( 'contact_dis'  ,    'Real', default='12.0', desc="max acceptable contact dis"),
+		Option( 'hash_2D_vs_3D',    'Real', default='1.3' , desc="grid spacing top 2D hash"),
+		Option( 'term_min_expose',  'Real', default='0.1' , desc="terminus at least X exposed"),
+		Option( 'term_max_angle',   'Real', default='45.0' , desc="terminus at most X degrees from XY plane"),
+	),
 
 ################STEVEN COMBS#######################
 	Option_Group( 'orbitals',
diff -rupN vanilla/rosetta_source/src/basic/prof.cc patched/rosetta_source/src/basic/prof.cc
--- vanilla/rosetta_source/src/basic/prof.cc	2012-03-20 19:43:05.000000000 +0100
+++ patched/rosetta_source/src/basic/prof.cc	2012-06-10 16:12:40.181041059 +0200
@@ -16,10 +16,12 @@
 #include <basic/Tracer.hh>
 #include <ObjexxFCL/string.functions.hh>
 #include <string>
+#include <time.h>
 
 //Auto Headers
 #include <utility/vector1.hh>
 #include <ObjexxFCL/format.hh>
+#include <boost/algorithm/string.hpp>
 
 //Auto using namespaces
 namespace ObjexxFCL { namespace fmt { } } using namespace ObjexxFCL::fmt; // AUTO USING NS
@@ -38,6 +40,19 @@ clock_t const SHRINK_FACTOR( 2 );
 
 double const clock_factor( ( (double) SHRINK_FACTOR * 100.0 ) / CLOCKS_PER_SEC );
 
+bool show_time_on_cerr( false );
+void show_time( basic::Tracer& tr, std::string const& msg ) {
+	using namespace std;
+	time_t rawtime;
+  struct tm * timeinfo;
+  time ( &rawtime );
+  timeinfo = localtime ( &rawtime );
+	std::string date( asctime( timeinfo ) );
+	boost::trim(date);
+	tr.Error << "TIME_STAMP: " << date << " " << msg << std::endl;
+	if ( show_time_on_cerr ) std::cerr << tr.channel() << ": TIME_STAMP: " << date << " " << msg << std::endl;
+}
+
 void setup_tag2string() {
 	tag2string.clear();
 	for ( int i=1; i<= n_prof_tags; ++i ) {
@@ -46,9 +61,9 @@ void setup_tag2string() {
 
 	// now fill in
 	tag2string[ TEST1 ] = "TEST1";
-	tag2string[ TEST2 ] = "FIND_NEIGHBORS";
-	tag2string[ TEST3 ] = "COMPUTE_GUNN";
-	tag2string[ TEST4 ] = "SMOOTH_MOVE";
+	tag2string[ TEST2 ] = "TEST2";
+	tag2string[ TEST3 ] = "TEST3";
+	tag2string[ TEST4 ] = "TEST4";
 	tag2string[ ATOM_TREE_UPDATE_INTERNAL_COORDS ] = "ATOM_TREE_UPDATE_INTERNAL_COORDS";
 	tag2string[ ATOM_TREE_UPDATE_XYZ_COORDS ] = "ATOM_TREE_UPDATE_XYZ_COORDS";
 	tag2string[ ROTAMER_TRIALS ] = "ROTAMER_TRIALS";
@@ -267,6 +282,38 @@ void setup_tag2string() {
 	tag2string[ SILENT_FILL_STRUCT ] = "SILENT_FILL_STRUCT";
 }
 
+
+std::map<std::string, double> dynamic_prof_total;
+std::map<std::string, int> dynamic_prof_calls;
+
+DynamicProfileThis::DynamicProfileThis( std::string const& tag ) {
+	using namespace basic::options;
+  using namespace basic::options::OptionKeys;
+
+	// don't profile unless instructed to via the option -run:profile
+	if (!option[basic::options::OptionKeys::run::profile])
+		return;
+
+	tag_ = tag;
+	start_clock_ = clock() / SHRINK_FACTOR;
+}
+
+DynamicProfileThis::~DynamicProfileThis() {
+	using namespace basic::options;
+	using namespace basic::options::OptionKeys;
+// don't profile unless instructed to via the option -run:profile
+	if (!option[basic::options::OptionKeys::run::profile])
+		return;
+
+	clock_t const current( clock() / SHRINK_FACTOR );
+	clock_t const start( start_clock_ );
+
+	if ( current >= start ) {
+		dynamic_prof_total[ tag_ ] += clock_factor * ( current - start );
+		dynamic_prof_calls[ tag_ ] += 1;
+	}
+}
+
 void prof_show() {
 	using namespace ObjexxFCL;
 	basic::Tracer tt( "core.util.prof", basic::t_info, true /*muted by default*/ );
@@ -303,6 +350,15 @@ void prof_show() {
 		if ( ncalls ) tt << F(12,2,t) << ' ' << I(9,ncalls) << ' ' << I(9,bcalls)
 										 << ' ' << F(12,3, clocks_per_call ) << ' ' << tag2string[tag] << '\n';
 	}
+	for ( std::map< std::string, double >::const_iterator it=dynamic_prof_total.begin(); it!=dynamic_prof_total.end(); ++it ) {
+		std::string const& tag( it->first );
+		double const t( it->second );
+		int const ncalls( dynamic_prof_calls[tag] );
+		double const clocks_per_call( ncalls != 0 ? t/ncalls : 0.0 );
+		if ( ncalls ) tt << F(12,2,t) << ' ' << I(9,ncalls) << ' ' << I(9,0)
+										 << ' ' << F(12,3, clocks_per_call ) << ' ' << tag << '\n';
+
+	}
 	tt << "========================================\n";
 	tt << "========================================\n";
 	tt << "========================================" << std::endl;
@@ -330,4 +386,5 @@ void prof_reset() {
 	PROF_START( TOTAL );
 }
 
+
 } // basic
diff -rupN vanilla/rosetta_source/src/basic/prof.hh patched/rosetta_source/src/basic/prof.hh
--- vanilla/rosetta_source/src/basic/prof.hh	2012-03-20 19:43:05.000000000 +0100
+++ patched/rosetta_source/src/basic/prof.hh	2012-06-10 16:12:40.184041147 +0200
@@ -15,6 +15,7 @@
 #define INCLUDED_basic_prof_hh
 
 #include <utility/vector1.hh>
+#include <basic/Tracer.hh>
 #include <string>
 
 #include <platform/types.hh>
@@ -416,6 +417,8 @@ enum ProfTag {
 	n_prof_tags = TOTAL
 };
 
+
+
 extern utility::vector1< std::string > tag2string;
 extern utility::vector1< clock_t > start_clock;
 extern utility::vector1< double > total_clock;
@@ -479,6 +482,19 @@ private:
 	ProfTag tag_;
 };
 
+class DynamicProfileThis {
+public:
+	DynamicProfileThis( std::string const& prof_tag );
+	~DynamicProfileThis();
+private:
+	clock_t start_clock_;
+	std::string tag_;
+};
+
+///@brief print "TIME_STAMP: Www Mmm dd hh:mm:ss yyyy msg" on tr.Error and on std::cerr (if boolean is true)
+extern bool show_time_on_cerr;
+void show_time( basic::Tracer& tr, std::string const& msg );
+
 } // basic
 
 #endif
diff -rupN vanilla/rosetta_source/src/basic/Tracer.cc patched/rosetta_source/src/basic/Tracer.cc
--- vanilla/rosetta_source/src/basic/Tracer.cc	2012-03-20 19:43:05.000000000 +0100
+++ patched/rosetta_source/src/basic/Tracer.cc	2012-06-10 16:12:40.172039874 +0200
@@ -78,8 +78,8 @@ int Tracer::mpi_rank_( 0 );
 bool Tracer::TracerProxy::visible() const
 {
 	if( !visibility_calculated_ ) {
-		bool visible, muted;
-		calculate_visibility(channel_, priority_, visible, muted, tracer_.muted_by_default_);
+		int mute_level;
+		calculate_visibility(channel_, priority_, visible_, mute_level, tracer_.muted_by_default_);
 	}
 	return visible_;
 }
@@ -190,6 +190,7 @@ void Tracer::flush_all_channels()
 
 bool Tracer::visible( int priority ) const {
 	if (!visibility_calculated_) calculate_visibility();
+	muted_ = priority >= mute_level_;
 	if ( muted_ ) return false;
 	if ( priority > tracer_options_.level ) return false;
 	return true;
@@ -210,6 +211,7 @@ void Tracer::priority(int priority)
 {
 	priority_ = priority;
 	if (visibility_calculated_) {
+		muted_ = priority >= mute_level_;
 		visible_ = !muted_ && ( priority <= tracer_options_.level );
 	}
 }
@@ -218,14 +220,14 @@ void Tracer::priority(int priority)
 /// @details Calculate visibility of current Tracer object.
 void Tracer::calculate_visibility() const
 {
-	calculate_visibility(channel_, priority_, visible_, muted_, muted_by_default_);
+	calculate_visibility(channel_, priority_, visible_, mute_level_, muted_by_default_);
 	visibility_calculated_ = true;
 }
 
 
 /// @details Calculate visibility (static version) of current Tracer object using channel name and priority.
 /// result stored in 'muted' and 'visible'.
-void Tracer::calculate_visibility(std::string const &channel, int priority, bool &visible, bool &muted, bool muted_by_default)
+void Tracer::calculate_visibility(std::string const &channel, int priority, bool &visible, int &mute_level, bool muted_by_default)
 {
 	visible = false;
 	if( in(tracer_options_.muted, "all", true) ) {
@@ -249,7 +251,77 @@ void Tracer::calculate_visibility(std::s
 		}
 	}
 
-	//if we are in MPI mode --- most of the time one doesn't want to see output from all nodes just the master and 1st client is plenty ..
+
+	//	muted = !visible;
+	//comes at end now...	if( priority > tracer_options_.level ) visible = false;
+  if ( !visible ) mute_level = t_fatal;
+	else {
+		mute_level = 1000;
+		if ( in(tracer_options_.muted_trace, "all", true) ) {
+			mute_level = t_trace;
+		}
+		if ( in(tracer_options_.muted_trace, channel, false ) ) {
+			mute_level = t_trace;
+		}
+		if ( in(tracer_options_.muted_debug, "all", true) ) {
+			mute_level = t_debug;
+		}
+		if ( in(tracer_options_.muted_debug, channel, false ) ) {
+			mute_level = t_debug;
+		}
+
+		if ( in(tracer_options_.muted_info, "all", true) ) {
+			mute_level = t_info;
+		}
+		if ( in(tracer_options_.muted_info, channel, false ) ) {
+			mute_level = t_info;
+		}
+
+		if ( in(tracer_options_.muted_warning, "all", true) ) {
+			mute_level = t_warning;
+		}
+		if ( in(tracer_options_.muted_warning, channel, false ) ) {
+			mute_level = t_warning;
+		}
+	}
+	if ( mute_level < t_warning ) {
+		if ( in(tracer_options_.unmuted_error, "all", true) ) {
+			mute_level = t_warning;
+		}
+		if ( in(tracer_options_.unmuted_error, channel, false ) ) {
+			mute_level = t_warning;
+		}
+	}
+
+	if ( mute_level < t_info ) {
+		if ( in(tracer_options_.unmuted_warning, "all", true) ) {
+			mute_level = t_info;
+		}
+		if ( in(tracer_options_.unmuted_warning, channel, false ) ) {
+			mute_level = t_info;
+		}
+	}
+
+	if ( mute_level < t_debug ) {
+		if ( in(tracer_options_.unmuted_info, "all", true) ) {
+			mute_level = t_debug;
+		}
+		if ( in(tracer_options_.unmuted_info, channel, false ) ) {
+			mute_level = t_debug;
+		}
+
+	}
+
+	if ( mute_level < t_trace ) {
+		if ( in(tracer_options_.unmuted_debug, "all", true) ) {
+			mute_level = t_trace;
+		}
+		if ( in(tracer_options_.unmuted_debug, channel, false ) ) {
+			mute_level = t_trace;
+		}
+	}
+
+//if we are in MPI mode --- most of the time one doesn't want to see output from all nodes just the master and 1st client is plenty ..
 #ifdef USEMPI
 	int already_initialized = 0;
 	int already_finalized = 0;
@@ -263,16 +335,20 @@ void Tracer::calculate_visibility(std::s
 	}
 
 	if ( in(tracer_options_.muted, "all_high_mpi_rank", true ) ) {
-		if ( mpi_rank_>=2 ) visible = false; //* visible: master and 1st client: rank 0 and rank1
+		if ( mpi_rank_>=2 ) {
+			mute_level = std::min( (int)t_warning, mute_level );
+		}
 	}
 
 	if ( in(tracer_options_.muted, "all_high_mpi_rank_filebuf", true ) ) {
-		if ( mpi_rank_>=4 ) visible = false; //* visible: master, filebuf and 1st client: rank 0, 1, 2
+		if ( mpi_rank_>=4 ) {
+			visible = false; //* visible: master, filebuf and 1st client: rank 0, 1, 2
+			mute_level = std::min( (int)t_warning, mute_level );
+		}
 	}
-
 #endif
-	muted = !visible;
-	if( priority > tracer_options_.level ) visible = false;
+
+	visible = (priority < mute_level) && ( priority <= tracer_options_.level );
 }
 
 
@@ -329,13 +405,13 @@ void Tracer::t_flush(std::string const &
 
 	if( ios_hook_ && ios_hook_.get()!=this &&
 			( in(monitoring_list_, channel_, false) || in(monitoring_list_, AllChannels, true ) ) ) {
-		if (ios_hook_raw_ || visible_){
+		if ( ios_hook_raw_ || visible() ){
 			prepend_channel_name<otstream>( *ios_hook_, str );
 			ios_hook_->flush();
 		}
 	}
 
-	if ( !super_mute_ && visible_ ){
+	if ( !super_mute_ && visible() ){
 		prepend_channel_name<std::ostream>( *final_channel, str );
 	}
 }
diff -rupN vanilla/rosetta_source/src/basic/Tracer.hh patched/rosetta_source/src/basic/Tracer.hh
--- vanilla/rosetta_source/src/basic/Tracer.hh	2012-03-20 19:43:05.000000000 +0100
+++ patched/rosetta_source/src/basic/Tracer.hh	2012-06-10 16:12:40.175040204 +0200
@@ -126,6 +126,26 @@ struct TracerOptions
 
 	/// @brief list of unmuted channels
 	utility::vector1<std::string> unmuted;
+
+	/// @brief channel is muted for all but error-level
+  utility::vector1<std::string> muted_warning;
+
+	/// @brief channel is muted for all but warning and error level
+	utility::vector1<std::string> muted_info;
+
+	/// @brief and so on...
+	utility::vector1<std::string> muted_debug;
+	utility::vector1<std::string> muted_trace;
+
+	/// @brief channel is unmuted for error level
+	utility::vector1<std::string> unmuted_error;
+
+	/// @brief channel is unmuted for error and warning level
+	utility::vector1<std::string> unmuted_warning;
+
+	/// @brief and so on...
+	utility::vector1<std::string> unmuted_info;
+	utility::vector1<std::string> unmuted_debug;
 };
 
 
@@ -180,7 +200,7 @@ public:
 	static void super_mute(bool f) { super_mute_ = f; }
 
 	static void flush_all_tracers();
-
+	std::string const& channel() { return channel_; }
 public: /// Inner Classes
 	 /// @brief Small inner class acting as a proxy to an object that hold it.
 	class TracerProxy : public otstream // std::ostringstream //
@@ -233,7 +253,7 @@ private: /// Functions
 
 	/// @brief calcualte visibility of the current object depending of the channel name and priority.
 	void calculate_visibility(void) const;
-	static void calculate_visibility(std::string const &channel, int priority, bool &visible, bool &muted, bool muted_by_default);
+	static void calculate_visibility(std::string const &channel, int priority, bool &visible, int &mute_level, bool muted_by_default);
 
 
 private: /// Data members
diff -rupN vanilla/rosetta_source/src/basic/TracerToFile.hh patched/rosetta_source/src/basic/TracerToFile.hh
--- vanilla/rosetta_source/src/basic/TracerToFile.hh	2012-03-20 19:43:05.000000000 +0100
+++ patched/rosetta_source/src/basic/TracerToFile.hh	2012-06-10 16:12:40.178041063 +0200
@@ -8,8 +8,8 @@
 /// @brief Class for a tracer that writes all output to a file.
 /// @author Matt O'Meara (mattjomeara@gmail.com)
 
-#ifndef INCLUDE_basic_tracer_to_file_hh
-#define INCLUDE_basic_tracer_to_file_hh
+#ifndef INCLUDED_basic_TracerToFile_hh
+#define INCLUDED_basic_TracerToFile_hh
 
 
 
@@ -56,4 +56,4 @@ private:
 } // namespace basic
 
 
-#endif // INCLUDE_basic_tracer_to_file_hh
+#endif // INCLUDED_basic_TracerToFile_hh
diff -rupN vanilla/rosetta_source/src/core/init.cc patched/rosetta_source/src/core/init.cc
--- vanilla/rosetta_source/src/core/init.cc	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/core/init.cc	2012-06-10 14:29:51.234989756 +0200
@@ -470,7 +470,17 @@ void init(int argc, char * argv [])
 	basic::options::OptionCollection::set_show_accessed_options_flag( basic::options::option[ out::show_accessed_options ].value() );
 
 	// set Tracer options
-	basic::TracerOptions & TO( basic::Tracer::tracer_options() );
+  basic::TracerOptions & TO( basic::Tracer::tracer_options() );
+        if( basic::options::option[ out::mute_warning ].active() )   TO.muted_warning = basic::options::option[ out::mute_warning ]();
+        if( basic::options::option[ out::mute_info ].active() )   TO.muted_info = basic::options::option[ out::mute_info ]();
+        if( basic::options::option[ out::mute_debug ].active() )   TO.muted_debug = basic::options::option[ out::mute_debug ]();
+        if( basic::options::option[ out::mute_trace ].active() )   TO.muted_trace = basic::options::option[ out::mute_trace ]();
+
+        if( basic::options::option[ out::unmute_error ].active() )   TO.unmuted_error = basic::options::option[ out::unmute_error ]();
+        if( basic::options::option[ out::unmute_warning ].active() )   TO.unmuted_warning = basic::options::option[ out::unmute_warning ]();
+        if( basic::options::option[ out::unmute_info ].active() )   TO.unmuted_info = basic::options::option[ out::unmute_info ]();
+        if( basic::options::option[ out::unmute_debug ].active() )   TO.unmuted_debug = basic::options::option[ out::unmute_debug ]();
+
 	if( basic::options::option[ out::mute ].active() )   TO.muted = basic::options::option[ out::mute ]();
 
 	if( basic::options::option[ out::unmute ].active() ) TO.unmuted = basic::options::option[ out::unmute ]();
diff -rupN vanilla/rosetta_source/src/core/scoring/dssp/StrandPairing.cc patched/rosetta_source/src/core/scoring/dssp/StrandPairing.cc
--- vanilla/rosetta_source/src/core/scoring/dssp/StrandPairing.cc	2012-03-20 19:44:07.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/dssp/StrandPairing.cc	2012-06-10 16:12:40.613040062 +0200
@@ -46,7 +46,7 @@
 
 #include <core/scoring/dssp/PairingsList.hh>
 #include <utility/vector1.hh>
-
+#include <boost/functional/hash.hpp>
 
 static basic::Tracer tr("core.scoring.dssp");
 
@@ -123,6 +123,7 @@ void StrandPairingSet::compute( FArray2_
 					 && hbonds(j-1,i+1) < threshold ) ) {
 				Size orientation, pleating;
 				get_pleating(pose, i, j, orientation, pleating);
+				//				tr.Debug << "found antiparallel pair at (" << i << "," << j << ") "<<std::endl;
 				add_pairing(i, j, true , pleating );
       } else if (	// parallel bridge
 								 ( hbonds(i-1,j) < threshold
@@ -131,6 +132,7 @@ void StrandPairingSet::compute( FArray2_
 									&& hbonds(i,j+1) < threshold ) ) {
 				Size orientation, pleating;
 				get_pleating(pose, i, j, orientation, pleating);
+				//				tr.Debug << "found parallel pair at (" << i << "," << j << ") "<<std::endl;
 				//								tr.Trace << "ben: para phil: " << orientation << std::endl;
 				add_pairing(i,j, false, pleating );
       }
@@ -444,6 +446,21 @@ void StrandPairing::show_internals( std:
 	out << std::endl;
 }
 
+std::size_t StrandPairing::hash_value() const {
+	std::ostringstream str;
+	str << (antipar ? 'A' : 'P') << '_';
+	core::Size regA, regE;
+	if (antipar) {
+		regA=begin1_ + end2_;
+		regE=end1_ + begin2_;
+	} else {
+		regA=begin2_-begin1_;
+		regE=end2_-end1_;
+	}
+	str << regA << '_' << regE;
+	return boost::hash_value(str.str());
+}
+
 bool StrandPairing::mergeable( const StrandPairing &other ) const {
 	tr.Trace << "compare " << *this << " to " << other << std::endl;
 	if ( antipar != other.antipar) {
diff -rupN vanilla/rosetta_source/src/core/scoring/dssp/StrandPairing.hh patched/rosetta_source/src/core/scoring/dssp/StrandPairing.hh
--- vanilla/rosetta_source/src/core/scoring/dssp/StrandPairing.hh	2012-03-20 19:44:07.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/dssp/StrandPairing.hh	2012-06-10 16:12:40.615040739 +0200
@@ -58,6 +58,7 @@ public:
 	~StrandPairing();
 
 	core::Size operator==(const StrandPairing &rhs) const;
+	//	core::Size operator!=(const StrandPairing &rhs) const;
 	core::Size operator<(const StrandPairing &rhs) const;
 
 	core::Size size() const {
@@ -78,7 +79,7 @@ public:
 
 	core::Size get_register() const;
 	void get_all_register_and_bulges( SizeList& regs, SizeList& bulges ) const;
-
+	std::size_t hash_value() const;
 	bool contains(core::Size res) const;
 	bool is_bulge(core::Size res) const;
 	bool is_ladder() const;
diff -rupN vanilla/rosetta_source/src/core/scoring/methods/ResidualDipolarCouplingEnergy.cc patched/rosetta_source/src/core/scoring/methods/ResidualDipolarCouplingEnergy.cc
--- vanilla/rosetta_source/src/core/scoring/methods/ResidualDipolarCouplingEnergy.cc	2012-03-20 19:44:02.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/methods/ResidualDipolarCouplingEnergy.cc	2012-06-10 16:12:40.193041198 +0200
@@ -175,15 +175,22 @@ ResidualDipolarCouplingEnergy::rdc_from_
 // this has to be spread out over different routines to make this energy yield derivatives
 //////////////////////////////////////////////////////
 Real ResidualDipolarCouplingEnergy::eval_dipolar(
-  pose::Pose & pose
+		pose::Pose& pose
 ) const
 {
-
 	ResidualDipolarCoupling& rdc_data( rdc_from_pose( pose ) );
-	utility::vector1< core::scoring::RDC > const& All_RDC_lines( rdc_data.get_RDC_data() );
+	return eval_dipolar( pose, rdc_data );
+}
+
+Real ResidualDipolarCouplingEnergy::eval_dipolar(
+		pose::Pose const& pose,
+		ResidualDipolarCoupling& rdc_data
+) const
+{
 	Real score;
 	//Size const nrow( All_RDC_lines.size() ); //number of experimental couplins
 	if ( basic::options::option[ basic::options::OptionKeys::rdc::iterate_weights ].user() ) {
+		utility::vector1< core::scoring::RDC > const& All_RDC_lines( rdc_data.get_RDC_data() );
 		Real const sigma2( basic::options::option[ basic::options::OptionKeys::rdc::iterate_weights ] );
 		Real const tol( basic::options::option[ basic::options::OptionKeys::rdc::iterate_tol ] );
 		bool const reset( basic::options::option[ basic::options::OptionKeys::rdc::iterate_reset ] );
@@ -199,7 +206,6 @@ Real ResidualDipolarCouplingEnergy::eval
 			out << std::endl;
 		} //dump_weights
 	} else {
-
 		static std::string const fit_method(
 			basic::options::option[ basic::options::OptionKeys::rdc::fit_method ]()
 		);
@@ -207,54 +213,52 @@ Real ResidualDipolarCouplingEnergy::eval
 			tr.Trace << "residual-energy method chosen: 'svd' " << std::endl;
 			score = rdc_data.compute_dipscore( pose );
 		} else {
-				using namespace basic::options;
-      	using namespace basic::options::OptionKeys;
-				if (option[ OptionKeys::rdc::fixDa].user()) {
-					if (option[ OptionKeys::rdc::fixR].user()) {
-								//Real const tensorDa( option[ OptionKeys::rdc::fixDa] );
-								//Real const tensorR( option[ OptionKeys::rdc::fixR] );
-								utility::vector1<Real> const tensorDa = option[ OptionKeys::rdc::fixDa]();
-								utility::vector1<Real> const tensorR = option[ OptionKeys::rdc::fixR]();
-
-								//make sure R is between 0 and 2/3
-								 for ( core::Size i = 1; i <= option[ OptionKeys::rdc::fixR ]().size(); ++i) {
-										if ( (tensorR[i] < 0) || (tensorR[i] > 2.0/3.0) ) {
-    									utility_exit_with_message("0=< R <=2/3");
-										}
-								}
-
-								//make sure user provide the same number Da and R
-								if (  ( option[ OptionKeys::rdc::fixDa ]().size() !=	option[ OptionKeys::in::file::rdc ]().size() )
-               || ( option[ OptionKeys::rdc::fixR ]().size() !=  option[ OptionKeys::in::file::rdc ]().size() )   )  {
-    									utility_exit_with_message("Number of Da and R must be the same as in number of experiment");
-								}
-
-								score = rdc_data.compute_dipscore_nlsDaR( pose, tensorDa , tensorR );
-								} //end of Da and R
-					else {
-								//Real const tensorDa( option[ OptionKeys::rdc::fixDa] );
-								utility::vector1<Real> const tensorDa = option[ OptionKeys::rdc::fixDa]();
-							  //tr.Trace << "nls and fixDa: " << tensorDa  << std::endl;
-								score = rdc_data.compute_dipscore_nlsDa( pose, tensorDa);
-						} //end of Da and noR
-					}//end of fixDa
+			using namespace basic::options;
+			using namespace basic::options::OptionKeys;
+			if (option[ OptionKeys::rdc::fixDa].user()) {
+				if (option[ OptionKeys::rdc::fixR].user()) {
+					//Real const tensorDa( option[ OptionKeys::rdc::fixDa] );
+					//Real const tensorR( option[ OptionKeys::rdc::fixR] );
+					utility::vector1<Real> const tensorDa = option[ OptionKeys::rdc::fixDa]();
+					utility::vector1<Real> const tensorR = option[ OptionKeys::rdc::fixR]();
+
+					//make sure R is between 0 and 2/3
+					for ( core::Size i = 1; i <= option[ OptionKeys::rdc::fixR ]().size(); ++i) {
+						if ( (tensorR[i] < 0) || (tensorR[i] > 2.0/3.0) ) {
+							utility_exit_with_message("0=< R <=2/3");
+						}
+					}
+
+					//make sure user provide the same number Da and R
+					if (  ( option[ OptionKeys::rdc::fixDa ]().size() !=	option[ OptionKeys::in::file::rdc ]().size() )
+						|| ( option[ OptionKeys::rdc::fixR ]().size() !=  option[ OptionKeys::in::file::rdc ]().size() )   )  {
+						utility_exit_with_message("Number of Da and R must be the same as in number of experiment");
+					}
+
+					score = rdc_data.compute_dipscore_nlsDaR( pose, tensorDa , tensorR );
+				} else { //end of Da and R
+					//Real const tensorDa( option[ OptionKeys::rdc::fixDa] );
+					utility::vector1<Real> const tensorDa = option[ OptionKeys::rdc::fixDa]();
+					//tr.Trace << "nls and fixDa: " << tensorDa  << std::endl;
+					score = rdc_data.compute_dipscore_nlsDa( pose, tensorDa);
+				} //end of Da and noR
+			}	else {//end of fixDa
+				if (option[ OptionKeys::rdc::fixR].user()) {
+					//Real const tensorR( option[ OptionKeys::rdc::fixR] );
+					utility::vector1<Real> const tensorR = option[ OptionKeys::rdc::fixR]();
+					//tr.Trace << "nls and fixR: " << tensorR << std::endl;
+					for ( core::Size i = 1; i <= option[ OptionKeys::rdc::fixR ]().size(); ++i) {
+						if ( (tensorR[i] < 0) || (tensorR[i] > 2.0/3.0) ) {
+							utility_exit_with_message("0=< R <=2/3");
+						}
+					}
+					score = rdc_data.compute_dipscore_nlsR( pose, tensorR);
+				}//end of noDa and R
 				else {
-					if (option[ OptionKeys::rdc::fixR].user()) {
-								//Real const tensorR( option[ OptionKeys::rdc::fixR] );
-								utility::vector1<Real> const tensorR = option[ OptionKeys::rdc::fixR]();
-							  //tr.Trace << "nls and fixR: " << tensorR << std::endl;
-								 for ( core::Size i = 1; i <= option[ OptionKeys::rdc::fixR ]().size(); ++i) {
-										if ( (tensorR[i] < 0) || (tensorR[i] > 2.0/3.0) ) {
-    									utility_exit_with_message("0=< R <=2/3");
-										}
-								}
-								score = rdc_data.compute_dipscore_nlsR( pose, tensorR);
-								}//end of noDa and R
-					else {
-							  //tr.Trace << "nls" << std::endl;
-								score = rdc_data.compute_dipscore_nls( pose );
-								}//end of noDa and noR
-					}//end of no fixDa
+					//tr.Trace << "nls" << std::endl;
+					score = rdc_data.compute_dipscore_nls( pose );
+				}//end of noDa and noR
+			}//end of no fixDa
 		}//end of nls
 	}//end of else dump
 	return score;
@@ -279,7 +283,7 @@ ResidualDipolarCouplingEnergy::eval_atom
 		return;
 	}
 	Vector fij(0,0,0);
-	for (int ii=1; ii<=rdc_nrs.size(); ++ii) {
+	for (core::Size ii=1; ii<=rdc_nrs.size(); ++ii) {
 		core::Size rdc_nr = rdc_nrs[ ii ];
 		ResidualDipolarCoupling const& rdc_cache( *retrieve_RDC_from_pose( pose ) );
 		utility::vector1< core::scoring::RDC > All_RDC_lines( rdc_cache.get_RDC_data() );
diff -rupN vanilla/rosetta_source/src/core/scoring/methods/ResidualDipolarCouplingEnergy.hh patched/rosetta_source/src/core/scoring/methods/ResidualDipolarCouplingEnergy.hh
--- vanilla/rosetta_source/src/core/scoring/methods/ResidualDipolarCouplingEnergy.hh	2012-03-20 19:44:03.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/methods/ResidualDipolarCouplingEnergy.hh	2012-06-10 16:12:40.195048025 +0200
@@ -99,6 +99,11 @@ public:
 		Vector & F2
 	) const;
 
+	Real eval_dipolar(
+		pose::Pose const& pose,
+		ResidualDipolarCoupling& rdc_data
+	) const;
+
  private:
 
 	ResidualDipolarCoupling& rdc_from_pose(
@@ -106,10 +111,9 @@ public:
 	) const;
 
 	Real eval_dipolar(
-		pose::Pose & pose
+		pose::Pose& pose
 	) const;
 
-
 private:
 
 //used by Energy Method during scoring... should this become part of ResidualDipolarCoupling and thus cached in the pose
diff -rupN vanilla/rosetta_source/src/core/scoring/ResidualDipolarCoupling.cc patched/rosetta_source/src/core/scoring/ResidualDipolarCoupling.cc
--- vanilla/rosetta_source/src/core/scoring/ResidualDipolarCoupling.cc	2012-03-20 19:44:14.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/ResidualDipolarCoupling.cc	2012-06-10 16:12:40.202040922 +0200
@@ -167,7 +167,7 @@ void ResidualDipolarCoupling::read_RDC_f
 			throw( utility::excn::EXCN_BadInput(" invalid line "+line+" in rdc-file "+filename));
 		}
 
-		if ( res1 < 1 || res1 < 1 ) {
+		if ( res1 < 1 || res2 < 1 ) {
 			tr.Error << "negative residue number in line " << line << " in rdc-file " << filename << std::endl;
 			throw( utility::excn::EXCN_BadInput(" invalid line "+line+" in rdc_file " + filename ) );
 		}
@@ -592,7 +592,7 @@ Real ResidualDipolarCoupling::compute_di
 	Real Qnorm = 0;
 
 	Size irow(0);
-	Size excnt(0);
+	//Size excnt(0);
 	Size ex(0);
 	//Size exold(0);
 	for (utility::vector1<core::scoring::RDC>::iterator it =
@@ -628,7 +628,7 @@ Real ResidualDipolarCoupling::compute_di
 		//		pfac  = fc*ip[type].orires.c*invr2;
 		//for(i=0; i<power; i++)
 		//    pfac *= invr;
-		Size const power(3); //this will be 0 for CSA see above
+		//Size const power(3); //this will be 0 for CSA see above
 		RDC& rdc = *it;
 		numeric::xyzVector<Real> r(
 				pose.residue(rdc.res1()).atom(rdc.atom1()).xyz()
@@ -717,8 +717,8 @@ Real ResidualDipolarCoupling::compute_di
 
 		out.open_append( filename ) ;
 		using namespace core::pose::datacache;
-		Size const width( 8 );
-		Size const width_large(6);
+		//Size const width( 8 );
+		//Size const width_large(6);
 		// mjo comment out precision because it is not used and causes a warning.
 		//Size const precision( 2 );
 		std::string tag( core::pose::tag_from_pose(pose) );
@@ -838,7 +838,7 @@ typedef struct {
 } data_structDaR;
 
 //Evaluaterdc function required by lmmin
-void evaluaterdc(const double *par, int m_dat, const void *data, double *fvec, int *info ) {
+void evaluaterdc(const double *par, int m_dat, const void *data, double *fvec, int * ) {
     data_struct *mydata;
     mydata= (data_struct*)data;
     int i;
@@ -847,7 +847,7 @@ void evaluaterdc(const double *par, int 
     }
 }//evaluaterdc
 
-void evaluaterdcDa(const double *par, int m_dat, const void *data, double *fvec, int *info ) {
+void evaluaterdcDa(const double *par, int m_dat, const void *data, double *fvec, int * ) {
     data_structDa *mydata;
     mydata= (data_structDa*)data;
     int i;
@@ -856,7 +856,7 @@ void evaluaterdcDa(const double *par, in
     }
 }//evaluaterdcDa
 
-void evaluaterdcR(const double *par, int m_dat, const void *data, double *fvec, int *info ) {
+void evaluaterdcR(const double *par, int m_dat, const void *data, double *fvec, int * ) {
     data_structR *mydata;
     mydata= (data_structR*)data;
     int i;
@@ -865,7 +865,7 @@ void evaluaterdcR(const double *par, int
     }
 }//evaluaterdcR
 
-void evaluaterdcDaR(const double *par, int m_dat, const void *data, double *fvec, int *info ) {
+void evaluaterdcDaR(const double *par, int m_dat, const void *data, double *fvec, int * ) {
     data_structDaR *mydata;
     mydata= (data_structDaR*)data;
     int i;
@@ -1219,8 +1219,8 @@ Real ResidualDipolarCoupling::compute_di
 
 		out.open_append( filename ) ;
 		using namespace core::pose::datacache;
-		Size const width( 8 );
-		Size const width_large(6);
+		//Size const width( 8 );
+		//Size const width_large(6);
 		std::string tag( core::pose::tag_from_pose(pose) );
 		for (Size ex = 0; ex < nex_; ex++) {
 			//show_tensor_stats_nls( out, ex, par);
@@ -1488,8 +1488,8 @@ Real ResidualDipolarCoupling::compute_di
 
 		out.open_append( filename ) ;
 		using namespace core::pose::datacache;
-		Size const width( 8 );
-		Size const width_large(6);
+		//Size const width( 8 );
+		//Size const width_large(6);
 		std::string tag( core::pose::tag_from_pose(pose) );
 		for (Size ex = 0; ex < nex_; ex++) {
 			show_rdc_values( out, ex );
@@ -1754,8 +1754,8 @@ Real ResidualDipolarCoupling::compute_di
 
 		out.open_append( filename ) ;
 		using namespace core::pose::datacache;
-		Size const width( 8 );
-		Size const width_large(6);
+		//Size const width( 8 );
+		//Size const width_large(6);
 		// mjo comment out precision because it is not used and causes a warning.
 		//Size const precision( 2 );
 		std::string tag( core::pose::tag_from_pose(pose) );
@@ -2024,8 +2024,8 @@ Real ResidualDipolarCoupling::compute_di
 
 		out.open_append( filename ) ;
 		using namespace core::pose::datacache;
-		Size const width( 8 );
-		Size const width_large(6);
+		//Size const width( 8 );
+		//Size const width_large(6);
 		std::string tag( core::pose::tag_from_pose(pose) );
 		for (Size ex = 0; ex < nex_; ex++) {
 			show_rdc_values( out, ex );
@@ -2053,7 +2053,7 @@ void ResidualDipolarCoupling::show_tenso
 	out << F( width, precision, Aa ) << F( width, precision, Ar ) << F( width, precision, rhombicity ) << std::endl;
 }
 
-void ResidualDipolarCoupling::show_tensor_stats_nls( std::ostream& out, Size ex , const double *par) const {
+void ResidualDipolarCoupling::show_tensor_stats_nls( std::ostream& out, Size, const double *par) const {
   using namespace ObjexxFCL;
   using namespace ObjexxFCL::fmt;
 
diff -rupN vanilla/rosetta_source/src/core/scoring/ResidualDipolarCoupling.fwd.hh patched/rosetta_source/src/core/scoring/ResidualDipolarCoupling.fwd.hh
--- vanilla/rosetta_source/src/core/scoring/ResidualDipolarCoupling.fwd.hh	2012-03-20 19:44:14.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/ResidualDipolarCoupling.fwd.hh	2012-06-10 16:12:40.205041157 +0200
@@ -29,9 +29,6 @@ typedef utility::pointer::owning_ptr< Re
 
 class RDC;
 
-
-
-
 } // scoring
 } // core
 
diff -rupN vanilla/rosetta_source/src/core/scoring/ResidualDipolarCoupling.hh patched/rosetta_source/src/core/scoring/ResidualDipolarCoupling.hh
--- vanilla/rosetta_source/src/core/scoring/ResidualDipolarCoupling.hh	2012-03-20 19:44:13.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/ResidualDipolarCoupling.hh	2012-06-10 16:12:40.198039808 +0200
@@ -9,7 +9,7 @@
 
 /// @file   core/scoring/ResidualDipolarCoupling.hh
 /// @brief  Uses NMR RDC for scoring
-/// @author Srivatsan Raman
+/// @author Srivatsan Raman, Oliver Lange
 
 #ifndef INCLUDED_core_scoring_ResidualDipolarCoupling_hh
 #define INCLUDED_core_scoring_ResidualDipolarCoupling_hh
diff -rupN vanilla/rosetta_source/src/core/scoring/ScoreFunction.cc patched/rosetta_source/src/core/scoring/ScoreFunction.cc
--- vanilla/rosetta_source/src/core/scoring/ScoreFunction.cc	2012-03-20 19:44:14.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/ScoreFunction.cc	2012-06-10 16:12:40.609041115 +0200
@@ -481,7 +481,7 @@ ScoreFunction::show_pretty( std::ostream
 	out << "---------------------------------------------\n";
 	out << " Scores                       Weight   \n";
 	out << "---------------------------------------------\n";
-	float sum_weighted=0.0;
+	//float sum_weighted=0.0;
 	for ( int i=1; i<= n_score_types; ++i ) {
 		if ( weights_[ ScoreType(i) ] != 0.0 ) {
 			out << ' ' << LJ(24,ScoreType(i)) << ' '<< F(9,3,weights_[ ScoreType(i) ]) << "   "
@@ -918,7 +918,7 @@ ScoreFunction::get_sub_score(
 core::Real
 ScoreFunction::get_sub_score_exclude_res(
 	pose::Pose const & pose,
-	utility::vector1< core::Size > const & exclude_list
+	utility::vector1< core::Size > const &
 ) const {
 
 	utility::vector1< bool > residue_mask(true, pose.total_residue());
@@ -932,7 +932,7 @@ ScoreFunction::get_sub_score_exclude_res
 core::Real
 ScoreFunction::get_sub_score_exclude_res(
 	pose::Pose & pose,
-	utility::vector1< core::Size > const & exclude_list
+	utility::vector1< core::Size > const &
 ) const {
 
 	//If the energies are not up-to-date score the pose
@@ -951,7 +951,7 @@ ScoreFunction::get_sub_score_exclude_res
 void
 ScoreFunction::get_sub_score_exclude_res(
 	pose::Pose const & pose,
-	utility::vector1< core::Size > const & exclude_list,
+	utility::vector1< core::Size > const &,
 	EnergyMap & emap
 ) const {
 	utility::vector1< bool > residue_mask(true, pose.total_residue());
@@ -965,7 +965,7 @@ ScoreFunction::get_sub_score_exclude_res
 void
 ScoreFunction::get_sub_score_exclude_res(
 	pose::Pose & pose,
-	utility::vector1< core::Size > const & exclude_list,
+	utility::vector1< core::Size > const &,
 	EnergyMap & emap
 ) const {
 
@@ -2817,10 +2817,10 @@ find_weights_file(std::string name, std:
 	if ( data1.good() ) {
 		return name;
 	} else {
-	  utility::io::izstream data2( name + extension );
-	  if ( data2.good() ) {
+		utility::io::izstream data2( name + extension );
+		if ( data2.good() ) {
 			return name + extension;
-	  } else {
+		} else {
 			utility::io::izstream data3(  basic::database::full_name( "scoring/weights/"+name+extension, /*warn=*/false )  );
 			if ( data3.good() ) {
 				return basic::database::full_name( "scoring/weights/"+name+extension );
@@ -2833,6 +2833,7 @@ find_weights_file(std::string name, std:
 						"(./)" + name + extension + " or " +
 						basic::database::full_name( "scoring/weights/"+name, false )  + " or " +
 						basic::database::full_name( "scoring/weights/"+name+extension, false )  + " exist"  );
+					return "invalid"; // To make the compiler happy - should never reach here.
 				}
 			}
 		}
diff -rupN vanilla/rosetta_source/src/core/scoring/ScoreFunctionFactory.cc patched/rosetta_source/src/core/scoring/ScoreFunctionFactory.cc
--- vanilla/rosetta_source/src/core/scoring/ScoreFunctionFactory.cc	2012-03-20 19:44:13.000000000 +0100
+++ patched/rosetta_source/src/core/scoring/ScoreFunctionFactory.cc	2012-06-10 16:12:40.190039714 +0200
@@ -48,6 +48,10 @@ namespace scoring {
 ScoreFunctionOP
 ScoreFunctionFactory::create_score_function( std::string weights_tag )
 {
+	utility::vector1< std::string > patch_tags;
+	return create_score_function( weights_tag, patch_tags );
+	/* removing duplicated code OL 5/24/2012 */
+	/*
 	ScoreFunctionOP scorefxn( new ScoreFunction );
 
 	load_weights_file( weights_tag, scorefxn );
@@ -63,6 +67,7 @@ ScoreFunctionFactory::create_score_funct
 	}
 
 	return scorefxn;
+	*/
 }
 
 
@@ -97,7 +102,7 @@ ScoreFunctionFactory::create_score_funct
 	for ( utility::vector1< std::string >::const_iterator it = patch_tags.begin(); it != patch_tags.end(); ++it ) {
 		std::string const& patch_tag( *it );
 		if ( patch_tag.size() && patch_tag != "NOPATCH" ) {
-			tr.Debug << "SCOREFUNCTION: apply patch "  << patch_tag << std::endl;
+			//			tr.Debug << "SCOREFUNCTION: apply patch "  << patch_tag << std::endl;
 			scorefxn->apply_patch_from_file( patch_tag );
 		}
 	}
@@ -124,8 +129,11 @@ ScoreFunctionFactory::create_score_funct
 
 	// create a new scorefunction
 	ScoreFunctionOP scorefxn( new ScoreFunction );
-
-	std::string patch_tag_local( patch_tag );
+	utility::vector1< std::string > patch_tags;
+	patch_tags.push_back( patch_tag );
+	return create_score_function( weights_tag, patch_tags );
+	/* REMOVING DUPLICATED CODE OL 5/24/2012 */
+	/*	std::string patch_tag_local( patch_tag );
 	if ( weights_tag == STANDARD_WTS && patch_tag == SCORE12_PATCH &&
 			basic::options::option[ basic::options::OptionKeys::corrections::score::score12prime ] ) {
 		weights_tag = "score12prime";
@@ -150,6 +158,7 @@ ScoreFunctionFactory::create_score_funct
 	}
 
 	return scorefxn;
+	*/
 }
 
 void ScoreFunctionFactory::apply_user_defined_reweighting_( core::scoring::ScoreFunctionOP scorefxn ) {
@@ -236,7 +245,7 @@ core::scoring::ScoreFunctionOP getScoreF
 	if( option[ score::empty ]() ) return scorefxn;
 
 	std::string weight_set = option[ score::weights ];
-	std::string patch      = option[ score::patch ];
+	utility::vector1< std::string > patch_tags = option[ score::patch ]();
 
 
 	if ( !option[ score::weights ].user() && !is_fullatom ){
@@ -251,24 +260,26 @@ core::scoring::ScoreFunctionOP getScoreF
 		/// and has not also asked for the score12 patch, then do not apply the score12 patch to it.
 		if ( ( weight_set == "standard" && !option[ score::weights ].user() ) &&
 				 ( !option[ score::patch ].user() ) ) {
-			patch = "score12";
+			patch_tags.push_back( "score12" );
 			if( basic::options::option[basic::options::OptionKeys::corrections::correct]) {
 				weight_set = "score12_w_corrections";
-				patch = "" ;
+				patch_tags.clear();
 			} else if ( basic::options::option[ basic::options::OptionKeys::corrections::score::score12prime ] ) {
 				weight_set = "score12prime";
-				patch = "";
+				patch_tags.clear();
 			}
 		}
 
 	}
 
 	T("core.scoring.ScoreFunctionFactory") << "SCOREFUNCTION: " << weight_set << std::endl;
-	if ( patch == "" ) {
+	if ( patch_tags.size() == 0 ) {
 		scorefxn = scoring::ScoreFunctionFactory::create_score_function( weight_set );
 	} else {
-		T("core.scoring.ScoreFunctionFactory") << "SCOREFUNCTION PATCH: " << patch << std::endl;
-		scorefxn = scoring::ScoreFunctionFactory::create_score_function( weight_set, patch );
+		if ( patch_tags.size() > 1 && patch_tags[1]=="" && patch_tags[2]!="" ) {
+			T("core.scoring.ScoreFunctionFactory") << "SCOREFUNCTION PATCH: " << patch_tags[2] << std::endl;
+		}	else if ( patch_tags[1]!="" ) T("core.scoring.ScoreFunctionFactory") << "SCOREFUNCTION PATCH: " << patch_tags[1] << std::endl;
+		scorefxn = scoring::ScoreFunctionFactory::create_score_function( weight_set, patch_tags );
 	}
 
 	// add in constraint weights if specified by the user. maybe we want other constraint
diff -rupN vanilla/rosetta_source/src/core/svn_version.cc patched/rosetta_source/src/core/svn_version.cc
--- vanilla/rosetta_source/src/core/svn_version.cc	2012-03-28 21:36:22.000000000 +0200
+++ patched/rosetta_source/src/core/svn_version.cc	2012-06-09 16:46:31.115040188 +0200
@@ -22,7 +22,7 @@
 
 namespace core {
 
-std::string minirosetta_svn_version() { return "48138:48185"; }
-std::string minirosetta_svn_url() { return "https://svn.rosettacommons.org/source/branches/releases/rosetta-3.4/rosetta_source"; }
+std::string minirosetta_svn_version() { return "unknown"; }
+std::string minirosetta_svn_url() { return "unknown"; }
 
 } // namespace core
diff -rupN vanilla/rosetta_source/src/devel.src.settings patched/rosetta_source/src/devel.src.settings
--- vanilla/rosetta_source/src/devel.src.settings	2012-03-21 09:06:01.000000000 +0100
+++ patched/rosetta_source/src/devel.src.settings	2012-06-05 23:43:19.377010095 +0200
@@ -20,7 +20,6 @@ libraries = [
 ]
 subprojects = [
 	"protocols.7",
-	"protocols.6",
 	"protocols_f.5",
 	"protocols_e.5",
 	"protocols_d.5",
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/AbrelaxMover.cc patched/rosetta_source/src/protocols/abinitio/AbrelaxMover.cc
--- vanilla/rosetta_source/src/protocols/abinitio/AbrelaxMover.cc	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/AbrelaxMover.cc	2012-06-10 16:12:40.442040940 +0200
@@ -23,6 +23,7 @@
 #include <core/kinematics/MoveMap.hh>
 #include <core/kinematics/FoldTree.hh>
 #include <core/scoring/ScoreFunction.hh>
+#include <core/scoring/ScoreFunctionFactory.hh>
 #include <core/kinematics/ShortestPathInFoldTree.hh>
 #include <core/scoring/constraints/ConstraintSet.hh>
 #include <protocols/abinitio/FragmentSampler.hh>
@@ -43,6 +44,8 @@
 #include <protocols/topology_broker/util.hh>
 #include <protocols/viewer/viewers.hh>
 
+#include <protocols/simple_moves/RepulsiveOnlyMover.hh>
+
 // Utility headers
 #include <basic/options/option.hh>
 #include <basic/datacache/BasicDataCache.hh>
@@ -231,6 +234,14 @@ void AbrelaxMover::apply( pose::Pose &po
 	//   setup -- e.g., sequence --> pose
 	//
 	topology_broker()->apply( pose ); //creates pose and a state in the topology_broker needed for the whole run
+
+	// apply a mover which calculates only repulsive energy on designate residues
+	{
+		protocols::simple_moves::RepulsiveOnlyMover replonly;
+		replonly.set_mutate_to_glycine( false );
+		replonly.apply( pose );
+	}
+
 	protocols::viewer::add_conformation_viewer( pose.conformation(), "start_pose" );  //add viewer
 
 #ifdef BOINC_GRAPHICS
@@ -339,6 +350,12 @@ void AbrelaxMover::apply( pose::Pose &po
 	if ( relax_protocol() || b_return_unrelaxed_fullatom_ ) {
 		tr << "AbrelaxMover: switch to fullatom" << std::endl;
 		jd2::get_current_job()->add_string_real_pair( "prefa_centroid_score", 	((sampling_protocol()->current_scorefxn())( pose ) ) );
+		core::scoring::ScoreFunctionOP clean_score3( core::scoring::ScoreFunctionFactory::create_score_function( "score3" ) );
+		clean_score3->set_weight( scoring::linear_chainbreak, 1.33 );
+		clean_score3->set_weight( scoring::overlap_chainbreak, 1.0 );
+		clean_score3->set_weight( scoring::chainbreak, 1.0 );
+		jd2::get_current_job()->add_string_real_pair( "prefa_clean_score3", ((*clean_score3)(pose)) );
+
 		topology_broker()->switch_to_fullatom( pose );
 
 		// we're now in fullatom mode - so upate the score function.
@@ -352,6 +369,13 @@ void AbrelaxMover::apply( pose::Pose &po
 		protocols::relax::RelaxProtocolBaseCOP relax_prot = relax_protocol();
 		core::scoring::ScoreFunctionCOP last_scorefxn_cop = relax_prot->get_scorefxn();
 		last_scorefxn = last_scorefxn_cop->clone();
+	} //switched to fullatom
+
+
+	{// apply a mover which calculates only repulsive energy on designate residues
+		protocols::simple_moves::RepulsiveOnlyMover replonly;
+		replonly.set_mutate_to_glycine( false );
+		replonly.apply( pose );
 	}
 
 	if( option[ basic::options::OptionKeys::abinitio::close_loops_by_idealizing ]() ){
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/AllResiduesChanged.hh patched/rosetta_source/src/protocols/abinitio/AllResiduesChanged.hh
--- vanilla/rosetta_source/src/protocols/abinitio/AllResiduesChanged.hh	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/AllResiduesChanged.hh	2012-06-10 16:12:40.444077088 +0200
@@ -1,10 +1,12 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
 // (c) Copyright Rosetta Commons Member Institutions.
 // (c) This file is part of the Rosetta software suite and is made available under license.
 // (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
 // (c) For more information, see http://www.rosettacommons.org. Questions about this can be
 // (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
 
-
 #ifndef INCLUDED_protocols_abinitio_AllResiduesChanged_hh
 #define INCLUDED_protocols_abinitio_AllResiduesChanged_hh
 
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/ClassicAbinitio.cc patched/rosetta_source/src/protocols/abinitio/ClassicAbinitio.cc
--- vanilla/rosetta_source/src/protocols/abinitio/ClassicAbinitio.cc	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/ClassicAbinitio.cc	2012-06-10 16:12:40.448040722 +0200
@@ -90,7 +90,7 @@ using namespace basic::options::OptionKe
 
 /*!
 @detail call this:
-ClassicAbinitio::register_options() before protocols::init::init().
+ClassicAbinitio::register_options() before devel::init().
 Derived classes that overload this function should also call Parent::register_options()
 */
 
@@ -99,7 +99,7 @@ Derived classes that overload this funct
 // ClassicAbinitio::register_options() in your main function, you get a really
 // unintuitive segfault as the options system doesn't know about the options
 // listed below. The solution is to call register_options() in your main method
-// before protocols::init::init(), which is really ugly as the main method shouldn't need
+// before devel::init(), which is really ugly as the main method shouldn't need
 // to know what protocols are called, and it's prone to error because it's an
 // easy thing to forget.
 // This should get some more thought before it becomes the standard way to add options.
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/ConstraintFragmentSampler.cc patched/rosetta_source/src/protocols/abinitio/ConstraintFragmentSampler.cc
--- vanilla/rosetta_source/src/protocols/abinitio/ConstraintFragmentSampler.cc	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/ConstraintFragmentSampler.cc	2012-06-10 16:12:40.451040081 +0200
@@ -68,7 +68,7 @@ using namespace basic::options::OptionKe
 
 /*!
 @detail call this:
-ConstraintFragmentSampler::register_options() before protocols::init::init().
+ConstraintFragmentSampler::register_options() before devel::init().
 Derived classes that overload this function should also call Parent::register_options()
 */
 
@@ -86,7 +86,6 @@ void protocols::abinitio::ConstraintFrag
 	option.add_relevant( fold_cst::seq_sep_stages );
 	option.add_relevant( fold_cst::skip_on_noviolation_in_stage1 );
 	option.add_relevant( fold_cst::stage1_ramp_cst_cycle_factor );
-	option.add_relevant( fold_cst::stage2_constraint_threshold );
 	option.add_relevant( fold_cst::ignore_sequence_seperation );
 	option.add_relevant( fold_cst::no_recover_low_at_constraint_switch );
 	option.add_relevant( fold_cst::ramp_coord_cst );
@@ -115,8 +114,8 @@ void ConstraintFragmentSampler::set_defa
 	using namespace basic::options;
 	using namespace basic::options::OptionKeys;
 	set_constraint_weight( option[ OptionKeys::constraints::cst_weight ] );
-	show_viol_level_ = 1;
-	max_seq_sep_fudge_ = 1.0; //models roseta++ behaviour.
+	show_viol_level_ = option[OptionKeys::constraints::viol_level];
+	max_seq_sep_fudge_ = 1.0; //models rosetta++ behaviour.
 
 	if ( option[ OptionKeys::fold_cst::seq_sep_stages ].user() ) {
 		if ( option[ OptionKeys::fold_cst::seq_sep_stages ]().size() != 3 ) {
@@ -132,7 +131,6 @@ void ConstraintFragmentSampler::set_defa
 	}
 
 	bSkipOnNoViolation_ = option[ fold_cst::skip_on_noviolation_in_stage1 ];
-	constraint_threshold_ = option[ fold_cst::stage2_constraint_threshold ];
 
 	bNoRecoverLowAtSwitch_ = option[ fold_cst::no_recover_low_at_constraint_switch ];
 
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/ConstraintFragmentSampler.hh patched/rosetta_source/src/protocols/abinitio/ConstraintFragmentSampler.hh
--- vanilla/rosetta_source/src/protocols/abinitio/ConstraintFragmentSampler.hh	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/ConstraintFragmentSampler.hh	2012-06-10 16:12:40.453040724 +0200
@@ -199,9 +199,6 @@ private:
   //@brief just for screen output: how verbose should it be
   Size show_viol_level_;
 
-  //@brief abolish run in stage2 if constraint threshold is violated -- '0' = inactive
-  Size constraint_threshold_;
-
 	//@brief usually we do a recover_low before we increase the number of active constraints
 	bool bNoRecoverLowAtSwitch_;
 
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/FragmentCost.hh patched/rosetta_source/src/protocols/abinitio/FragmentCost.hh
--- vanilla/rosetta_source/src/protocols/abinitio/FragmentCost.hh	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/FragmentCost.hh	2012-06-10 16:12:40.456040490 +0200
@@ -14,8 +14,8 @@
 /// @date   Wed Aug 22 12:08:31 2007
 ///
 
-#ifndef core_fragments_FragData_HH
-#define core_fragments_FragData_HH
+#ifndef INCLUDED_protocols_abinitio_FragmentCost_HH
+#define INCLUDED_protocols_abinitio_FragmentCost_HH
 
 // Unit Headers
 // AUTO-REMOVED #include <core/fragment/FragData.fwd.hh>
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/FragmentSampler.cc patched/rosetta_source/src/protocols/abinitio/FragmentSampler.cc
--- vanilla/rosetta_source/src/protocols/abinitio/FragmentSampler.cc	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/FragmentSampler.cc	2012-06-10 16:12:40.459065171 +0200
@@ -64,7 +64,7 @@ using namespace basic::options::OptionKe
 
 /*!
 @detail call this:
-FragmentSampler::register_options() before protocols::init::init().
+FragmentSampler::register_options() before devel::init().
 Derived classes that overload this function should also call Parent::register_options()
 */
 void protocols::abinitio::FragmentSampler::register_options() {
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/IterativeAbrelax.cc patched/rosetta_source/src/protocols/abinitio/IterativeAbrelax.cc
--- vanilla/rosetta_source/src/protocols/abinitio/IterativeAbrelax.cc	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/IterativeAbrelax.cc	2012-06-10 16:12:40.461039708 +0200
@@ -40,6 +40,7 @@
 
 #include <utility/vector1.hh>
 
+#include <ctime>
 
 static basic::Tracer tr("protocols.iterative");
 
@@ -70,10 +71,10 @@ void protocols::abinitio::IterativeAbrel
 
 IterativeAbrelax::IterativeAbrelax()
 	: Parent( "abstract" ),
-		centroid_archive_(&fullatom_archive_ ),
+		centroid_archive_( &fullatom_archive_ ), //calling cstor of IterativeCentroid
 		fullatom_( false )
 {
-	fullatom_ = option[ iterative::fullatom ];
+	fullatom_ = option[ iterative::fullatom ]();
 	//not needed anymore: if I initialize base with this finish_stage
 	if ( !fullatom_ ) centroid_archive_.set_finish_stage( IterativeBase::LAST_CENTROID_START );
 }
@@ -100,6 +101,11 @@ bool IterativeAbrelax::finished() const 
 	return ( centroid_archive_.finished() && !fullatom_ ) || fullatom_archive_.finished();
 }
 
+void IterativeAbrelax::initialize() {
+	centroid_archive_.initialize();
+	if ( fullatom_ ) fullatom_archive_.initialize();
+}
+
 bool IterativeAbrelax::still_interested( Batch const& batch ) const {
 	//	return Parent::still_interested( batch )&&
 	return ( centroid_archive_.still_interested( batch ) && ( fullatom_ && fullatom_archive_.still_interested( batch ) ) );
@@ -140,8 +146,23 @@ void IterativeAbrelax::set_manager( jd2:
 
 
 void IterativeAbrelax::idle() {
+	int start_time( time(NULL) );
 	centroid_archive_.idle();
+	int later( time(NULL) );
+	int centroid_idle( later-start_time);
+	if ( centroid_idle > 10 ) {
+		tr.Debug << "spend " << centroid_idle << " seconds in idle() function of " << centroid_archive_.name() << std::endl;
+		if ( fullatom_ ) tr.Debug << "will postpone idle() call for " << fullatom_archive_.name() << std::endl;
+		return;
+	}
 	if ( fullatom_ ) fullatom_archive_.idle();
+	int final( time(NULL) );
+	int fullatom_idle( final-later );
+	if ( fullatom_idle > 10 ) {
+		tr.Debug << "spend " << fullatom_idle << " seconds in idle() function of " << fullatom_archive_.name() << std::endl;
+		tr.Debug << "will postpone idle() call for " << fullatom_archive_.name() << std::endl;
+		return;
+	}
 }
 
 void IterativeAbrelax::save_to_file( std::string suffix ) {
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/IterativeAbrelax.hh patched/rosetta_source/src/protocols/abinitio/IterativeAbrelax.hh
--- vanilla/rosetta_source/src/protocols/abinitio/IterativeAbrelax.hh	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/IterativeAbrelax.hh	2012-06-10 16:12:40.464040662 +0200
@@ -69,6 +69,9 @@ public:
 
   IterativeAbrelax();
 
+	//	virtual bool ready_for_batch() const { return false; };
+	virtual void initialize();
+
   virtual bool finished() const;
 	//  virtual bool ready_for_batch() const;
 	virtual bool still_interested( jd2::archive::Batch const& batch ) const;
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/IterativeBase.cc patched/rosetta_source/src/protocols/abinitio/IterativeBase.cc
--- vanilla/rosetta_source/src/protocols/abinitio/IterativeBase.cc	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/IterativeBase.cc	2012-06-10 16:12:40.468039577 +0200
@@ -17,12 +17,15 @@
 #include <protocols/abinitio/IterativeBase.hh>
 #include <protocols/jd2/archive/ArchiveManager.hh>
 
+
 // Package Headers
 #include <protocols/noesy_assign/NoesyModule.hh>
 #include <protocols/noesy_assign/NoesyModule.impl.hh>
 
 // to test broker setup-file
 #include <protocols/topology_broker/TopologyBroker.hh>
+#include <protocols/topology_broker/ConstraintClaimer.hh>
+#include <protocols/topology_broker/ConstraintEvaluatorWrapper.hh>
 #include <protocols/topology_broker/util.hh>
 #include <basic/options/keys/broker.OptionKeys.gen.hh>
 
@@ -66,10 +69,10 @@
 // AUTO-REMOVED #include <core/scoring/constraints/util.hh>
 
 #include <protocols/abinitio/PairingStatistics.hh>
-#include <protocols/constraints_additional/ConstraintEvaluator.hh>
 #include <protocols/simple_filters/JumpEvaluator.hh>
 #include <protocols/simple_filters/RmsdEvaluator.hh>
 #include <protocols/simple_filters/ScoreEvaluator.hh>
+#include <protocols/simple_filters/RDC_Evaluator.hh>
 #include <protocols/evaluation/util.hh>
 #include <protocols/loops/util.hh>
 #include <protocols/loops/Loop.hh>
@@ -100,7 +103,7 @@
 #include <basic/options/keys/in.OptionKeys.gen.hh>
 #include <basic/options/keys/run.OptionKeys.gen.hh>
 #include <basic/options/keys/cluster.OptionKeys.gen.hh>
-
+#include <basic/options/keys/score.OptionKeys.gen.hh>
 // Third-party Headers
 #include <boost/functional/hash.hpp>
 
@@ -172,11 +175,13 @@ OPT_1GRP_KEY( String, iterative, initial
 OPT_1GRP_KEY( Integer, iterative, recompute_beta_Naccept )
 OPT_1GRP_KEY( String, iterative, flags_fullatom )
 OPT_1GRP_KEY( Boolean, iterative, force_topology_resampling )
+OPT_2GRP_KEY( Boolean, iterative, normalize, sampling )
 
 std::string const NOESY_CST_FILE_NAME("noe_auto_assign.cst");
 
 bool protocols::abinitio::IterativeBase::options_registered_( false );
 
+
 //Mike: when you want to remove these Macros... leave them at least here as comment - since they provide documentation
 void protocols::abinitio::IterativeBase::register_options() {
 	if ( !options_registered_ ) {
@@ -192,10 +197,10 @@ void protocols::abinitio::IterativeBase:
 		NEW_OPT( iterative::enumerate::skip_half, "run half of the batches without enumerated pairings -- even before Naccept is reached", false );
 		//		NEW_OPT( iterative::turnover_rate, "exchange of X percent of archive before new batch is started", 0.1 );
 		NEW_OPT( iterative::accept_ratio, "switch to new stage if accept_ratio is lower than", 0.2 );
-		NEW_OPT( iterative::rmsf_nstruct, "how many structures of pool used for computations of cores", 50 );
+		NEW_OPT( iterative::rmsf_nstruct, "how many structures of pool used for computations of cores", 30 );
 		NEW_OPT( iterative::cen_score, "energy function for centroid pool", "score3" );
 		NEW_OPT( iterative::cen_score_patch, "patch of centroi_pool energy function", "NOPATCH" );
-		NEW_OPT( iterative::fa_score, "energy function for centroid pool", "score13_env_hb" );
+		NEW_OPT( iterative::fa_score, "energy function for centroid pool", "score12_full" );
 		NEW_OPT( iterative::fa_score_patch, "patch of centroi_pool energy function", "NOPATCH" );
 		NEW_OPT( iterative::max_nstruct, "give maximum numbers of structures generated for a given stage before switch -- 0 for infinite, -1 for skip stage", 0);
 
@@ -214,7 +219,7 @@ void protocols::abinitio::IterativeBase:
 
 		NEW_OPT( iterative::fix_core, "RIGID file for RigidChunkClaimer to fix residues in stage 1-3", "" );
 
-		NEW_OPT( iterative::cenpool_noesy_cst_weight, "weight to apply to centroid pool for noesy-autoassigned constraints", 5);
+		NEW_OPT( iterative::cenpool_noesy_cst_weight, "weight to apply to centroid pool for noesy-autoassigned constraints", 1);
 		NEW_OPT( iterative::cenpool_chemicalshift_weight, "weight to apply to chemical shifts in centroid pool rescoring", 5 );
 		NEW_OPT( iterative::chemicalshift_column, "column name of the ChemicalShiftEvaluator used for chemical shift rescoring -- allows to have inactive shifts in score", "chem_shift" );
 		NEW_OPT( iterative::super_quick_relax_protocol, "provide a sequence file for super quick relax ", "none" );
@@ -230,12 +235,66 @@ void protocols::abinitio::IterativeBase:
 		NEW_OPT( iterative::dcut,"in ADAPT1 what dcut should be chosen",7);
 		NEW_OPT( iterative::initial_beta_topology,"start with this file as beta.top in stage3","" );
 		NEW_OPT( iterative::force_topology_resampling,"if strand-fraction is low topology sampling is usually skipped. Override this with this flags", false );
-		NEW_OPT( iterative::recompute_beta_Naccept, "recompute beta-topology after minimum of Naccept structures -- if no initial_beta_topology always recompute", -1 );
+		NEW_OPT( iterative::recompute_beta_Naccept, "recompute beta-topology after minimum of Naccept structures -- if no initial_beta_topology always recompute", 2000 );
 		NEW_OPT( iterative::flags_fullatom, "point to flag-file to read flags for fullatom-refinement and loop-closing specify e.g., as ../flags_fullatom ","");
+		NEW_OPT( iterative::normalize::sampling,
+			"dynamically determined score-variation will be used for patching the sampling stage scores", false );
+
 		options_registered_ = true;
 	}
 }
 
+#define OBSOLETE(key)														\
+	if ( option[ key ].user() ) {									\
+		tr.Warning << "WARNING: Option "<< #key<< " is deprecated!" << std::endl; \
+	}
+
+void warn_obsolete_flags() {
+	using namespace basic::options;
+	using namespace basic::options::OptionKeys;
+	//	if ( option[ iterative::copy_pool_for_convergence_check ].user() ) {
+	//		tr.Warning << "WARNING: Option -iterative::copy_pool_for_convergence_check is deprecated!"  << std::endl;
+	//	}
+	OBSOLETE(iterative::copy_pool_for_convergence_check);
+	OBSOLETE(iterative::fix_core);
+	OBSOLETE(iterative::enumerate::Naccept);
+	OBSOLETE(iterative::min_core_fraction_to_score);
+	OBSOLETE(iterative::force_scored_region);
+	OBSOLETE(iterative::scored_ss_core);
+
+	OBSOLETE( iterative::perturb_resampling);
+
+	OBSOLETE( iterative::chainbreak_evaluator_weight);
+
+	//OBSOLETE( iterative::safety_hatch_scorecut);
+	OBSOLETE( iterative::cluster);
+
+
+//OBSOLETE( iterative::cenpool_chemicalshift_weight);
+//OBSOLETE( iterative::chemicalshift_column);
+//OBSOLETE( iterative::super_quick_relax_protocol);
+//OBSOLETE( iterative::centroid_before_quickrelax_weight);
+//OBSOLETE( iterative::fullatom_after_quickrelax_weight);
+//OBSOLETE( iterative::limit_decoys_for_noe_assign);
+//OBSOLETE( iterative::centroid_quickrelax);
+
+//noesy
+//OBSOLETE( iterative::skip_redundant_constraints);
+//OBSOLETE( iterative::cenpool_noesy_cst_weight);
+//OBSOLETE( iterative::delay_noesy_reassign);
+//OBSOLETE( iterative::initial_noe_auto_assign_csts);
+//OBSOLETE( iterative::auto_assign_scheme);
+//OBSOLETE( iterative::dcut);
+
+//OBSOLETE( iterative::initial_beta_topology);
+//OBSOLETE( iterative::force_topology_resampling);
+//OBSOLETE( iterative::recompute_beta_Naccept);
+
+//OBSOLETE( iterative::flags_fullatom);
+//OBSOLETE( iterative::normalize::sampling);
+
+}
+
 namespace protocols {
 namespace abinitio {
 
@@ -243,10 +302,53 @@ static numeric::random::RandomGenerator 
 
 using namespace jd2::archive;
 
-IterativeBase::IterativeBase(std::string name )
-	: EvaluatedArchive(),
-		scored_core_initialized_( false ),
-		super_quick_relax_of_centroids_( false ),
+
+void fix_chainbreak_patch( scoring::ScoreFunctionOP scorefxn, std::string const& patch_name ) {
+	//constraints are done via patches
+	bool chainbreaks_in_patch( scorefxn->get_weight( scoring::linear_chainbreak ) > 0.0 );
+	core::Real extra_chainbreak_weight( basic::options::option[ basic::options::OptionKeys::jumps::increase_chainbreak ] );
+	if ( !chainbreaks_in_patch ) { //if chainbreak is not patched .. set it
+		core::Real lin_wgt( 4.0/3.0 * extra_chainbreak_weight );
+		core::Real overlap_wgt( 1.0 * extra_chainbreak_weight );
+		core::Real quad_wgt( 1.0 * extra_chainbreak_weight );
+		tr.Info << "no chainbreaks specified in  " << patch_name << ",..."
+						<< " set chainbreaks to " << lin_wgt << " and "
+						<< overlap_wgt <<" for linear- and overlap-chainbreak, respectively" << std::endl;
+		scorefxn->set_weight( scoring::chainbreak, quad_wgt );
+		scorefxn->set_weight( scoring::linear_chainbreak, lin_wgt );
+		scorefxn->set_weight( scoring::overlap_chainbreak, overlap_wgt );
+	}
+}
+
+bool decide_on_beta_jumping_from_frags() {
+	/// determine if we have enough strands to do jumping...
+	bool bDoBetaJumping(true);
+	using namespace core::fragment;
+	FragSetOP frags_s = FragmentIO( option[ OptionKeys::abinitio::number_3mer_frags ]()	).read_data( option[ in::file::frag3 ] );
+	core::fragment::SecondaryStructure ss_def( *frags_s, true /*no JustUseCentralResidue */ );
+	Size ct_E( 0 );
+	for ( Size i=1; i<=ss_def.total_residue(); ++i ) {
+		if ( ss_def.strand_fraction( i ) > 0.7 ) ++ct_E;
+	}
+	mem_tr << "fragments loaded for ss-prediction" << std::endl;
+	//less than 15% strands and less than 40 residues in total and we skip jumping...
+	bDoBetaJumping = true;
+	if ( (ct_E*1.0)/(ss_def.total_residue()*1.0) < 0.15 && ct_E < 40 ) {
+		tr.Info << "skip beta-jumping since mostly alpha-helical protein" << std::endl;
+		tr.Info << "only " << (ct_E*1.0)/(ss_def.total_residue()*1.0)*100 << "% of residues display significant strand-character" << std::endl;
+		bDoBetaJumping = false;
+	}
+	if ( !bDoBetaJumping && option[ OptionKeys::iterative::force_topology_resampling ]() ) {
+		tr.Info << "force-topology-resampling despite low beta-sheet content due to flag -force_topology_resampling" << std::endl;
+		bDoBetaJumping = true;
+	}
+	return bDoBetaJumping;
+}
+
+
+IterativeBase::IterativeBase(std::string name_in )
+	: Parent(),
+
 		stage_( ENUMERATION ),
 		finish_stage_( LAST_CENTROID_START ),
 		first_batch_this_stage_ ( 1 ),
@@ -267,11 +369,16 @@ IterativeBase::IterativeBase(std::string
 		noesy_assign_float_cycle_( 1.0 ), //changed OCT 20th 2010 ... start only in generation 3 of STAGE2_RESAMPLE with cyana-cycle 2
 		first_noesy_cst_file_( "n/a" ),
 		first_noesy_fa_cst_file_ ("n/a" ),
+		current_noesy_sampling_file_( "n/a" ),
 		bCombineNoesyCst_( true ),
+		super_quick_relax_of_centroids_( option[ iterative::centroid_quickrelax ]() ),
+		use_dynamic_weights_for_sampling_( option[ iterative::normalize::sampling ]() ),
 		rdc_data_( NULL ),
 		cst_data_( NULL ),
 		cst_fa_data_( NULL )
 {
+	warn_obsolete_flags();
+	basic::show_time_on_cerr = true;
 	using namespace ObjexxFCL;
 	mem_tr << "IterativeBase CStor-Start" << std::endl;
 	//changes for debug mode
@@ -280,92 +387,9 @@ IterativeBase::IterativeBase(std::string
 	}
 
 	//name is e.g., centroid_pool or fullatom_pool
-	set_name( name );
-
-
-	// --- setup scorefxn
-	core::scoring::ScoreFunctionOP scorefxn =
-		core::scoring::ScoreFunctionFactory::create_score_function( cen_score(), cen_score_patch() );
-	tr.Info << "create Archive Scorefunction with: "
-					<<  option[ iterative::cen_score]() << " "
-					<<  option[ iterative::cen_score_patch ]() << std::endl;
-
-
-	if (  option[ OptionKeys::iterative::force_scored_region ].user() ) {
-		std::ifstream is( option[ OptionKeys::iterative::force_scored_region ]().name().c_str() );
-		
-		if (!is.good()) {
-			utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + option[ OptionKeys::iterative::force_scored_region ]().name() + "'" );
-		}
-		loops::LoopsFileIO loop_file_reader;
-		loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format( is, option[ OptionKeys::iterative::force_scored_region ](), false /*no strict checking */, "RIGID" );
-		scored_core_ = loops::Loops( loops );
-	}
-
-	mem_tr << "setup cen-scorefxn" << std::endl;
-
-	//constraints are done via patches
-	bool chainbreaks_in_patch( scorefxn->get_weight( scoring::linear_chainbreak ) > 0.0 );
-	core::Real extra_chainbreak_weight( basic::options::option[ basic::options::OptionKeys::jumps::increase_chainbreak ] );
-	if ( !chainbreaks_in_patch ) { //if chainbreak is not patched .. set it
-		core::Real lin_wgt( 4.0/3.0 * extra_chainbreak_weight );
-		core::Real overlap_wgt( 1.0 * extra_chainbreak_weight );
-		core::Real quad_wgt( 1.0 * extra_chainbreak_weight );
-		tr.Info << "no chainbreaks specified in  " << cen_score_patch() << ",..."
-						<< " set chainbreaks to " << lin_wgt << " and "
-						<< overlap_wgt <<" for linear- and overlap-chainbreak, respectively" << std::endl;
-		scorefxn->set_weight( scoring::chainbreak, quad_wgt );
-		scorefxn->set_weight( scoring::linear_chainbreak, lin_wgt );
-		scorefxn->set_weight( scoring::overlap_chainbreak, overlap_wgt );
-	}
-	set_scorefxn( scorefxn );
-
-	tr.Trace << "pool scorefxn as set to EvaluatedArchive: " << std::endl;
-	scorefxn->show( tr.Trace );
-
-	// --- setup pool-evaluation
-	if ( evaluate_local() ) {
-		set_weight( "score", 1.0 );
-	} else {
-		set_weight( "score", 0.0 ); //don't use score that comes back --- but the score_final thing
-		set_weight( "score_final", 1.0 );
-
-		super_quick_relax_of_centroids_ = option[ iterative::centroid_quickrelax ]();
-
-		if ( noesy_assign::NoesyModule::cmdline_options_activated() ) {
-			set_weight( "noesy_autoassign_cst", option[ iterative::cenpool_noesy_cst_weight ]() );
-			super_quick_relax_of_centroids_=true;
-
-			std::ostringstream hash_string;
-			hash_string << "NO_POOL " << std::endl;
-			noesy_assign_hash_ = hasher( hash_string.str() );
-
-			current_noesy_sampling_file_ = option[ iterative::initial_noe_auto_assign_csts ]();
-			using utility::file::file_exists;
-				if ( !file_exists( current_noesy_sampling_file_ ) ) {
-				utility_exit_with_message( "couldn't find initial NOESY-autoassign file "+current_noesy_sampling_file_ );
-			}
-		} // NoesyAssign
-
-		mem_tr << "setup evaluators" << std::endl;
-
-		if ( option[ iterative::cenpool_chemicalshift_weight ].user() ) {
-			chemshift_column_ = option[ iterative::chemicalshift_column ]();
-			set_weight( option[ iterative::chemicalshift_column ](), option[ iterative::cenpool_chemicalshift_weight ]() );
-			super_quick_relax_of_centroids_=true;
-			//this will make constraints probably invisible...
-			if ( option[ constraints::cst_file ].user() || option[ constraints::cst_fa_file ].user() ) set_weight( "filter_constraints", 5.0 );
-		}
-		if ( super_quick_relax_of_centroids_ ) {
-			set_weight( "prefa_centroid_score", option[ iterative::centroid_before_quickrelax_weight ]() );
-			set_weight( "score_fa", option[ iterative::fullatom_after_quickrelax_weight ]() );
-		}
-
-	}
-	//OBSOLET	add_evaluation( new evaluation::JumpNrEvaluator );
-	//OBSOLET	set_weight( "nrjump_weighted_chainbreaks", option[ iterative::chainbreak_evaluator_weight ] );
+	set_name( name_in );
 
-	// --- setup stage-steering parameters
+// --- setup stage-steering parameters
 	// maximum of sampled structures per stage
 	max_nstruct_list_ = option[ iterative::max_nstruct ]();
 	if ( max_nstruct_list_.size() != ( FINISHED-1 ) ) {
@@ -398,10 +422,14 @@ IterativeBase::IterativeBase(std::string
 		mem_tr << "setup native pose" << std::endl;
 	}
 
-
 	/// --- setup sequence
 	if ( option[ in::file::fasta ].user() ) {
 		target_sequence_ = core::sequence::read_fasta_file( option[ in::file::fasta ]()[1] )[1]->sequence();
+		if ( reference_pose_ ) {
+			if ( reference_pose_->sequence()!=target_sequence_ ) {
+				utility_exit_with_message("target sequence and sequence of native pose -in:file:native are inconsistent! ");
+			}
+		}
 	} else {
 		if ( reference_pose_ ) {
 			target_sequence_ = reference_pose_->sequence();
@@ -414,31 +442,73 @@ IterativeBase::IterativeBase(std::string
 		if ( reference_pose_ ) reference_pose_->dump_pdb("reference_pose_in_IterativeBase.pdb");
 		tr.Trace << "target_sequence_:\n " << target_sequence_ << std::endl;
 	}
+}
 
-	/// determine if we have enough strands to do jumping...
-	using namespace core::fragment;
-	FragSetOP frags_s = FragmentIO( option[ OptionKeys::abinitio::number_3mer_frags ]()	).read_data( option[ in::file::frag3 ] );
-	core::fragment::SecondaryStructure ss_def( *frags_s, true /*no JustUseCentralResidue */ );
-	Size ct_E( 0 );
-	for ( Size i=1; i<=ss_def.total_residue(); ++i ) {
-		if ( ss_def.strand_fraction( i ) > 0.7 ) ++ct_E;
-	}
-	mem_tr << "fragments loaded for ss-prediction" << std::endl;
-	//less than 15% strands and less than 40 residues in total and we skip jumping...
-	bDoBetaJumping_ = true;
-	if ( (ct_E*1.0)/(ss_def.total_residue()*1.0) < 0.15 && ct_E < 40 ) {
-		tr.Info << "skip beta-jumping since mostly alpha-helical protein" << std::endl;
-		tr.Info << "only " << (ct_E*1.0)/(ss_def.total_residue()*1.0)*100 << "% of residues display significant strand-character" << std::endl;
-		bDoBetaJumping_ = false;
+void IterativeBase::initialize() {
+	Parent::initialize();
+	// --- setup scorefxn
+	core::scoring::ScoreFunctionOP scorefxn =
+		core::scoring::ScoreFunctionFactory::create_score_function( cen_score(), cen_score_patch() );
+	tr.Info << "create Archive Scorefunction with: "
+					<<  option[ iterative::cen_score]() << " "
+					<<  option[ iterative::cen_score_patch ]() << std::endl;
+
+	mem_tr << "setup cen-scorefxn" << std::endl;
+
+	//manually set the chainbreaks if user has forgotten to specify them ...
+	fix_chainbreak_patch( scorefxn, cen_score_patch() );
+
+	set_scorefxn( scorefxn );
+
+	// --- setup pool-evaluation
+	if ( evaluate_local() ) {
+		set_weight( "score", 1.0 );
+		//setup constraint-evaluation for filter-cst from the ConstraintClaimers ( -broker:setup )
+	///@brief set scorefxn used for evaluation
+		set_weight( "atom_pair_constraint", 0 ); //this is now done via FILTER mechanism of ConstraintClaimer only !
+		set_overall_cstfilter_weight( scorefxn->get_weight( scoring::atom_pair_constraint ) );
+		setup_filter_cst( overall_cstfilter_weight() );
+		scorefxn->set_weight( scoring::atom_pair_constraint, 0 );
+
+		//		set_weight( "prefa_clean_score3", option[ iterative::centroid_before_quickrelax_weight ]() );
+		add_evaluation( new simple_filters::RDC_Evaluator("rdc"), scorefxn->get_weight( scoring::rdc ) );
+		scorefxn->set_weight( scoring::rdc, 0 );
+
+		set_scorefxn( scorefxn );
+	} else {
+		set_weight( "score", 0.0 ); //don't use score that comes back --- but the score_final thing
+		set_weight( "score_final", 1.0 );
 	}
-	if ( !bDoBetaJumping_ && option[ OptionKeys::iterative::force_topology_resampling ]() ) {
-		tr.Info << "force-topology-resampling despite low beta-sheet content due to flag -force_topology_resampling" << std::endl;
-		bDoBetaJumping_ = true;
+
+	//will setup autoNOE module if cmd-line options activated -- might set super_quick_relax_of_centroids_ to true.
+	setup_autoNOE();
+
+	// setup chemical shift rescoring -- this is done on worker side, here we pick up the column and give it a weight
+	if ( option[ iterative::cenpool_chemicalshift_weight ].user() ) {
+		chemshift_column_ = option[ iterative::chemicalshift_column ]();
+		set_weight( option[ iterative::chemicalshift_column ](), option[ iterative::cenpool_chemicalshift_weight ]() );
+		super_quick_relax_of_centroids_=true;
 	}
+
+	bDoBetaJumping_ = decide_on_beta_jumping_from_frags();
 	if ( !bDoBetaJumping_ ) {
 		stage_ = PURE_TOPO_RESAMPLING;
 	}
 
+	//if we use super-quick-relax mode setup appropriate score-evaluation
+	//and put a 0-Scorefunction into the Archive (as the scores are computed on worker side)
+	//keep this at end of constructor since other setup-routines can change this boolean value
+	if ( super_quick_relax_of_centroids_ ) {
+		set_weight( "prefa_clean_score3", option[ iterative::centroid_before_quickrelax_weight ]() );
+		set_weight( "score_fa", option[ iterative::fullatom_after_quickrelax_weight ]() );
+
+		// --- setup scorefxn a NULL scorefxn since we cannot evaluate a centroid score anymore (could do that by changing residue_type_set...)
+		core::scoring::ScoreFunctionOP scorefxn = new core::scoring::ScoreFunction;
+		set_scorefxn( scorefxn );
+		set_weight( "score", 0 );
+	}
+
+	//start stage-end controller
 	test_for_stage_end();
 
 	mem_tr << "IterativeBase CStor-End" << std::endl;
@@ -455,9 +525,29 @@ IterativeBase::~IterativeBase() {}
 // 	return false;
 // }
 
+void IterativeBase::idle() {
+	if ( last_accepted_decoys_in_idle_ < ( accepts_since_last_batch() + total_accepts() - decoys().size()/2 ) ) {
+		basic::show_time( tr,  "compute_cores/rescore: start..." );
+		last_accepted_decoys_in_idle_ = accepts_since_last_batch() + total_accepts();
+		compute_cores();
+		rescore();
+		basic::show_time( tr,  "compute_cores/rescore: done..." );
+		//if we take out the compute_cores() we should still trigger a rescore() to get the new score-variations...
+	}
 
-
-
+	//if we are in remote-evaluation mode we want to switch the noesy-filter restraints once after stage3
+	if ( !evaluate_local()
+		&& stage_ >= STAGE2_RESAMPLING
+		&& noesy_assign::NoesyModule::cmdline_options_activated()
+		&& !never_switched_noe_filter_
+		&& decoys().begin() != decoys().end()
+	) {
+		basic::show_time( tr,  "non-local scoring replace noesy_filter constraints: start..." );
+		never_switched_noe_filter_=true;
+		replace_noesy_filter_constraints();
+		basic::show_time( tr,  "non-local scoring replace noesy_filter constraints: done! ");
+	}
+}
 ///  ----------------- stage control ----------------------
 // ---> outsource to extra class ?  --- might be reused by other protocols
 ///@brief batch is expired ?
@@ -465,10 +555,12 @@ bool IterativeBase::still_interested( Ba
 	return Parent::still_interested( batch ) && batch.id() >= first_batch_this_stage_;
 }
 
-
+//after reading new structures we test for energy-saturation
 void IterativeBase::read_structures( core::io::silent::SilentFileData& sfd, Batch const& batch ) {
+	basic::show_time( tr,  "read structures into "+name()+"..." );
 	Parent::read_structures( sfd, batch );
 	test_for_stage_end();
+	basic::show_time( tr,  "done reading into "+name() );
 }
 
 ///@brief are we ready to switch to next stage ?
@@ -481,7 +573,6 @@ void IterativeBase::test_for_stage_end()
 					<< proposed_since_last_batch() << " proposed decoys since last batch "
 					<< std::endl;
 
-
 	int last_stage_N( 0 );
 	if ( stage_ > 1 ) last_stage_N = max_nstruct_list_[ stage_ - 1 ];
 	if ( max_nstruct_list_[ stage_ ] && ( (int) total_proposed() - last_stage_N ) > max_nstruct_list_[ stage_ ] ) {
@@ -507,6 +598,7 @@ void IterativeBase::increment_stage() {
 	stage_ = IterationStage( 1 + (int) stage_ );
 	while ( max_nstruct_list_[ stage_ ] < 0 && stage_ < finish_stage_ ) {
 		stage_ = IterationStage( 1 + (int) stage_ );
+		if ( !bDoBetaJumping_ && stage_ == NOESY_PHASEII_TOPO ) stage_ = IterationStage( 1 + (int) stage_ );
 	}
 	if ( !manager_ptr() ) {
 		tr.Info << "start with stage " << stage_ << std::endl;
@@ -558,12 +650,31 @@ bool IterativeBase::add_structure( core:
 			//                    might be that we have swapped away the original structure
 			return Parent::add_evaluated_structure( evaluated_decoy );
 		}
+
 		//improved score ?
-		if ( it != decoys().end() && select_score( evaluated_decoy ) < select_score( *it ) ) {
-			tr.Debug << "swap " << evaluated_decoy->decoy_tag() << " for " << (*it)->decoy_tag() << std::endl;
-			decoys().erase( it );
-			return Parent::add_evaluated_structure( evaluated_decoy );
-		}
+		if ( it != decoys().end() ) {
+			core::Real const new_score=select_score( evaluated_decoy );
+			core::Real const old_score=select_score( *it );
+			core::Real const check_score=(*it)->get_energy( "_archive_select_score_" );
+			if ( new_score < old_score ) {
+				core::Real const min_score=select_score( decoys().front() );
+				core::Real const max_score=select_score( decoys().back() );
+				core::Real const delta_max=max_score-min_score;
+				core::Real const delta_score=new_score-old_score;
+				tr.Debug << "swap " << evaluated_decoy->decoy_tag() << " for " << (*it)->decoy_tag()
+								 << " new-score " << new_score << " check: " << check_score
+								 << " score-improvement: " << delta_score
+								 << " at spread of " << delta_max
+								 << " ratio " << delta_score/delta_max << std::endl;
+				if ( delta_score/delta_max < -0.05 ) {
+					decoys().erase( it );
+					return Parent::add_evaluated_structure( evaluated_decoy );
+				} else {
+					tr.Debug << "swap declined because score-improvement below 5% of total spread" << std::endl;
+					return false;
+				}
+			} // new_score < old_score
+		}//improve score block
 
 		tr.Trace << "decoy " << evaluated_decoy->decoy_tag() << " with original tag " << evaluated_decoy->get_comment( "tag_in_file" )
 						 << " declined because of min_diversity: rmsd is " << rmsd_to_pool
@@ -583,12 +694,12 @@ bool IterativeBase::add_structure( core:
 ///    (maybe need to put a safeguard in here: ratio small but at least XXX decoys proposed since last batch... )
 ///
 void IterativeBase::generate_batch() {
-	cluster();
-
+	//OBSOLET	cluster();
+	basic::show_time( tr,  "generate_batch" );
+	//initialize batch
 	mem_tr << "IterativeBase::start_new_batch " << std::endl;
 	Batch& batch( manager().start_new_batch() );
 	mem_tr << "IterativeBase::generate_batch " << stage_ << " " << batch.batch() << std::endl;
-
 	tr.Info << "\ngenerate batch from " <<name() << " " << batch.batch() << std::endl;
 
 	//want intermediate structures from abinitio runs
@@ -601,36 +712,42 @@ void IterativeBase::generate_batch() {
 	if ( (int) stage_ < (int) PURE_TOPO_RESAMPLING ) gen_enumerate_pairings( batch );
 
 	// beta-sheet-topologies
-	if ( stage_ == TOPO_RESAMPLING || stage_ == PURE_TOPO_RESAMPLING ) gen_resample_topologies( batch );
-
-	if ( (int) stage_ < (int) STAGE2_RESAMPLING && option[ iterative::fix_core ].user() ) {
-		gen_start_structures( batch );
-	}
+	if ( stage_ == TOPO_RESAMPLING || stage_ == PURE_TOPO_RESAMPLING || stage_ == NOESY_PHASEII_TOPO ) gen_resample_topologies( batch );
 
 	// reuse fragments and restart from stage2 structures
-	if ( stage_ == STAGE2_RESAMPLING ) {
+	if ( stage_ == STAGE2_RESAMPLING || stage_ == NOESY_PHASEII_S2_RESAMPLING ) {
 		gen_resample_stage2( batch );
+	}
+
+	if ( stage_ >= STAGE2_RESAMPLING ) {
 		gen_resample_fragments( batch );
 	}
+
 	bool result_is_fullatom = false;
 	// close loops - fullatom relax
 	if ( stage_ == CEN2FULLATOM ) {
 		gen_cen2fullatom( batch );
-		gen_resample_fragments( batch );
+		//	gen_resample_fragments( batch );
 		batch.set_intermediate_structs( false ); //otherwise the intermediate (centroid) structures will be scored by score_13_envhb
 		result_is_fullatom = true;
 	}
 	mem_tr.Debug << "before evaluation output" << std::endl;
 	//finalize batch
 	gen_evaluation_output( batch, result_is_fullatom );
+	gen_dynamic_patches( batch );
 	mem_tr.Debug << "evaluation output" << std::endl;
 
+	basic::show_time( tr,  "finalize batch..." );
 	test_broker_settings( batch );
 	manager().finalize_batch( batch );
+	basic::show_time( tr,  "finalized batch" );
 
 
 	//add extra batch if we have "safety_hatch"
-	if ( stage_ == CEN2FULLATOM && option [ iterative::safety_hatch_scorecut ].user() ) {
+	///SWITCHED THIS OFF TEMPORARILY !!!
+	std::cerr << "saftey hatch is switched off due to maintainence reasons" << std::endl;
+	if ( stage_ == CEN2FULLATOM && false && option [ iterative::safety_hatch_scorecut ].user() ) {
+		basic::show_time( tr,  "generate safety_hatch" );
 		mem_tr.Debug << "make safety hatch..." << std::endl;
 		Batch& harvest_batch( manager().start_new_batch() );
 		tr.Info << "starting harvest batch at same time as normal cen2fullatom batch" << std::endl;
@@ -641,9 +758,11 @@ void IterativeBase::generate_batch() {
 
 		harvest_batch.set_intermediate_structs( false ); //otherwise the intermediate (centroid) structures will be scored by score_13_envhb
 		gen_evaluation_output( harvest_batch, true /*fullatom*/ );
-
+		gen_dynamic_patches( batch );
+		basic::show_time( tr,  "finalize safety_hatch... ");
 		test_broker_settings( batch );
 		manager().finalize_batch( harvest_batch );
+		basic::show_time( tr,  "finalized safety_hatch" );
 	}
 
 	tr.Info << std::endl;
@@ -652,15 +771,6 @@ void IterativeBase::generate_batch() {
 	mem_tr << "IterativeBase::generated_batch " << std::endl;
 	//now it is best time to do this... JobQueue is definitely filled up....
 	reassign_noesy_data( batch );
-
-
-}
-
-void IterativeBase::idle() {
-	if ( last_accepted_decoys_in_idle_ != ( accepts_since_last_batch() + total_accepts() ) ) {
-		last_accepted_decoys_in_idle_ = accepts_since_last_batch() + total_accepts();
-		compute_cores();
-	}
 }
 
 /// ============================================================================
@@ -669,28 +779,99 @@ void IterativeBase::idle() {
 /// ============================================================================
 
 
+void IterativeBase::do_dynamic_patching( jd2::archive::Batch& batch, utility::io::ozstream& flags, std::string score, utility::options::FileVectorOptionKey const& key ) const {
+	if ( ! option[ key ].user() ) return; //if this wasn't patched it doesn't require dynamic balancing...
+
+	core::Real var_score(0); //can't change score so keep this as reference
+	if ( get_weight("score")>0.001 ) {
+		var_score = score_variation("score");
+	} else if ( get_weight("prefa_clean_score3") > 0.001 ) {
+		var_score = score_variation("prefa_clean_score3");
+	} else {
+		runtime_assert(false); //should find either score or prefa_clean_score3
+	}
+
+	typedef std::map< scoring::ScoreType, std::string > ScoreTypeMap;
+	ScoreTypeMap dynamic_scores;
+	dynamic_scores[ scoring::rdc ] ="rdc";
+	dynamic_scores[ scoring::atom_pair_constraint ] ="atom_pair_constraint";
+
+	//get patched scorefxn
+	scoring::ScoreFunctionOP scorefxn  = scoring::ScoreFunctionFactory::create_score_function( score, option[ key ]()[1] );
+	std::ostringstream patches;
+	bool have_patch( false );
+	for ( ScoreTypeMap::const_iterator it = dynamic_scores.begin(); it != dynamic_scores.end(); ++it ) {
+		if ( scorefxn->get_weight( it->first ) > 0.00001 ) {
+			core::Real var_rel;
+			if ( it->second == "atom_pair_constraint" ) {
+				core::Real var_sum( 0 ); core::Size ct_cst( 0 );
+				WeightMap const& variations( score_variations() );
+				for ( WeightMap::const_iterator vit = variations.begin(); vit != variations.end(); ++vit ) {
+					if ( vit->first.find( "filter_cst" ) != std::string::npos ) {
+						var_sum += vit->second;
+						++ct_cst;
+					}
+				}
+				runtime_assert( ct_cst );
+				var_sum /= ct_cst;
+				var_rel=var_sum/var_score;
+			} else { //not a atom_pair_constraint
+				var_rel=score_variation( it->second );
+				var_rel/=var_score;
+			}
+			core::Real patch = scorefxn->get_weight( it->first )/var_rel;
+			patches << it->second << " = " << patch << std::endl;
+			have_patch = true;
+		} //has positive weight in patched scorefunction
+	}
+	if ( have_patch ) {
+		std::string patch_file ( batch.dir()+"/dynamic_abinitio_"+score+".patch" );
+		utility::io::ozstream patch_fd( patch_file );
+		patch_fd << patches.str() << std::endl;
+		tr.Info << "dynamic patching: write to flag-file " << key.id() << " " << patch_file << std::endl;
+		flags << "-" << key.id() << " " << patch_file << std::endl;
+		//		std::cerr << "dynamic patching for " << key.id() << std::endl;
+	}
+}
+
+void IterativeBase::gen_dynamic_patches( jd2::archive::Batch& batch ) {
+	if ( !use_dynamic_weights_for_sampling_ ) return;
+
+	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+	do_dynamic_patching( batch, flags, "score0",  OptionKeys::abinitio::stage1_patch  );
+	do_dynamic_patching( batch, flags, "score1",  OptionKeys::abinitio::stage2_patch  );
+	do_dynamic_patching( batch, flags, "score2",  OptionKeys::abinitio::stage3a_patch  );
+	do_dynamic_patching( batch, flags, "score5",  OptionKeys::abinitio::stage3b_patch  );
+	do_dynamic_patching( batch, flags, "score3",  OptionKeys::abinitio::stage4_patch  );
+	do_dynamic_patching( batch, flags, "score12", OptionKeys::score::patch  );
+}
+
+
 void IterativeBase::gen_evaluation_output( Batch& batch, bool fullatom ) {
 	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
 	flags << "-evaluation:jump_nr" << std::endl; //add JumpNrEvaluator
 
 	//add score evaluator
 	if ( !fullatom && !super_quick_relax_of_centroids_ ) { //centroid
+		// the standard 'score_final' score column
 		flags << "-evaluation:extra_score " << option[ iterative::cen_score]() << std::endl
 					<< "-evaluation:extra_score_column _final" << std::endl;
 		flags << "-evaluation:extra_score_patch " << option[ iterative::cen_score_patch ]() << std::endl;
 	} else { //fullatom
 		if ( super_quick_relax_of_centroids_ ) {
+			//obtain 'empty' score for 'score_final' and put normal fullatom score into 'score_fa'
 			flags << "-evaluation:extra_score " << "empty " << option[ iterative::fa_score]() << std::endl
 						<< "-evaluation:extra_score_column _final _fa" << std::endl;
 			flags << "-evaluation:extra_score_patch " << option[ iterative::fa_score_patch ]() << " NOPATCH " << std::endl;
 		} else {
+			//score-final standard fullatom mode
 			flags << "-evaluation:extra_score " << option[ iterative::fa_score]() << std::endl
 						<< "-evaluation:extra_score_column _final" << std::endl;
 			flags << "-evaluation:extra_score_patch " << option[ iterative::fa_score_patch ]() << std::endl;
 		}
 	}
 
-
+	//setup relax sequence protocol for super-quick relax
 	if ( super_quick_relax_of_centroids_ ) {
 		if ( !fullatom ) {
 			if ( option[ iterative::super_quick_relax_protocol ].user() ) {
@@ -709,25 +890,9 @@ void IterativeBase::gen_evaluation_outpu
 		} else { //!fullatom
 			flags << "-out:user_tag fullatom" << std::endl;
 		}
-		if ( option[ constraints::cst_file ].user() && !option[ constraints::cst_fa_file ].user() ) {
-			flags << "-evaluation:constraints " << option[ constraints::cst_file ]()[1] << std::endl;
-			flags << "-evaluation:constraints_column " << "filter_constraints" << std::endl;
-		} else if ( option[ constraints::cst_fa_file ].user() ) {
-			flags << "-evaluation:constraints " << option[ constraints::cst_fa_file ]()[1] << std::endl;
-			flags << "-evaluation:constraints_column " << "filter_constraints" << std::endl;
-		}
-	}
-
-	//score only parts of the structure ?
-	if ( scored_core_initialized_ && scored_core_.nr_residues() > 30 ) { //hey if this is less something is seriously wrong and we ignore it.
-		flags << "-evaluation:extra_score_select " << batch.dir()+"/scored_core.rigid" ;
-		if ( super_quick_relax_of_centroids_ ) {
-			flags << " " << batch.dir()+"/scored_core.rigid" ;
-		}
-		flags << std::endl;
-		scored_core_.write_loops_to_file( batch.dir()+"/scored_core.rigid", "RIGID" );
-	}
+	} //end super-quick relax
 
+	//NOESY FILTER Restraints
 	if ( noesy_assign::NoesyModule::cmdline_options_activated() ) {
 		if ( first_noesy_cst_file_ == "n/a" ) {
 			if ( super_quick_relax_of_centroids_ ) {
@@ -740,49 +905,108 @@ void IterativeBase::gen_evaluation_outpu
 			first_noesy_fa_cst_file_ = current_noesy_sampling_file_+".filter";
 		}
 		flags << "-evaluation::constraints " << ( fullatom ? first_noesy_fa_cst_file_ : first_noesy_cst_file_ ) << std::endl;
-		flags << "-evaluation::constraints_column " << "noesy_autoassign_cst" << std::endl;
+		flags << "-evaluation::constraints_column " << ( evaluate_local() ? "noesy_autoassign_cst_worker" : "noesy_autoassign_cst" ) << std::endl;
 	}
 
 	//compute pool_convergence_XXX ?
 	if ( min_diversity_list_[ stage() ] > 0 ) {
-		if ( option[ iterative::copy_pool_for_convergence_check ]() ) {
-			io::silent::SilentFileData sfd;
-			for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
-				sfd.add_structure( *it ); //not a copy, only adds OP to sfd
-			}
-			sfd.write_all( batch.dir()+"/pool.in" );
-			if ( sfd.size() == 0 ) {
-				// write a pool anyway so that we have the tags in the returning structures and don't mess
-				// up the columns in the pool decoys.out file... not crucial but makes post-analysis with scripts easier.
-				utility::io::ozstream empty_pool_file( batch.dir()+"/pool.in" );
-				empty_pool_file << "REMARK no structure in pool " << std::endl;
-			}
-			flags << "-mc:known_structures " << batch.dir() << "/pool.in" << std::endl;
-		} else 	flags << "-mc:known_structures " << name() << "/decoys.out" << std::endl;
+
+		//copy pool to '<batch>/pool.in'
+		io::silent::SilentFileData sfd;
+		for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+			sfd.add_structure( *it ); //not a copy, only adds OP to sfd
+		}
+		sfd.write_all( batch.dir()+"/pool.in" );
+
+		//empty pool -- write empty file for score-column consistency
+		if ( sfd.size() == 0 ) {
+			// write a pool anyway so that we have the tags in the returning structures and don't mess
+			// up the columns in the pool decoys.out file... not crucial but makes post-analysis with scripts easier.
+			utility::io::ozstream empty_pool_file( batch.dir()+"/pool.in" );
+			empty_pool_file << "REMARK no structure in pool " << std::endl;
+		}
+
+		//setup flags for min-divergence-pool: ----------------
+
+		//common flags
+		flags << "-mc:known_structures " << batch.dir() << "/pool.in" << std::endl;
 		flags << "-mc:max_rmsd_against_known_structures " << std::max( 0.0, min_diversity_list_[ stage() ] - 0.25 ) << std::endl;
-	}
+
+		//exclude residues from RMSD that are flexible anyhow
+		if ( basic::options::option[ basic::options::OptionKeys::in::replonly_residues ].user() ) {
+			flags << "-mc:excluded_residues_from_rmsd ";
+			utility::vector1<Size> replonly_rsd = basic::options::option[ basic::options::OptionKeys::in::replonly_residues ]();
+			for ( utility::vector1<Size>::const_iterator it = replonly_rsd.begin(); it != replonly_rsd.end(); ++it ) {
+				flags << " "<< *it;
+			}
+			flags << std::endl;
+		}
+	} //setup of min-divergence pool
 
 } //gen_evaluation
 
 ///@brief in the comp. modelling protocol the topo-resampling stage might also contain a RigidChunkClaimer...
 /// provide start-structures for this as -in:file:silent
-void IterativeBase::gen_start_structures( Batch& batch ) {
+void IterativeBase::gen_start_structures( Batch& /*batch*/ ) {
+	// OBSOLETE
+// 	batch.set_has_silent_in();
+// 	io::silent::SilentFileData sfd;
+// 	for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+// 		sfd.add_structure( *it ); //not a copy, only adds OP to sfd
+// 	}
+// 	sfd.write_all( batch.silent_in() );
+
+// 	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+// 	broker << "\nUSE_INPUT_POSE\n" << std::endl;
+// 	broker << "CLAIMER RigidChunkClaimer" << std::endl
+// 				 << "REGION_FILE " << option[ iterative::fix_core ]() << std::endl
+// 				 << "END_CLAIMER" << std::endl;
+
+// 	//compute nstruct such that we get the usual amount of total structures
+// 	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*decoys().size() ) ) );
+}
+
+//creation of the random-ss samplign stage
+void IterativeBase::gen_enumerate_pairings( Batch& batch ) {
+
+	//after Naccept accepted structures stop doing the enumerated pairing.
+	//sounds OBSOLETE TO ME: if ( (int) total_accepts() > option[ iterative::enumerate::Naccept ]() ) return;
 
-	batch.set_has_silent_in();
-	io::silent::SilentFileData sfd;
-	for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
-		sfd.add_structure( *it ); //not a copy, only adds OP to sfd
+	//skip every second time (standard setting in flag-lib: Apr 2012)
+	if ( option[ iterative::enumerate::skip_half ]() && bEnumeratedLastTime_ ) {
+		bEnumeratedLastTime_ = false;
+		return;
 	}
-	sfd.write_all( batch.silent_in() );
+	bEnumeratedLastTime_ = true;
 
+	tr.Info << "enumerate pairings\n ";
 	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
-	broker << "\nUSE_INPUT_POSE\n" << std::endl;
-	broker << "CLAIMER RigidChunkClaimer" << std::endl
-				 << "REGION_FILE " << option[ iterative::fix_core ]() << std::endl
-				 << "END_CLAIMER" << std::endl;
+	runtime_assert( broker.good() );
 
-	//compute nstruct such that we get the usual amount of total structures
-	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*decoys().size() ) ) );
+	//look for an explicit broker file for enumeration stage...
+	if ( option[ iterative::enumerate::broker ].user() ) {
+		utility::io::izstream enum_broker( option[ iterative::enumerate::broker ]() );
+		if ( !enum_broker.good() ) throw ( utility::excn::EXCN_FileNotFound
+			( "-iterative::enumerate::broker: File "
+				+std::string( option[ iterative::enumerate::broker ]())+" not found! ") );
+		std::string line;
+		while ( getline( enum_broker, line ) ) broker << line << std::endl;
+	} else {
+		//no explicit enumerate file is given -- generate enumeration automatically from ss-content of fragments
+		std::string frag_ss_file( batch.dir() + "psipred_ss2.dat" );
+		std::string pairings_file( batch.dir() + "pairings_guess.dat" );
+
+		using namespace core::fragment;
+		FragSetOP frags_s = FragmentIO(
+																	 option[ OptionKeys::abinitio::number_3mer_frags ]()
+		).read_data( option[ in::file::frag3 ] );
+		guess_pairings_from_secondary_structure( *frags_s, pairings_file, frag_ss_file );
+		broker << "CLAIMER TemplateJumpClaimer\n"
+					 << "RANDOM_SHEETS 2\n"
+					 << "SS_INFO " << frag_ss_file << "\n"
+					 << "PAIRING_FILE " << pairings_file << "\n"
+					 << "END_CLAIMER" << std::endl;
+	} //else (not enumerate::broker)
 }
 
 ///@brief figure out beta-sheet topologies from pooled decoys and run with jumping
@@ -798,7 +1022,9 @@ void IterativeBase::gen_resample_topolog
 				 << "END_CLAIMER\n\n" << std::endl;
 	broker.close();
 
-	if ( option[ iterative::initial_beta_topology ].user() &&  option[ iterative::recompute_beta_Naccept ]() > (int) total_accepts() ) {
+	//read beta-topology from start file -fix_topol --- use this file for first recompute_beta_Naccept decoys
+	if ( option[ iterative::initial_beta_topology ].user() &&
+		(int) total_accepts() < option[ iterative::recompute_beta_Naccept ]() ) {
 		//copy file to batch.dir() + "beta.top"
 		std::string input( option[ iterative::initial_beta_topology ]() );
 
@@ -810,7 +1036,7 @@ void IterativeBase::gen_resample_topolog
 		} else {
 			utility_exit_with_message("topology_file "+input+" not found. supply file or remove option -iterative::initial_beta_topology");
 		}
-	} else {
+	} else { //generate beta-topology from decoys
 		PairingStatisticsOP beta_topol = compute_beta_topology();
 		utility::io::ozstream file( batch.dir() + "beta.top" );
 		file << *beta_topol << std::endl;
@@ -822,7 +1048,11 @@ void IterativeBase::gen_resample_stage2(
 	tr.Info << "resample_stage2 \n";
 	mem_tr << "IterativeBase::gen_resample_stage2 start" << std::endl;
 	SilentStructVector start_decoys;
+
+	//collect to decoys() the corresponding stage2 decoys and store in start_decoys
 	collect_alternative_decoys( decoys(), "decoys_stage2.out", start_decoys );
+
+
 // 	typedef std::map< std::string, utility::vector1< std::string > > SourceFiles;
 // 	typedef std::map< std::string, utility::vector1< core::io::silent::SilentStructOP > > AlternativeDecoys;
 
@@ -871,6 +1101,7 @@ void IterativeBase::gen_resample_stage2(
 // 	if ( start_decoys.size() != decoys().size() ) {
 // 		tr.Warning << "[WARNING] why do we have a different number of decoys in pool and start_decoys ? " << std::endl;
 // 	}
+
 	///write flags and broker-file
 	if ( start_decoys.size() ) {
 		numeric::random::random_permutation( start_decoys, RG ); //permute to get rid of high fluctuation in acceptance rate
@@ -882,7 +1113,7 @@ void IterativeBase::gen_resample_stage2(
 		}
 		sfd.write_all( batch.silent_in() );
 
-
+		//make broker file for RESTART calculations
 		utility::io::ozstream broker( batch.broker_file(), std::ios::app );
 		broker << "\nUSE_INPUT_POSE\n"
 					 << "CLAIMER StartStructClaimer\n"
@@ -891,7 +1122,7 @@ void IterativeBase::gen_resample_stage2(
 					 << "CLAIMER JumpClaimer\n"
 					 << "END_CLAIMER\n\n" << std::endl;
 
-
+		//skip stage 1
 		utility::io::ozstream flags( batch.flag_file(), std::ios::app );
 		flags << "-abinitio::skip_stages 1 " << std::endl;
 	} else {
@@ -903,41 +1134,6 @@ void IterativeBase::gen_resample_stage2(
 	mem_tr << "IterativeBase::gen_resample_stage2 end" << std::endl;
 }
 
-void IterativeBase::gen_enumerate_pairings( Batch& batch ) {
-	if ( option[ iterative::enumerate::Naccept ]() < (int) total_accepts() ) return;
-	if ( option[ iterative::enumerate::skip_half ]() && bEnumeratedLastTime_ ) {
-		bEnumeratedLastTime_ = false;
-		return;
-	}
-	tr.Info << "enumerate pairings\n ";
-	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
-	runtime_assert( broker.good() );
-
-	if ( option[ iterative::enumerate::broker ].user() ) {
-		utility::io::izstream enum_broker( option[ iterative::enumerate::broker ]() );
-		if ( !enum_broker.good() ) throw ( utility::excn::EXCN_FileNotFound
-			( "-iterative::enumerate::broker: File "
-				+std::string( option[ iterative::enumerate::broker ]())+" not found! ") );
-		std::string line;
-		while ( getline( enum_broker, line ) ) broker << line << std::endl;
-	} else { //no explicit enumerate file is given
-		std::string frag_ss_file( batch.dir() + "psipred_ss2.dat" );
-		std::string pairings_file( batch.dir() + "pairings_guess.dat" );
-
-		using namespace core::fragment;
-		FragSetOP frags_s = FragmentIO(
-																	 option[ OptionKeys::abinitio::number_3mer_frags ]()
-		).read_data( option[ in::file::frag3 ] );
-
-		guess_pairings_from_secondary_structure( *frags_s, pairings_file, frag_ss_file );
-		broker << "CLAIMER TemplateJumpClaimer\n"
-					 << "RANDOM_SHEETS 2\n"
-					 << "SS_INFO " << frag_ss_file << "\n"
-					 << "PAIRING_FILE " << pairings_file << "\n"
-					 << "END_CLAIMER" << std::endl;
-	} //if enumerate::broker
-	bEnumeratedLastTime_ = true;
-}
 
 void IterativeBase::gen_resample_fragments( Batch& batch ) {
 	using namespace core::fragment;
@@ -975,58 +1171,213 @@ void IterativeBase::gen_resample_fragmen
 				<< "-abinitio:number_3mer_frags 0" << std::endl
 				<< "-abinitio:number_9mer_frags 0" << std::endl;
 
-	bool rescore( false );
-	if ( stage_ >= STAGE2_RESAMPLING && !scored_core_initialized_
-		&& ( option[ OptionKeys::iterative::scored_ss_core ]() || option[ OptionKeys::iterative::force_scored_region ].user() ) ) {
-		if (  option[ OptionKeys::iterative::force_scored_region ].user() ) {
-			std::ifstream is( option[ OptionKeys::iterative::force_scored_region ]().name().c_str() );
-			
-			if (!is.good()) {
-				utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + option[ OptionKeys::iterative::force_scored_region ]().name() + "'" );
-			}
-			loops::LoopsFileIO loop_file_reader;
-			loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format( is, option[ OptionKeys::iterative::force_scored_region ](), false /*no strict checking */, "RIGID" );
-			scored_core_ = loops::Loops( loops );
-		} else {
-			tr.Debug << "use refined secondary structure information to select scored_core " << std::endl;
-			// obtain secondary structure from fragments
-			core::fragment::SecondaryStructure ss_def( frags_9mer, true /*no JustUseCentralResidue */ );
-			//	utility::vector1< bool > loop( ss_def.total_residue(),false );
-			loops::define_scorable_core_from_secondary_structure( ss_def, scored_core_ );
-		}
-		rescore = true;
-	}
-	if ( stage_ >= STAGE2_RESAMPLING && noesy_assign::NoesyModule::cmdline_options_activated() && !scored_core_initialized_ &&
-		decoys().begin() != decoys().end() && (batch.id() > 1 )) {
-		rescore = true;
-		pose::Pose pose;
-		(*decoys().begin())->fill_pose( pose );
-		if ( scored_core_.size() == 0 ) scored_core_.add_loop( 1, pose.total_residue() );
 
-		// due to lazy reassignment protocol this batch might not actually have a noesy-cst file when this it is started.
-		/// need to ggo one batch back...
+// 	OBSOLETE:
+//   bool rescore( false );
+// 	if ( stage_ >= STAGE2_RESAMPLING && !scored_core_initialized_
+// 		&& ( option[ OptionKeys::iterative::scored_ss_core ]() || option[ OptionKeys::iterative::force_scored_region ].user() ) ) {
+// 		if (  option[ OptionKeys::iterative::force_scored_region ].user() ) {
+// 			std::ifstream is( option[ OptionKeys::iterative::force_scored_region ]().name().c_str() );
 
-// 		if ( super_quick_relax_of_centroids_ ) {
-// 			first_noesy_cst_file_ = batch.dir() + "/"+NOESY_CST_FILE_NAME+".filter";
+// 			if (!is.good()) {
+// 				utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + option[ OptionKeys::iterative::force_scored_region ]().name() + "'" );
+// 			}
+// 			loops::LoopsFileIO loop_file_reader;
+// 			loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format( is, option[ OptionKeys::iterative::force_scored_region ](), false /*no strict checking */, "RIGID" );
+// 			scored_core_ = loops::Loops( loops );
 // 		} else {
-// 			first_noesy_cst_file_ = batch.dir()+"/"+NOESY_CST_FILE_NAME+".centroid.filter";
+// 			tr.Debug << "use refined secondary structure information to select scored_core " << std::endl;
+// 			// obtain secondary structure from fragments
+// 			core::fragment::SecondaryStructure ss_def( frags_9mer, true /*no JustUseCentralResidue */ );
+// 			//	utility::vector1< bool > loop( ss_def.total_residue(),false );
+// 			loops::define_scorable_core_from_secondary_structure( ss_def, scored_core_ );
 // 		}
-// 		bool const fullatom( pose.is_fullatom() );
-// 		if ( fullatom ) first_noesy_fa_cst_file_ = batch.dir()+"/"+NOESY_CST_FILE_NAME+".filter";
-		if ( super_quick_relax_of_centroids_ ) {
-			first_noesy_cst_file_ = current_noesy_sampling_file_+".filter";
-		} else {
-			first_noesy_cst_file_ = current_noesy_sampling_file_+".filter.centroid";
+// 		rescore = true;
+// 	}
+//	if ( rescore ) set_scored_core();
+	mem_tr << "IterativeBase::gen_resample_fragments end" << std::endl;
+}
+
+//generate ConstraintClaimer files for NOE restraints
+void IterativeBase::gen_noe_assignments( Batch& batch ) {
+	if ( !noesy_assign::NoesyModule::cmdline_options_activated() ) return;
+	bool bCombine( bCombineNoesyCst_ );
+	mem_tr << "IterativeBase::gen_noe_assignments start" << std::endl;
+
+
+	//if just started IterativeFullatom we are in a new instance and the first_noesy_cst_file and
+	// the current_noesy_sampling_file_ are not set .. go through backward through past batches and take first (i.e., youngest) file.
+	if ( batch.id() > 1 && stage() > CEN2FULLATOM && first_noesy_cst_file_ == "n/a"  ) {
+		for ( Size back = batch.id() - 1; back >= 1; --back ) {
+			Batch last_batch( back );
+			runtime_assert( last_batch.id() < batch.id() );
+			current_noesy_sampling_file_ = last_batch.dir()+"/"+NOESY_CST_FILE_NAME;
+			if ( utility::file::file_exists( current_noesy_sampling_file_ ) ) break;
+			current_noesy_sampling_file_ = option[ iterative::initial_noe_auto_assign_csts ]();
 		}
-		bool const fullatom( pose.is_fullatom() );
-		if ( fullatom ) first_noesy_fa_cst_file_ = current_noesy_sampling_file_+".filter";
+		first_noesy_fa_cst_file_ = current_noesy_sampling_file_+".filter";
+	}
+
+	//
+	std::string cst_file( current_noesy_sampling_file_ );
+	std::string cst_centroid_file( cst_file + ".centroid");
+
+	//make broker files with FULL-ATOM and CENTROID CLaimers
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	if ( stage() >= CEN2FULLATOM ) { //don't add constraints in early stages... slows down super-quick relax to much...
+		broker << "\nCLAIMER ConstraintClaimer \n"
+					 << "CST_FILE " << cst_file << "\n"
+					 << "NO_CENTROID\n"
+					 << "FULLATOM\n"
+					 << "SKIP_REDUNDANT "<<option[ iterative::skip_redundant_constraints ]() << "\n";
+		if ( bCombine ) broker << "COMBINE_RATIO " << basic::options::option[ basic::options::OptionKeys::constraints::combine ]() << "\n";
+		broker << "END_CLAIMER\n" << std::endl;
+	}
+
+	broker << "\nCLAIMER ConstraintClaimer \n"
+				 << "CST_FILE " << cst_centroid_file << "\n"
+				 << "CENTROID\n"
+				 << "SKIP_REDUNDANT "<<option[ iterative::skip_redundant_constraints ]() << "\n";
+	if ( bCombine ) broker << "COMBINE_RATIO " << basic::options::option[ basic::options::OptionKeys::constraints::combine ]() << "\n";
+	broker << "END_CLAIMER\n" << std::endl;
+
+	mem_tr << "IterativeBase::gen_noe_assignments end" << std::endl;
+}
+
+
+void IterativeBase::gen_cen2fullatom( Batch& batch ) {
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	broker << "\nUSE_INPUT_POSE\n"
+				 << "CLAIMER StartStructClaimer\n"
+				 << "END_CLAIMER\n\n"
+				 << "CLAIMER JumpClaimer\n"
+				 << "END_CLAIMER\n\n" << std::endl;
+
+
+	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+	flags << "-abinitio::skip_stages 1 2 3 4" << std::endl;
 
+	add_fullatom_flags( batch );
+	io::silent::SilentStructOPs start_decoys;
+	std::copy( decoys().begin(), decoys().end(), std::back_inserter( start_decoys ) );
 
+	if ( start_decoys.size() ) {
+		batch.set_has_silent_in();
+		core::io::silent::SilentFileData sfd;
+		for ( core::io::silent::SilentStructOPs::const_iterator
+						it = start_decoys.begin(); it != start_decoys.end(); ++it ) {
+			sfd.add_structure( **it );
+		}
+		sfd.write_all( batch.silent_in() );
 	}
-	if ( rescore ) set_scored_core();
-	mem_tr << "IterativeBase::gen_resample_fragments end" << std::endl;
+
+	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*start_decoys.size() ) ) );
+
+}
+
+void IterativeBase::gen_cen2fullatom_non_pool_decoys( Batch& batch ) {
+	using namespace core::io::silent;
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	broker << "\nUSE_INPUT_POSE\n"
+				 << "CLAIMER StartStructClaimer\n"
+				 << "END_CLAIMER\n\n"
+				 << "CLAIMER JumpClaimer\n"
+				 << "END_CLAIMER\n\n" << std::endl;
+
+
+	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+	flags << "-abinitio::skip_stages 1 2 3 4" << std::endl;
+	add_fullatom_flags( batch );
+
+	//count total decoys
+	Size total( 0 );
+	for ( ArchiveManager::BatchList::const_iterator it = manager().batches().begin(); it != manager().batches().end(); ++it ) {
+		if ( it->id() >= first_fullatom_batch_ ) break;
+		if ( !it->has_silent_in() ) continue;
+		total += it->decoys_returned();
+		tr.Debug << "harvest old decoys for safety hatch: batch " << it->id() << " " << it->decoys_returned() << " " << total << std::endl;
+	}
+
+	basic::show_time( tr,  "generate safety_hatch: counted total decoys" );
+
+	Real score_cut_per_batch( option[ OptionKeys::iterative::safety_hatch_scorecut ] );
+	//now go thru batches and select percentage_per_batch structures randomly from the pool created by score_cut_per_batch...
+	//use score_final for this ? or can we use EvaluatedArchive methods to get a reasonable score ???
+	//ACHTUNG:  need also to know final centroid batch id...
+	SilentStructOPs start_decoys;
+	for ( ArchiveManager::BatchList::const_iterator it = manager().batches().begin(); it != manager().batches().end(); ++it ) {
+		Real percentage_per_batch( 1.0*batch.nstruct() / (1.0*total) );
+		if ( it->id() >= first_fullatom_batch_ ) break;
+		if ( !it->has_silent_in() ) continue; //usually only the resampling decoys are interesting...
+		if ( !it->decoys_returned() ) continue; //avoid looking for empty files
+		//		it->silent_out();
+		basic::show_time( tr,  "generate safety_hatch: access batch "+it->batch() );
+		SilentFileData sfd;
+			std::list< std::pair< core::Real, SilentStructOP > > score_cut_decoys;
+		Size ct( 0 );
+		tr.Debug << "read and score decoys in " << it->silent_out() << "..." << std::endl;
+		sfd.read_file( it->silent_out() );
+		for ( SilentFileData::iterator sit=sfd.begin(), esit=sfd.end(); sit!=esit; ++sit ) {
+			std::string tag = sit->decoy_tag();
+			sit->set_decoy_tag( "harvest_"+batch.batch()+"_"+ObjexxFCL::lead_zero_string_of( ++ct, 6 ) );
+
+			//note this does nothing but return *it, if b_evaluate_incoming_decoys_ is false
+			//Solve this by having another Archive that is once and only once filled with decoys from all relevant batches.
+			//This can already be done when the batches are being made. the only difference is that the rule for acceptance is different..
+			//the archive has no upper-size limit and always takes the bestX% of all structures.
+			//it has to be maintained with updates of evaluators and such together with the main-archive.
+			//but one could also choose to *not* update evaluators to have a more different (more hedging approach. )
+			//this should probably be renamed into hedging !!!
+			core::io::silent::SilentStructOP pss = *sit;//cannot afford this ever: evaluate_silent_struct( *sit );
+			score_cut_decoys.push_back( std::make_pair( select_score( pss ), pss ) );
+		}
+		score_cut_decoys.sort();
+		tr.Debug << "select " << percentage_per_batch*100 << "% from batch from the lowest scoring " << score_cut_per_batch*100 << "% of structures" << std::endl;
+		basic::show_time( tr,  "generate safety_hatch: collected decoys batch "+it->batch() );
+		// if we have less structures below score cut than what we want to harvest,.... take them all
+		while ( score_cut_per_batch < percentage_per_batch ) {
+			Size ind_max( static_cast< Size > ( score_cut_decoys.size()*score_cut_per_batch ) );
+			for ( std::list< std::pair< core::Real, core::io::silent::SilentStructOP > >::const_iterator sit = score_cut_decoys.begin();
+						sit != score_cut_decoys.end(); ++sit ) {
+				start_decoys.push_back( sit->second );
+				if ( --ind_max <= 1 ) break;
+			}
+			percentage_per_batch-=score_cut_per_batch;
+		}
+		basic::show_time( tr,  "generate safety_hatch: generated start_decoys batch "+it->batch());
+		// for the remaining structures we want to harvest, they clearly will be less than what the score-cut yields... choose randomly...
+		if ( percentage_per_batch > 0.01 ) {
+			Size ind_max( static_cast< Size > ( score_cut_decoys.size()*score_cut_per_batch ) );
+			for ( std::list< std::pair< core::Real, core::io::silent::SilentStructOP > >::const_iterator sit = score_cut_decoys.begin();
+						sit != score_cut_decoys.end(); ++sit ) {
+				if ( RG.uniform() < ( percentage_per_batch / score_cut_per_batch ) ) {
+					start_decoys.push_back( sit->second );
+				}
+				if ( --ind_max <= 1 ) break;
+			}
+		}
+	}
+	basic::show_time( tr,  "generate safety_hatch: done collecting");
+	if ( start_decoys.size() ) {
+		batch.set_has_silent_in();
+		core::io::silent::SilentFileData sfd;
+		Size ct( 0 );
+		for ( core::io::silent::SilentStructOPs::const_iterator
+						it = start_decoys.begin(); it != start_decoys.end(); ++it ) {
+			if ( ++ct > batch.nstruct() ) break;
+			sfd.add_structure( **it );
+		}
+		sfd.write_all( batch.silent_in() );
+	}
+	basic::show_time( tr,  "generate safety_hatch: done writing");
+	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*start_decoys.size() ) ) );
+
 }
 
+/// -----------------------------------------------------------------------------
+///         END gen_xxx ( batch ) methods
+/// ==============================================================================
+
 void IterativeBase::reassign_noesy_data( Batch& batch ) {
 	if ( !noesy_assign::NoesyModule::cmdline_options_activated() ) return;
 	if ( batch.id() == 1 || ( total_proposed() < (Size) option[ iterative::delay_noesy_reassign ]() ) ) return; //don't do this at very beginning
@@ -1039,52 +1390,43 @@ void IterativeBase::reassign_noesy_data(
 	Size const n_decoys( option[ iterative::limit_decoys_for_noe_assign ] );
 	std::ostringstream hash_string;
 	hash_string << "NO_POOL " << std::endl;
+
+	//get the calibration subset of decoys...
 	if ( decoys().size() < n_decoys && decoys().size() < nstruct() ) {
 		calibration_decoys = decoys();
 		hash_string << "ONLY "<< decoys().size() << std::endl;
 	} else {
-		//  this seems to help a little bit: double cut take 90 decoys by score and then the lowest 30 by cst-score
-		// not a big difference though...
-		// bullshit probably helped because of other bug
-		// 		typedef std::list< std::pair< core::Real, core::io::silent::SilentStructOP > > Sorted_decoys;
-		// 		Sorted_decoys cst_sorted_decoys;
-		// 		Size ct1( 1 );
-		// 		for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end() && ct1 <= 3*n_decoys; ++ct1, ++it ) {
-		// 			cst_sorted_decoys.push_back( std::make_pair( (*it)->get_energy( "noesy_autoassign_cst" ), *it ));
-		// 		}
-		// 		cst_sorted_decoys.sort();
-		// 		cst_sorted_decoys.reverse();
-
-		// 		Size ct2 ( 1 );
-		// 		for ( Sorted_decoys::const_iterator it = cst_sorted_decoys.begin(); it != cst_sorted_decoys.end() && ct2 <= n_decoys; ++ct2, ++it ) {
-		// 			calibration_decoys.push_back( it->second );
-		// 			hash_string << it->second->decoy_tag() << std::endl;
-		// 		}
-
 		Size ct2 ( 1 );
 		for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end() && ct2 <= n_decoys; ++ct2, ++it ) {
 			calibration_decoys.push_back( *it );
-			hash_string << (*it)->decoy_tag() << std::endl;
+			hash_string << (*it)->decoy_tag() << std::endl; //create hash-string out of decoy tags
 		}
 	}
 
+	//check if the low-energy decoy-tags have changed via their hash-string
 	size_t hash_val( hasher( hash_string.str() ) );
 	if ( hash_val == noesy_assign_hash_ ) {
 		tr.Info << "do not create new noesy assignment since low-energy structures have not changed..." << std::endl;
 		return; // don't do anything
 	}
-
 	noesy_assign_hash_ = hash_val;
 
+	//initialize noesy-module
 	if ( !noesy_module_ ) {
 		noesy_module_ = new protocols::noesy_assign::NoesyModule( target_sequence_ );
 	} else {
 		noesy_module_->reset();
 	}
 
+	//manipulate params if we have some "SCHEME"
 	noesy_assign::PeakAssignmentParameters& params( *noesy_assign::PeakAssignmentParameters::get_nonconst_instance() );
-
 	std::string scheme( option[ iterative::auto_assign_scheme ]() );
+	if ( stage() > STAGE2_RESAMPLING ) {
+		params.set_cycle( 7 );
+		params.use_local_distviol_ = true;
+		//params.calibrate= calibrate on converged regions only
+	}
+
 	if ( scheme == "CONST" ) {
 		tr.Info << " reassign NOESY data with cmd-line settings " << std::endl;
 		bCombineNoesyCst_ = stage() <= STAGE2_RESAMPLING;
@@ -1102,113 +1444,55 @@ void IterativeBase::reassign_noesy_data(
 	} else {
 		utility_exit_with_message("unknown auto_assign_scheme for NOESY data: choose ADAPT1 or CONST" + scheme);
 	}
-	//	if ( stage() < STAGE2_RESAMPLING ) {
+
+	//dump params on tracer and in README file
 	params.show_on_tracer();
 	{
 		utility::io::ozstream param_out( batch.dir()+"/README_noe_auto_assign", std::ios::app );
 		params.show( param_out );
 	}
 
-		// 	} else {
-		// 		Size cycle ( std::min( (Size) 7, (Size) std::ceil( noesy_assign_float_cycle_ ) ) );
-		// 		params.set_cycle( cycle );
-		// 		utility::io::ozstream cycle_file( batch.dir()+"/README_noe_auto_assign" );
-		// 		cycle_file << noesy_assign_float_cycle_ << " " << cycle;
-		// 		noesy_assign_float_cycle_ += 0.5;
-		// 	}
-
-
+	//assign corss-peaks using the calibration decoys
 	noesy_module_->assign(
 		utility::DereferenceIterator< SilentStructs >( calibration_decoys.begin() ),
 		utility::DereferenceIterator< SilentStructs >( calibration_decoys.end() )
 	);
 
-	core::pose::Pose aPose;
-	if ( reference_pose_ ) aPose = *reference_pose_;
-	else 	core::pose::make_pose_from_sequence(
+
+	//make constraints
+	core::pose::Pose aPose; 	//make a pose to make constraint-files
+	core::pose::make_pose_from_sequence(
 				aPose,
 				target_sequence_,
 				*( chemical::ChemicalManager::get_instance()->residue_type_set( core::chemical::FA_STANDARD ))
 	);
-
-	std::string cst_file( batch.dir()+"/"+NOESY_CST_FILE_NAME );
+	std::string cst_file( batch.dir()+"/"+NOESY_CST_FILE_NAME ); //cst-file names
 	std::string cst_centroid_file( cst_file + ".centroid");
-
-	noesy_module_->generate_constraint_files( aPose, cst_file, cst_centroid_file, 5 );
+	noesy_module_->generate_constraint_files( aPose, cst_file, cst_centroid_file, 5 ); //generate constraints
 	noesy_module_->generate_constraint_files( aPose, cst_file+".filter", cst_file+".filter.centroid", 2 );
 
+	//write NOE_out.dat
 	noesy_module_->write_assignments( batch.dir()+"/NOE_out.dat" );
 
+	//remember current cst-file
 	current_noesy_sampling_file_ = cst_file;
 
-	prof_show();
+	//switch out filter constraints --- if evaluate-local() otherwise we do this only once ( triggered from idle() )
+	if ( evaluate_local() ) { //change filter restraints if we are local-evaluators
+		topology_broker::ConstraintClaimerOP cst =
+			new topology_broker::ConstraintClaimer( current_noesy_sampling_file_+".filter", "noesy_autoassign_cst" );
+		cst->set_combine_ratio( bCombineNoesyCst_ ? 2 : 1 );
+		cst->set_fullatom( true );
+		cst->set_centroid( false );
+		cst->set_filter_weight( get_weight( "noesy_autoassign_cst" )/overall_cstfilter_weight_ );
+		add_evaluation( new topology_broker::ConstraintEvaluatorWrapper( cst->tag(), cst ), cst->filter_weight()*overall_cstfilter_weight_ );
+		rescore(); //rescore now, since we probably have more time now, when later when the decoys are arriving...
+	}
+	basic::prof_show();
 	mem_tr << "IterativeBase reassign_noesy_data end" << std::endl;
 }
 
 
-void IterativeBase::gen_noe_assignments( Batch& batch ) {
-	if ( !noesy_assign::NoesyModule::cmdline_options_activated() ) return;
-	bool bCombine( bCombineNoesyCst_ );
-	mem_tr << "IterativeBase::gen_noe_assignments start" << std::endl;
-
-	if ( batch.id() > 1 && stage() > CEN2FULLATOM && first_noesy_cst_file_ == "n/a"  ) {
-		//now we are in a new instance of IterativeBase... need to recover the state data
-		for ( Size back = batch.id() - 1; back >= 1; --back ) {
-			Batch last_batch( back );
-			runtime_assert( last_batch.id() < batch.id() );
-			current_noesy_sampling_file_ = last_batch.dir()+"/"+NOESY_CST_FILE_NAME;
-			if ( utility::file::file_exists( current_noesy_sampling_file_ ) ) break;
-			current_noesy_sampling_file_ = option[ iterative::initial_noe_auto_assign_csts ]();
-		}
-		first_noesy_fa_cst_file_ = current_noesy_sampling_file_+".filter";
-	}
-
-	std::string cst_file( current_noesy_sampling_file_ );
-	std::string cst_centroid_file( cst_file + ".centroid");
-
-	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
-	if ( stage() >= CEN2FULLATOM ) { //don't add constraints in early stages... slows down super-quick relax to much...
-		broker << "\nCLAIMER ConstraintClaimer \n"
-					 << "CST_FILE " << cst_file << "\n"
-					 << "NO_CENTROID\n"
-					 << "FULLATOM\n"
-					 << "SKIP_REDUNDANT "<<option[ iterative::skip_redundant_constraints ]() << "\n";
-		if ( bCombine ) broker << "COMBINE_RATIO " << basic::options::option[ basic::options::OptionKeys::constraints::combine ]() << "\n";
-
-		broker << "END_CLAIMER\n" << std::endl;
-	}
-
-	broker << "\nCLAIMER ConstraintClaimer \n"
-				 << "CST_FILE " << cst_centroid_file << "\n"
-				 << "CENTROID\n"
-				 << "SKIP_REDUNDANT "<<option[ iterative::skip_redundant_constraints ]() << "\n";
-		//NO: 			 << "FULLATOM\n"
-	if ( bCombine ) broker << "COMBINE_RATIO " << basic::options::option[ basic::options::OptionKeys::constraints::combine ]() << "\n";
-	broker << "END_CLAIMER\n" << std::endl;
-
-	//if we have "normal constraints" supply them in addition...
-	if ( option[ constraints::cst_file ].user() ) {
-		for ( Size i = 1; i<= option[ constraints::cst_file ]().size(); i++ ) {
-			std::string cst_file( option[ constraints::cst_file ]()[i] );
-			broker << "\nCLAIMER ConstraintClaimer \n"
-						 << "CST_FILE " << cst_file << "\n"
-						 << "CENTROID\n";
-			if ( !option[ constraints::cst_fa_file ].user() ) broker << "FULLATOM\n";
-			broker << "END_CLAIMER\n" << std::endl;
-		}
-	}
-	if ( option[ constraints::cst_fa_file ].user() ) {
-		for ( Size i = 1; i<= option[ constraints::cst_fa_file ]().size(); i++ ) {
-			std::string cst_file( option[ constraints::cst_fa_file ]()[i] );
-			broker << "\nCLAIMER ConstraintClaimer \n"
-						 << "CST_FILE " << cst_file << "\n"
-						 << "NO_CENTROID\n"
-						 << "FULLATOM\n"
-						 << "END_CLAIMER\n" << std::endl;
-		}
-	}
-	mem_tr << "IterativeBase::gen_noe_assignments end" << std::endl;
-}
 
 void IterativeBase::guess_pairings_from_secondary_structure(
 	core::fragment::FragSet const& frags,
@@ -1257,113 +1541,115 @@ void IterativeBase::guess_pairings_from_
 			}
 		}
 	}
-
 }
 
-void IterativeBase::set_scored_core() {
-
-	scored_core_initialized_ = true;
-	if ( evaluate_local() ) {
-		add_core_evaluator( scored_core_ , "_scored_core");
-		set_weight( "score", 0.0 );
-		set_weight( "score_scored_core", 1.0 );
-// 		remove_evaluation( "score_core4" );
-// 		remove_evaluation( "rms_core4" );
-
-// 		remove_evaluation( "score_core3" );
-// 		remove_evaluation( "rms_core3" );
 
-// 		remove_evaluation( "score_core2" );
-// 		remove_evaluation( "rms_core2" );
+//this is called for non-local evaluation to switch-out the filter restraints once after stage3.
+//this causes cancelling of batches and other shit, that is the reason why called rarely/once
+void IterativeBase::replace_noesy_filter_constraints() {
+
+	//are we full-atom ?
+	pose::Pose pose;
+	(*decoys().begin())->fill_pose( pose );
+	bool const fullatom( pose.is_fullatom() );
+	if ( fullatom ) first_noesy_fa_cst_file_ = current_noesy_sampling_file_+".filter";
 
+	if ( super_quick_relax_of_centroids_ ) {
+		first_noesy_cst_file_ = current_noesy_sampling_file_+".filter";
 	} else {
-		//cancel all running batches...
-		manager().cancel_batches_previous_to( manager().last_batch_id(), false /*don't allow reading of old decoys...*/ );
+		first_noesy_cst_file_ = current_noesy_sampling_file_+".filter.centroid";
+	}
 
-		//make sure that archive gets re-evaluated...
-		set_evaluate_local( true );//set this temporarily
+	// this needs work in EvaluatedArchive to make sure the right constraint files are used...
+	if ( noesy_assign::NoesyModule::cmdline_options_activated() ) {
+		std::string const cst_file( fullatom ? first_noesy_fa_cst_file_ : first_noesy_cst_file_ );
+		Real weight( get_weight( "noesy_autoassign_cst" )/overall_cstfilter_weight_ );
+		topology_broker::ConstraintClaimerOP cst =
+			new topology_broker::ConstraintClaimer( cst_file, "noesy_autoassign_cst" );
+		cst->set_combine_ratio( 2 );
+		cst->set_fullatom( true );
+		cst->set_centroid( false );
+		cst->set_filter_weight( weight );
+		add_evaluation( new topology_broker::ConstraintEvaluatorWrapper( cst->tag(), cst ), cst->filter_weight()*overall_cstfilter_weight_ );
+	}
+	rescore_nonlocal_archive();
+}
+
+//this is called for non-local evaluation to switch filter-restraints
+void IterativeBase::rescore_nonlocal_archive() {
+	if ( evaluate_local() ) return;
+
+	//cancel all running batches...
+	manager().cancel_batches_previous_to( manager().last_batch_id(), false /*don't allow reading of old decoys...*/ );
+
+	//make sure that archive gets re-evaluated...
+	set_evaluate_local( true );//set this temporarily
+
+	core::scoring::ScoreFunctionOP scfxn( NULL );
+	std::string score_name;
+	std::string score_patch;
+
+	//check fullatom:
+	core::pose::Pose a_pose;
+	(*decoys().begin())->fill_pose( a_pose );
+	bool const fullatom( a_pose.is_fullatom() );
+
+	if ( !fullatom ) {
+		score_name=option[ iterative::cen_score]();
+		score_patch=option[ iterative::cen_score_patch ]();
+	} else {
+		score_name=option[ iterative::fa_score ]();
+		score_patch=option[ iterative::fa_score_patch ]();
+	}
 
-		utility::vector1< Size> selection;
-		scored_core_.get_residues( selection );
+	if ( score_patch != "NOPATCH" ) {
+		scfxn = core::scoring::ScoreFunctionFactory::create_score_function( score_name, score_patch );
+	} else {
+		scfxn = core::scoring::ScoreFunctionFactory::create_score_function( score_name );
+	}
 
-		core::scoring::ScoreFunctionOP scfxn( NULL );
-		std::string score_name;
-		std::string score_patch;
-
-		//check fullatom:
-		core::pose::Pose a_pose;
-		(*decoys().begin())->fill_pose( a_pose );
-		bool const fullatom( a_pose.is_fullatom() );
+	bool chainbreaks_in_patch( scfxn->get_weight( scoring::linear_chainbreak ) > 0.0 );
+	core::Real extra_chainbreak_weight( basic::options::option[ basic::options::OptionKeys::jumps::increase_chainbreak ] );
+	if ( !chainbreaks_in_patch ) { //if chainbreak is not patched .. set it
+		core::Real lin_wgt( 4.0/3.0 * extra_chainbreak_weight );
+		core::Real overlap_wgt( 1.0 * extra_chainbreak_weight );
+		core::Real quad_wgt( 1.0 * extra_chainbreak_weight );
+		tr.Info << "no chainbreaks specified in  " << score_patch << ",..."
+						<< " set chainbreaks to " << lin_wgt << " and "
+						<< overlap_wgt <<" for linear- and overlap-chainbreak, respectively" << std::endl;
+		scfxn->set_weight( scoring::chainbreak, quad_wgt );
+		scfxn->set_weight( scoring::linear_chainbreak, lin_wgt );
+		scfxn->set_weight( scoring::overlap_chainbreak, overlap_wgt );
+	}
 
-		if ( !fullatom ) {
-			score_name=option[ iterative::cen_score]();
-			score_patch=option[ iterative::cen_score_patch ]();
-		} else {
-			score_name=option[ iterative::fa_score ]();
-			score_patch=option[ iterative::fa_score_patch ]();
-		}
+	if ( super_quick_relax_of_centroids_ && stage_ < CEN2FULLATOM) {
+		std::string score_patch=option[ iterative::fa_score_patch ]();
 		if ( score_patch != "NOPATCH" ) {
-			scfxn = core::scoring::ScoreFunctionFactory::create_score_function( score_name, score_patch );
+			scfxn = core::scoring::ScoreFunctionFactory::create_score_function( "empty", score_patch );
 		} else {
-			scfxn = core::scoring::ScoreFunctionFactory::create_score_function( score_name );
+			scfxn = core::scoring::ScoreFunctionFactory::create_score_function( "empty" );
 		}
-
-		//constraints are done via patches
-		bool chainbreaks_in_patch( scfxn->get_weight( scoring::linear_chainbreak ) > 0.0 );
-		core::Real extra_chainbreak_weight( basic::options::option[ basic::options::OptionKeys::jumps::increase_chainbreak ] );
-		if ( !chainbreaks_in_patch ) { //if chainbreak is not patched .. set it
-			core::Real lin_wgt( 4.0/3.0 * extra_chainbreak_weight );
-			core::Real overlap_wgt( 1.0 * extra_chainbreak_weight );
-			core::Real quad_wgt( 1.0 * extra_chainbreak_weight );
-			tr.Info << "no chainbreaks specified in  " << score_patch << ",..."
-							<< " set chainbreaks to " << lin_wgt << " and "
-							<< overlap_wgt <<" for linear- and overlap-chainbreak, respectively" << std::endl;
-			scfxn->set_weight( scoring::chainbreak, quad_wgt );
-			scfxn->set_weight( scoring::linear_chainbreak, lin_wgt );
-			scfxn->set_weight( scoring::overlap_chainbreak, overlap_wgt );
-		}
-
-		// this needs work in EvaluatedArchive to make sure the right constraint files are used...
-		if ( noesy_assign::NoesyModule::cmdline_options_activated() ) {
-			std::string const cst_file( fullatom ? first_noesy_fa_cst_file_ : first_noesy_cst_file_ );
-			Real weight( get_weight( "noesy_autoassign_cst" ) );
-			if ( weight < 0.01 )  {
-				tr.Error << "why is the noesy_autoassign_cst weight 0 ? set it to 5" << std::endl;
-				weight = 5.0;
-			}
-			add_evaluation( new constraints_additional::ConstraintEvaluator( "noesy_autoassign_cst", cst_file ), weight );
-		}
-
-		if ( super_quick_relax_of_centroids_ ) {
-			std::string score_patch=option[ iterative::fa_score_patch ]();
-			if ( score_patch != "NOPATCH" ) {
-				scfxn = core::scoring::ScoreFunctionFactory::create_score_function( "empty", score_patch );
-			} else {
-				scfxn = core::scoring::ScoreFunctionFactory::create_score_function( "empty" );
-			}
-			// cannot compute this from fullatom-pose... keep energy term around in rescore...
-			// 			std::string cen_score = option[ iterative::cen_score ]();
-			// 			core::scoring::ScoreFunctionOP cen_scfxn( NULL );
-			// 			cen_scfxn = core::scoring::ScoreFunctionFactory::create_score_function( cen_score );
-			// 			add_evaluation( new evaluation::TruncatedScoreEvaluator( "prefa_centroid_score", selection, cen_scfxn, true /*fullname*/ ), 1.0 );
-
-			std::string fa_score = option[ iterative::fa_score ]();
-			core::scoring::ScoreFunctionOP fa_scfxn( NULL );
-			fa_scfxn = core::scoring::ScoreFunctionFactory::create_score_function( fa_score );
-			add_evaluation( new simple_filters::TruncatedScoreEvaluator( "score_fa", selection, fa_scfxn, true /*fullname*/ ), option[ iterative::fullatom_after_quickrelax_weight ]() );
-
-		}
-		set_scorefxn( scfxn );
-		add_evaluation( new simple_filters::TruncatedScoreEvaluator( "_final", selection, scfxn ), 1.0 );
-
-
-		rescore();
-		save_to_file();
-		set_scorefxn( NULL );
-		remove_evaluation("score_final");
-		set_weight("score_final",1.0); // need this for further scoring
-		set_evaluate_local( false );//have set this above to true, it was temporarily
-	} //no local evaluation
+		// cannot compute this from fullatom-pose... keep energy term around in rescore...
+		// 			std::string cen_score = option[ iterative::cen_score ]();
+		// 			core::scoring::ScoreFunctionOP cen_scfxn( NULL );
+		// 			cen_scfxn = core::scoring::ScoreFunctionFactory::create_score_function( cen_score );
+		// 			add_evaluation( new evaluation::TruncatedScoreEvaluator( "prefa_centroid_score", selection, cen_scfxn, true /*fullname*/ ), 1.0 );
+
+		std::string fa_score = option[ iterative::fa_score ]();
+		core::scoring::ScoreFunctionOP fa_scfxn( NULL );
+		fa_scfxn = core::scoring::ScoreFunctionFactory::create_score_function( fa_score );
+		add_evaluation( new simple_filters::ScoreEvaluator( "score_fa", fa_scfxn, true /*fullname*/ ), option[ iterative::fullatom_after_quickrelax_weight ]() );
+	}
+
+	set_scorefxn( scfxn );
+	add_evaluation( new simple_filters::ScoreEvaluator( "_final", scfxn ), 1.0 );
+	rescore();
+	save_to_file();
+	set_scorefxn( NULL );
+	remove_evaluation("score_final");
+	set_weight("score_final",1.0); // need this for further scoring
+	//can only get here, if the mode is evaluate_local == false, then its setting to true was only temporarily
+	set_evaluate_local( false );//have set this above to true, it was temporarily
 }
 
 void IterativeBase::add_fullatom_flags( jd2::archive::Batch& batch ) {
@@ -1371,6 +1657,9 @@ void IterativeBase::add_fullatom_flags( 
 	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
 	//these are many.... should there be some input file ?
 	//	flags << "@../flags_fullatom" << std::endl;
+	if ( !option[ iterative::flags_fullatom ].user() ) {
+		utility_exit_with_message( "option -iterative:flags_fullatom is required !!! ");
+	}
 	flags << "@"<< option[ iterative::flags_fullatom ]() << std::endl;
 
 	if ( option[ constraints::cst_fa_file ].user() ) {
@@ -1392,126 +1681,6 @@ void IterativeBase::add_fullatom_flags( 
 					 << "END_CLAIMER\n"
 					 << std::endl;
 	}
-
-}
-
-void IterativeBase::gen_cen2fullatom( Batch& batch ) {
-	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
-	broker << "\nUSE_INPUT_POSE\n"
-				 << "CLAIMER StartStructClaimer\n"
-				 << "END_CLAIMER\n\n"
-				 << "CLAIMER JumpClaimer\n"
-				 << "END_CLAIMER\n\n" << std::endl;
-
-
-	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
-	flags << "-abinitio::skip_stages 1 2 3 4" << std::endl;
-
-	add_fullatom_flags( batch );
-	io::silent::SilentStructOPs start_decoys;
-	std::copy( decoys().begin(), decoys().end(), std::back_inserter( start_decoys ) );
-
-	if ( start_decoys.size() ) {
-		batch.set_has_silent_in();
-		core::io::silent::SilentFileData sfd;
-		for ( core::io::silent::SilentStructOPs::const_iterator
-						it = start_decoys.begin(); it != start_decoys.end(); ++it ) {
-			sfd.add_structure( **it );
-		}
-		sfd.write_all( batch.silent_in() );
-	}
-
-	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*start_decoys.size() ) ) );
-
-}
-
-void IterativeBase::gen_cen2fullatom_non_pool_decoys( Batch& batch ) {
-	using namespace core::io::silent;
-	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
-	broker << "\nUSE_INPUT_POSE\n"
-				 << "CLAIMER StartStructClaimer\n"
-				 << "END_CLAIMER\n\n"
-				 << "CLAIMER JumpClaimer\n"
-				 << "END_CLAIMER\n\n" << std::endl;
-
-
-	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
-	flags << "-abinitio::skip_stages 1 2 3 4" << std::endl;
-	add_fullatom_flags( batch );
-
-	//count total decoys
-	Size total( 0 );
-	for ( ArchiveManager::BatchList::const_iterator it = manager().batches().begin(); it != manager().batches().end(); ++it ) {
-		if ( it->id() >= first_fullatom_batch_ ) break;
-		if ( !it->has_silent_in() ) continue;
-		total += it->decoys_returned();
-		tr.Debug << "harvest old decoys for safety hatch: batch " << it->id() << " " << it->decoys_returned() << " " << total << std::endl;
-	}
-
-	Real score_cut_per_batch( option[ OptionKeys::iterative::safety_hatch_scorecut ] );
-	//now go thru batches and select percentage_per_batch structures randomly from the pool created by score_cut_per_batch...
-	//use score_final for this ? or can we use EvaluatedArchive methods to get a reasonable score ???
-	//ACHTUNG:  need also to know final centroid batch id...
-	SilentStructOPs start_decoys;
-	for ( ArchiveManager::BatchList::const_iterator it = manager().batches().begin(); it != manager().batches().end(); ++it ) {
-		Real percentage_per_batch( 1.0*batch.nstruct() / (1.0*total) );
-		if ( it->id() >= first_fullatom_batch_ ) break;
-		if ( !it->has_silent_in() ) continue; //usually only the resampling decoys are interesting...
-		if ( !it->decoys_returned() ) continue; //avoid looking for empty files
-		//		it->silent_out();
-		SilentFileData sfd;
-			std::list< std::pair< core::Real, SilentStructOP > > score_cut_decoys;
-		Size ct( 0 );
-		tr.Debug << "read and score decoys in " << it->silent_out() << "..." << std::endl;
-		sfd.read_file( it->silent_out() );
-		for ( SilentFileData::iterator sit=sfd.begin(), esit=sfd.end(); sit!=esit; ++sit ) {
-			std::string tag = sit->decoy_tag();
-			sit->set_decoy_tag( "harvest_"+batch.batch()+"_"+ObjexxFCL::lead_zero_string_of( ++ct, 6 ) );
-
-			//note this does nothing but return *it, if b_evaluate_incoming_decoys_ is false
-			core::io::silent::SilentStructOP pss = evaluate_silent_struct( *sit );
-			score_cut_decoys.push_back( std::make_pair( select_score( pss ), pss ) );
-		}
-		score_cut_decoys.sort();
-		tr.Debug << "select " << percentage_per_batch*100 << "% from batch from the lowest scoring " << score_cut_per_batch*100 << "% of structures" << std::endl;
-
-		// if we have less structures below score cut than what we want to harvest,.... take them all
-		while ( score_cut_per_batch < percentage_per_batch ) {
-			Size ind_max( static_cast< Size > ( score_cut_decoys.size()*score_cut_per_batch ) );
-			for ( std::list< std::pair< core::Real, core::io::silent::SilentStructOP > >::const_iterator sit = score_cut_decoys.begin();
-						sit != score_cut_decoys.end(); ++sit ) {
-				start_decoys.push_back( sit->second );
-				if ( --ind_max <= 1 ) break;
-			}
-			percentage_per_batch-=score_cut_per_batch;
-		}
-		// for the remaining structures we want to harvest, they clearly will be less than what the score-cut yields... choose randomly...
-		if ( percentage_per_batch > 0.01 ) {
-			Size ind_max( static_cast< Size > ( score_cut_decoys.size()*score_cut_per_batch ) );
-			for ( std::list< std::pair< core::Real, core::io::silent::SilentStructOP > >::const_iterator sit = score_cut_decoys.begin();
-						sit != score_cut_decoys.end(); ++sit ) {
-				if ( RG.uniform() < ( percentage_per_batch / score_cut_per_batch ) ) {
-					start_decoys.push_back( sit->second );
-				}
-				if ( --ind_max <= 1 ) break;
-			}
-		}
-	}
-
-	if ( start_decoys.size() ) {
-		batch.set_has_silent_in();
-		core::io::silent::SilentFileData sfd;
-		Size ct( 0 );
-		for ( core::io::silent::SilentStructOPs::const_iterator
-						it = start_decoys.begin(); it != start_decoys.end(); ++it ) {
-			if ( ++ct > batch.nstruct() ) break;
-			sfd.add_structure( **it );
-		}
-		sfd.write_all( batch.silent_in() );
-	}
-
-	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*start_decoys.size() ) ) );
-
 }
 
 /// ============================================================================
@@ -1571,55 +1740,39 @@ void get_core( toolbox::DecoySetEvaluati
 
 void IterativeBase::compute_cores() {
 	tr.Info << "compute converged regions " << std::endl;
+	basic::DynamicProfileThis prof_here("ARCHIVE_COMPUTE_CONVERGED_REGIONS");
 	core::Size const opt_nstruct( option[ iterative::rmsf_nstruct ]() );
 	core::Size const nstruct( std::min( int( opt_nstruct ), int( decoys().size() ) ));
+
+	if ( nstruct==0 ) return;
 	toolbox::DecoySetEvaluation eval;
 	eval.reserve( nstruct );
-	Size ct( 1 );
-	Size nres(1000);
-	for ( const_decoy_iterator iss = decoys().begin(); iss != decoys().end(); ++iss, ++ct ) {
-		if ( ct > nstruct ) break;
-		pose::Pose pose;
-		(*iss)->fill_pose( pose );
-		eval.push_back( pose );
-		nres = pose.total_residue();
-	}
+	Size nres( (*decoys().begin())->nres() );
+	//	Size ct( 1 );
+	//for ( const_decoy_iterator iss = decoys().begin(); iss != decoys().end(); ++iss, ++ct ) {
+	//		if ( ct > nstruct ) break;
+	//		pose::Pose pose;
+	//		(*iss)->fill_pose( pose );
+	//		eval.push_back( pose );
+	//		nres = pose.total_residue();
+	//	}
+	typedef toolbox::OP_const_iterator<SilentStructs::const_iterator, core::io::silent::SilentStructOP > decoy_iterator;
+	eval.push_back_CA_xyz_from_silent_file( nstruct, decoy_iterator( decoys().begin() ), decoy_iterator( decoys().end() ), false );
 
+	loops::Loops old_core15 = core15_;
 	loops::Loops old_core2 = core2_;
 	loops::Loops old_core3 = core3_;
 	loops::Loops old_core4 = core4_;
 
+	get_core( eval, 1.5, core15_ );
 	get_core( eval, 2, core2_ );
 	get_core( eval, 3, core3_ );
 	get_core( eval, 4, core4_ );
 
-	//	if ( old_core2 != core2_ ) add_core_evaluator( core2_, "_core2" );
-	//	if ( old_core3 != core3_ ) add_core_evaluator( core3_, "_core3" );
-	//	if ( old_core4 != core4_ ) add_core_evaluator( core4_, "_core4" );
-
-	if ( evaluate_local() ) {
-		set_weight( "score_core2", 0.0 );
-		set_weight( "score_core3", 0.0 );
-		set_weight( "score_core4", 0.0 );
-		set_weight( "score", 0.0 );
-
-		if ( ( 1.0*core2_.loop_size() / nres ) > option[ iterative::min_core_fraction_to_score ] ) {
-			set_weight( "score_core2", 1.0);
-			return;
-		}
-
-		if ( ( 1.0*core3_.loop_size() / nres ) > option[ iterative::min_core_fraction_to_score ] ) {
-			set_weight( "score_core3", 1.0);
-			return;
-		}
-
-		if ( ( 1.0*core4_.loop_size() / nres ) > option[ iterative::min_core_fraction_to_score ] ) {
-			set_weight( "score_core4", 1.0);
-			return;
-		}
-
-		set_weight( "score", 1.0 );
-	}
+	if ( old_core15 != core15_ ) add_core_evaluator( core15_, "_core15" );
+	if ( old_core2 != core2_ ) add_core_evaluator( core2_, "_core2" );
+	if ( old_core3 != core3_ ) add_core_evaluator( core3_, "_core3" );
+	if ( old_core4 != core4_ ) add_core_evaluator( core4_, "_core4" );
 	tr.Info << "finished computing converged regions" << std::endl;
 }
 
@@ -1627,29 +1780,11 @@ void IterativeBase::add_core_evaluator( 
 	utility::vector1< Size> selection;
 	core.get_residues( selection );
 	if ( reference_pose_ ) add_evaluation( new simple_filters::SelectRmsdEvaluator( reference_pose_, selection, core_tag ) );
-	add_evaluation( new simple_filters::TruncatedScoreEvaluator( core_tag, selection ) );
-	core.write_loops_to_file( name()+"/"+core_tag+".rigid", "RIGID" ); //so we have them for other evaluations
+	core.write_loops_to_file( name()+"/"+core_tag+".gen.rigid", "RIGID" ); //so we have them for other evaluations
 }
 
-
-
-
-// void IterativeBase::restore_from_file( std::string const& dirname ) {
-// 	EvaluatedArchive::restore_from_file( dirname );
-// 	utility::io::izstream stage( dirname+"/IterationStage" );
-// 	int bla;
-// 	stage >> bla;
-// 	stage_ = IterationStage( bla );
-// }
-
-// void IterativeBase::save_to_file( std::string const& dirname ) {
-// 	EvaluatedArchive::save_to_file( dirname );
-// 	utility::io::ozstream stage( dirname+"/IterationStage" );
-// 	stage << stage_;
-// }
-
 void IterativeBase::restore_status( std::istream& is ) {
-	EvaluatedArchive::restore_status( is );
+	Parent::restore_status( is );
 	int bla; std::string tag;
 	is >> tag >> bla;
 	runtime_assert( tag == "IterationStage:" );
@@ -1664,10 +1799,10 @@ void IterativeBase::restore_status( std:
 	compute_cores();
 	is >> tag;
 	if ( is.good() && tag == "SCORED_CORE:" ) {
+		//OBSOLETE TAG: read anyway for backward compatibility
 		loops::LoopsFileIO loop_file_reader;
 		loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format( is, name()+"STATUS file", false /*no strict checking */, "RIGID" );
-		scored_core_ = loops::Loops( loops );
-		scored_core_initialized_ = true;
+		tr.Warning << "WARNING: found obsolete tag SCORE_CORE in status file" << std::endl;
 	}
 	is >> tag;
 	if ( is.good() && tag == "NOESY_CYCLE:" ) {
@@ -1685,20 +1820,25 @@ void IterativeBase::restore_status( std:
 	if ( is.good() && tag == "NOESY_CURRENT_CST:" ) {
 		is >> current_noesy_sampling_file_;
 	}
+	if ( evaluate_local() && current_noesy_sampling_file_ != "n/a" ) { //change filter restraints if we are local-evaluators
+		topology_broker::ConstraintClaimerOP cst =
+			new topology_broker::ConstraintClaimer( current_noesy_sampling_file_+".filter", "noesy_autoassign_cst" );
+		cst->set_combine_ratio( bCombineNoesyCst_ ? 2 : 1 );
+		cst->set_fullatom( true );
+		cst->set_centroid( false );
+		cst->set_filter_weight( get_weight( "noesy_autoassign_cst" )/overall_cstfilter_weight_ );
+		add_evaluation( new topology_broker::ConstraintEvaluatorWrapper( cst->tag(), cst ), cst->filter_weight()*overall_cstfilter_weight_ );
+		rescore(); //rescore now, since we probably have more time now, when later when the decoys are arriving...
+	}
 	bCombineNoesyCst_ = stage() < STAGE2_RESAMPLING; //will be overwritten in next reassign NOESY... take guess until then...
 }
 
 void IterativeBase::save_status( std::ostream& os ) const {
-	EvaluatedArchive::save_status( os );
+	Parent::save_status( os );
 	os << "IterationStage: " << stage_;
 	os << "   first_batch_this_stage: " << first_batch_this_stage_;
 	os << "   first_fullatom_batch: " << first_fullatom_batch_;
 	os << std::endl;
-	if ( scored_core_initialized_ ) {
-		os << "SCORED_CORE:\n";
-		scored_core_.write_loops_to_stream( os, "RIGID" );
-		os << "END_SCORED_CORE" << std::endl;
-	}
 	os << "NOESY_CYCLE: " << noesy_assign_float_cycle_ << std::endl;
 	os << "NOESY_FIRST_CST: " << first_noesy_cst_file_ << std::endl;
 	os << "NOESY_FIRST_FA_CST: " << first_noesy_fa_cst_file_ << std::endl;
@@ -1713,127 +1853,69 @@ void IterativeBase::setup_default_evalua
 
 
 void IterativeBase::cluster() {
-	using namespace protocols::cluster;
-	//	using namespace basic::options::OptionKeys;
-	using namespace basic::options::OptionKeys::cluster;
-	using namespace basic::options;
-	using namespace toolbox;
-
-	//jump out if inactive
-	if ( !option[ iterative::cluster ]() ) return;
-	if ( decoys().size() < 50 ) return;
-  if ( min_diversity_list_[ stage() ] == 0 ) return;
-
-	mem_tr << "IterativeBase cluster-start" << std::endl;
-
-	SilentStructs kept_decoys;
-	toolbox::ClusterOptions cluster_opts( false /*don't change tags to c.XXX.NNN */ );
-	cluster_opts.cluster_radius = min_diversity_list_[ stage() ];
-	cluster_opts.keep_center = false; /* keep the lowest energy structures -- not interested in the most central structure */
-
- //read CA coords into DecoySetEvaluation
-  DecoySetEvaluation CA_set;
-	CA_set.push_back_CA_xyz_from_silent_file( decoys().size(),
-		utility::DereferenceIterator< SilentStructs >( decoys().begin() ),
-		utility::DereferenceIterator< SilentStructs >( decoys().end() ),
-		false /*don't store plain energies */
-	);
-
-	//we have our special score... so need to gather this information
-	utility::vector1< core::Real > all_energies;
-	all_energies.reserve( decoys().size() );
-	for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
-		all_energies.push_back( select_score( *it ) );
-	}
-	CA_set.set_all_energies( all_energies );
-
-	//now do the clustering
-	toolbox::cluster_silent_structs( CA_set,
-  	utility::DereferenceIterator< SilentStructs >( decoys().begin() ),
-		utility::DereferenceIterator< SilentStructs >( decoys().end() ),
-		kept_decoys,
-		cluster_opts
-	);
+	///OBSOLET
+// 	using namespace protocols::cluster;
+// 	//	using namespace basic::options::OptionKeys;
+// 	using namespace basic::options::OptionKeys::cluster;
+// 	using namespace basic::options;
+// 	using namespace toolbox;
+
+// 	//jump out if inactive
+// 	if ( !option[ iterative::cluster ]() ) return;
+// 	if ( decoys().size() < 50 ) return;
+//   if ( min_diversity_list_[ stage() ] == 0 ) return;
+
+// 	mem_tr << "IterativeBase cluster-start" << std::endl;
+
+// 	SilentStructs kept_decoys;
+// 	toolbox::ClusterOptions cluster_opts( false /*don't change tags to c.XXX.NNN */ );
+// 	cluster_opts.cluster_radius = min_diversity_list_[ stage() ];
+// 	cluster_opts.keep_center = false; /* keep the lowest energy structures -- not interested in the most central structure */
+
+//  //read CA coords into DecoySetEvaluation
+//   DecoySetEvaluation CA_set;
+// 	CA_set.push_back_CA_xyz_from_silent_file( decoys().size(),
+// 		utility::DereferenceIterator< SilentStructs >( decoys().begin() ),
+// 		utility::DereferenceIterator< SilentStructs >( decoys().end() ),
+// 		false /*don't store plain energies */
+// 	);
+
+// 	//we have our special score... so need to gather this information
+// 	utility::vector1< core::Real > all_energies;
+// 	all_energies.reserve( decoys().size() );
+// 	for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+// 		all_energies.push_back( select_score( *it ) );
+// 	}
+// 	CA_set.set_all_energies( all_energies );
 
-	//how many were removed ?
-	Size n_removed = decoys().size() - kept_decoys.size();
-	tr.Info << "removed " << n_removed << " structures.   " << kept_decoys.size() << " structures remaining after clustering " << std::endl;
-	decoys()=kept_decoys;
-	count_removed_structures( n_removed );
+// 	//now do the clustering
+// 	toolbox::cluster_silent_structs( CA_set,
+//   	utility::DereferenceIterator< SilentStructs >( decoys().begin() ),
+// 		utility::DereferenceIterator< SilentStructs >( decoys().end() ),
+// 		kept_decoys,
+// 		cluster_opts
+// 	);
+
+// 	//how many were removed ?
+// 	Size n_removed = decoys().size() - kept_decoys.size();
+// 	tr.Info << "removed " << n_removed << " structures.   " << kept_decoys.size() << " structures remaining after clustering " << std::endl;
+// 	decoys()=kept_decoys;
+// 	count_removed_structures( n_removed );
 
-	//finally...
-	mem_tr << "IterativeBase cluster-end" << std::endl;
+// 	//finally...
+// 	mem_tr << "IterativeBase cluster-end" << std::endl;
 }
 
 
 
 ///@detail before we can apply score-fxn we have to add extra data: RDC, NOES, (not supported yet: PCS, ... )
 void IterativeBase::score( pose::Pose & pose ) const {
-
 	//to speed up things we cache the RDC data in the archive
 	if ( basic::options::option[ basic::options::OptionKeys::in::file::rdc ].user() ) {
 		if ( !rdc_data_ ) rdc_data_ = new core::scoring::ResidualDipolarCoupling;
 		core::scoring::store_RDC_in_pose( rdc_data_, pose );
 	}
-
-	//set fullatom or centroid constraints
-	// remove cutpoints from pose used to setup the constraint-set--> at least we will not have higher atom-indices than
-	// in standard residues (which causes seg-faults, down the line.. ). Some constraints will be slightly messed up... but can't be that bad...
-	tr.Trace << "checking for constraints when rescoring" << std::endl;
-	using namespace core::scoring::constraints;
-	bool const fullatom( pose.is_fullatom() );
-	core::pose::Pose cutfree_pose( pose );
-	protocols::jumping::JumpSample jumps( pose.fold_tree() );
-	jumps.remove_chainbreaks( cutfree_pose );
-
-	if ( !fullatom && basic::options::option[ basic::options::OptionKeys::constraints::cst_file ].user() ) {
-		if ( !cst_data_ ) {
-			std::string filename( core::scoring::constraints::get_cst_file_option() );
-			tr.Info << "read centroid constraint set " << filename << std::endl;
-			cst_data_ = ConstraintIO::get_instance()->read_constraints( filename, new ConstraintSet, cutfree_pose );
-		}
-		pose.constraint_set( cst_data_ );
-	} else if ( fullatom ) {
-		if ( basic::options::option[ basic::options::OptionKeys::constraints::cst_fa_file ].user() ) {
-			if ( !cst_fa_data_ ) {
-				std::string filename( core::scoring::constraints::get_cst_fa_file_option() );
-				tr.Info << "read fullatom constraint set " << filename << std::endl;
-				cst_fa_data_ = ConstraintIO::get_instance()->read_constraints( filename, new ConstraintSet, cutfree_pose );
-			}
-		} else if ( basic::options::option[ basic::options::OptionKeys::constraints::cst_file ].user() ) {
-			if ( !cst_fa_data_ ) {
-				std::string const filename( core::scoring::constraints::get_cst_file_option() );
-				tr.Info << "read centroid constraint set " << filename  << " for fullatom " << std::endl;
-				cst_fa_data_ = ConstraintIO::get_instance()->read_constraints( filename, new ConstraintSet, cutfree_pose );
-			}
-		}
-		if ( cst_fa_data_ ) cutfree_pose.constraint_set( cst_fa_data_ );
-	} //fullatom
-
-	core::pose::Pose chainbreak_pose( pose );
-	jumping::JumpSample js( pose.fold_tree() );
-	js.add_chainbreaks( chainbreak_pose );
-	scoring::ScoreFunction chainbreaks_scfxn;
-	scoring::ScoreFunction no_chainbreak_scorefxn( scorefxn() );
-	chainbreaks_scfxn.set_weight(  scoring::linear_chainbreak, no_chainbreak_scorefxn.get_weight(  scoring::linear_chainbreak ) );
-	chainbreaks_scfxn.set_weight(  scoring::overlap_chainbreak, no_chainbreak_scorefxn.get_weight(  scoring::overlap_chainbreak ) );
-	chainbreaks_scfxn.set_weight(  scoring::chainbreak, no_chainbreak_scorefxn.get_weight(  scoring::chainbreak ) );
-	no_chainbreak_scorefxn.set_weight(  scoring::linear_chainbreak, 0);
-	no_chainbreak_scorefxn.set_weight(  scoring::overlap_chainbreak, 0);
-	no_chainbreak_scorefxn.set_weight(  scoring::chainbreak, 0);
-	//mjo commenting out 'val' because it is unused and causes a warning
-	//core::Real val = scorefxn( cutfree_pose );
-	//mjo commenting out 'chains' because it is unused and causes a warning
-	//core::Real chains = chainbreaks_scfxn( chainbreak_pose );
-	//score
-	scorefxn()( pose ); //get the weights into the pose
-	pose.energies().total_energies() = cutfree_pose.energies().total_energies();
-	pose.energies().total_energies()[ scoring::linear_chainbreak ] = chainbreak_pose.energies().total_energies()[ scoring::linear_chainbreak ];
-	pose.energies().total_energies()[ scoring::overlap_chainbreak ] = chainbreak_pose.energies().total_energies()[ scoring::overlap_chainbreak ];
-	pose.energies().total_energies()[ scoring::chainbreak ] = chainbreak_pose.energies().total_energies()[ scoring::chainbreak ];
-	if ( tr.Trace.visible() ) {
-		scorefxn().show( tr.Trace, pose );
-	}
+	Parent::score( pose );
 }
 
 
@@ -1900,10 +1982,12 @@ IterativeBase::test_broker_settings( Bat
 	try {
 		topology_broker::TopologyBrokerOP topology_broker = new topology_broker::TopologyBroker();
 		topology_broker::add_cmdline_claims( *topology_broker );
-		tr.Debug << "setting of broker::setup  ";
+		tr.Debug << "setting of broker::setup  " << std::endl;
 		utility::vector1< std::string > files( option[ OptionKeys::broker::setup ]() );
 		std::copy( files.begin(), files.end(), std::ostream_iterator<std::string>( tr.Debug, " "));
+		tr.Debug << std::endl;
 	} catch ( utility::excn::EXCN_Exception &excn ) {  // clean up options and rethrow
+		utility_exit_with_message( "[ERROR] problems with broker setup in "+batch.all_broker_files()+" aborting... ");
 		tr.Error << "[ERROR] problems with broker setup in " << batch.all_broker_files() << " aborting... " << std::endl;
 		// excn.show( tr.Error );
 		option = vanilla_options;
@@ -1937,5 +2021,68 @@ void IterativeBase::init_from_decoy_set(
 }
 
 
+//setup filter-cst from broker-setup:
+void IterativeBase::setup_filter_cst( core::Real overall_weight ) {
+	using namespace topology_broker;
+	tr.Info << "setup filter-cst module in IterativeBase"<<std::endl;
+	TopologyBrokerOP topology_broker = new TopologyBroker();
+	add_cmdline_claims( *topology_broker, false );
+	tr.Trace << "topology_broker is initiailized with " << topology_broker->num_claimers() << " claimers "<< std::endl;
+	core::Size ct( 1 );
+	for ( TopologyBroker::const_iterator it = topology_broker->begin();
+				it != topology_broker->end(); ++it, ++ct ) {
+		tr.Trace << "found claimer of type " << (*it)->type() << "trying to cast now..."<< std::endl;
+		ConstraintClaimerCOP cst_claimer = dynamic_cast< ConstraintClaimer* >( (*it).get() );
+		if ( cst_claimer ) {
+			tr.Info << "found cst-claimer with filter_name " << cst_claimer->filter_name()
+							<< " filter_weight " << cst_claimer->filter_weight() << std::endl;
+			if ( cst_claimer->filter_weight() < 0.01 ) continue;
+			std::string name( cst_claimer->filter_name() );
+			core::Real weight( cst_claimer->filter_weight() );
+			if ( !name.size() ) {
+				name = "filter_cst_"+ObjexxFCL::lead_zero_string_of( ct, 2 );
+			} else {
+				name = "filter_cst_"+name+"_"+ObjexxFCL::lead_zero_string_of( ct, 2 );;
+			}
+			add_evaluation( new ConstraintEvaluatorWrapper( name, cst_claimer ), weight*overall_weight );
+		}//if cst_claimer
+	} // for claimer
+}
+
+void IterativeBase::setup_autoNOE() {
+	if ( !noesy_assign::NoesyModule::cmdline_options_activated() ) return;
+
+	tr.Debug << "setup autoNOE module in IterativeBase"<<std::endl;
+	super_quick_relax_of_centroids_=true;
+	current_noesy_sampling_file_ = option[ iterative::initial_noe_auto_assign_csts ]();
+	using utility::file::file_exists;
+	if ( !file_exists( current_noesy_sampling_file_ ) ) {
+		utility_exit_with_message( "couldn't find initial NOESY-autoassign file "+current_noesy_sampling_file_ );
+	}
+
+	//another cst set for filtering
+	set_weight( "noesy_autoassign_cst", option[ iterative::cenpool_noesy_cst_weight ]()*overall_cstfilter_weight_ );
+
+	//use restraints combination -- this might be switched off later when convergence is better
+	bCombineNoesyCst_ = true;
+
+	//add full-atom restraints as Evaluator (since a full-atom structure is sent back after relax)
+	if ( evaluate_local() ) {
+		tr.Debug << "cool we have local-scoring active"<<std::endl;
+		topology_broker::ConstraintClaimerOP cst =
+			new topology_broker::ConstraintClaimer( current_noesy_sampling_file_+".filter", "noesy_autoassign_cst" );
+		cst->set_combine_ratio( bCombineNoesyCst_ ? 2 : 1 );
+		cst->set_fullatom( true );
+		cst->set_centroid( false );
+		cst->set_filter_weight( option[ iterative::cenpool_noesy_cst_weight ]() );
+		add_evaluation( new topology_broker::ConstraintEvaluatorWrapper( cst->tag(), cst ), cst->filter_weight()*overall_cstfilter_weight_ );
+	}
+
+	//hash-string of the low30 decoy-tags to quickly determine if a new AutoNOE run should be done.
+	std::ostringstream hash_string;
+	hash_string << "NO_POOL " << std::endl;
+	noesy_assign_hash_ = hasher( hash_string.str() );
+}
+
 } //abinitio
 } //protocols
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/IterativeBase.cc.olli patched/rosetta_source/src/protocols/abinitio/IterativeBase.cc.olli
--- vanilla/rosetta_source/src/protocols/abinitio/IterativeBase.cc.olli	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/IterativeBase.cc.olli	2012-06-10 16:12:40.472041226 +0200
@@ -0,0 +1,1962 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file IterativeAbrelax
+/// @brief iterative protocol starting with abinitio and getting progressively more concerned with full-atom relaxed structures
+/// @detailed
+///
+///
+/// @author Oliver Lange
+
+// Unit Headers
+#include <protocols/abinitio/IterativeBase.hh>
+#include <protocols/jd2/archive/ArchiveManager.hh>
+
+// Package Headers
+#include <protocols/noesy_assign/NoesyModule.hh>
+#include <protocols/noesy_assign/NoesyModule.impl.hh>
+
+// to test broker setup-file
+#include <protocols/topology_broker/TopologyBroker.hh>
+#include <protocols/topology_broker/util.hh>
+#include <basic/options/keys/broker.OptionKeys.gen.hh>
+
+// Project Headers
+#include <core/types.hh>
+#include <core/pose/Pose.hh>
+#include <core/pose/util.hh>
+// AUTO-REMOVED #include <core/io/pdb/pose_io.hh>
+#include <core/scoring/Energies.hh>
+#include <core/scoring/ResidualDipolarCoupling.hh>
+#include <core/scoring/constraints/ConstraintSet.hh>
+#include <core/scoring/constraints/ConstraintIO.hh>
+#include <core/scoring/constraints/util.hh>
+#include <protocols/constraints_additional/ConstraintEvaluator.hh>
+
+#include <core/io/silent/SilentStruct.hh>
+#include <core/io/silent/SilentFileData.hh>
+
+#include <core/fragment/ConstantLengthFragSet.hh>
+#include <core/fragment/FragmentIO.hh>
+#include <core/fragment/util.hh>
+
+
+#include <core/chemical/ChemicalManager.hh>
+
+#ifdef WIN32
+#include <core/fragment/FragID.hh>
+#include <core/scoring/dssp/PairingsList.hh>
+#endif
+
+#include <core/sequence/util.hh>
+#include <core/sequence/Sequence.hh>
+
+#include <protocols/toolbox/DecoySetEvaluation.hh>
+#include <protocols/toolbox/DecoySetEvaluation.impl.hh>
+
+#include <core/scoring/ScoreFunction.fwd.hh>
+#include <core/scoring/ScoreFunctionFactory.hh>
+#include <core/scoring/ScoreType.hh>
+
+
+// AUTO-REMOVED #include <core/scoring/constraints/util.hh>
+
+#include <protocols/abinitio/PairingStatistics.hh>
+#include <protocols/simple_filters/JumpEvaluator.hh>
+#include <protocols/simple_filters/RmsdEvaluator.hh>
+#include <protocols/simple_filters/ScoreEvaluator.hh>
+#include <protocols/evaluation/util.hh>
+#include <protocols/loops/util.hh>
+#include <protocols/loops/Loop.hh>
+#include <protocols/loops/LoopsFileIO.hh>
+#include <basic/Tracer.hh>
+#include <basic/MemTracer.hh>
+
+#include <protocols/cluster/cluster.hh>
+#include <protocols/toolbox/Cluster.hh>
+#include <protocols/toolbox/Cluster.impl.hh>
+
+
+#include <core/fragment/SecondaryStructure.hh>
+// ObjexxFCL Headers
+
+// Utility headers
+#include <utility/io/izstream.hh>
+#include <utility/io/ozstream.hh>
+#include <utility/file/FileName.hh>
+#include <utility/file/file_sys_util.hh>
+#include <numeric/random/random.hh>
+#include <utility/DereferenceIterator.hh>
+
+// Option Headers
+#include <basic/options/keys/abinitio.OptionKeys.gen.hh>
+#include <basic/options/keys/constraints.OptionKeys.gen.hh>
+#include <basic/options/keys/jumps.OptionKeys.gen.hh>
+#include <basic/options/keys/in.OptionKeys.gen.hh>
+#include <basic/options/keys/run.OptionKeys.gen.hh>
+#include <basic/options/keys/cluster.OptionKeys.gen.hh>
+
+// Third-party Headers
+#include <boost/functional/hash.hpp>
+
+//// C++ headers
+#include <cstdlib>
+#include <string>
+// AUTO-REMOVED #include <ctime>
+// AUTO-REMOVED #include <iterator>
+#include <vector>
+
+// Utility headers
+#include <basic/options/option_macros.hh>
+#include <numeric/random/random_permutation.hh>
+
+#include <core/import_pose/import_pose.hh>
+#include <core/pose/annotated_sequence.hh>
+#include <protocols/noesy_assign/CrossPeakList.impl.hh>
+#include <utility/vector0.hh>
+#include <utility/vector1.hh>
+
+static basic::Tracer tr("protocols.iterative");
+using basic::mem_tr;
+
+static numeric::random::RandomGenerator RG(428342); // <- Magic number, do not change
+
+using core::Real;
+using namespace core;
+using namespace basic;
+using namespace basic::options;
+using namespace basic::options::OptionKeys;
+
+OPT_2GRP_KEY( File, iterative, enumerate, broker )
+OPT_2GRP_KEY( Integer, iterative, enumerate, Naccept )
+OPT_2GRP_KEY( Boolean, iterative, enumerate, skip_half )
+//OPT_1GRP_KEY( Real, iterative, turnover_rate )
+OPT_1GRP_KEY( Integer, iterative, rmsf_nstruct )
+OPT_1GRP_KEY( File, iterative, cen_score )
+OPT_1GRP_KEY( File, iterative, cen_score_patch )
+
+OPT_1GRP_KEY( File, iterative, fa_score )
+OPT_1GRP_KEY( File, iterative, fa_score_patch )
+OPT_1GRP_KEY( Real, iterative, chainbreak_evaluator_weight )
+OPT_1GRP_KEY( IntegerVector, iterative, max_nstruct )
+OPT_1GRP_KEY( Real, iterative, perturb_resampling )
+OPT_1GRP_KEY( Boolean, iterative, mix_frags )
+OPT_1GRP_KEY( Real, iterative, min_core_fraction_to_score )
+OPT_1GRP_KEY( RealVector, iterative, min_diversity )
+OPT_1GRP_KEY( RealVector, iterative, accept_ratio )
+OPT_1GRP_KEY( Boolean, iterative, copy_pool_for_convergence_check )
+OPT_1GRP_KEY( Real, iterative, safety_hatch_scorecut )
+OPT_1GRP_KEY( Boolean, iterative, scored_ss_core )
+OPT_1GRP_KEY( File, iterative, force_scored_region )
+OPT_1GRP_KEY( Boolean, iterative, cluster )
+OPT_1GRP_KEY( File, iterative, fix_core )
+OPT_1GRP_KEY( Real, iterative, cenpool_noesy_cst_weight )
+OPT_1GRP_KEY( String, iterative, chemicalshift_column )
+OPT_1GRP_KEY( Real, iterative, cenpool_chemicalshift_weight )
+OPT_1GRP_KEY( Real, iterative, centroid_before_quickrelax_weight )
+OPT_1GRP_KEY( Real, iterative, fullatom_after_quickrelax_weight )
+OPT_1GRP_KEY( Integer, iterative, limit_decoys_for_noe_assign )
+OPT_1GRP_KEY( Boolean, iterative, centroid_quickrelax )
+OPT_1GRP_KEY( String, iterative, super_quick_relax_protocol )
+OPT_1GRP_KEY( Integer, iterative, skip_redundant_constraints )
+OPT_1GRP_KEY( String, iterative, initial_noe_auto_assign_csts )
+OPT_1GRP_KEY( Integer, iterative, delay_noesy_reassign )
+OPT_1GRP_KEY( String, iterative, auto_assign_scheme )
+OPT_1GRP_KEY( Real, iterative, dcut )
+OPT_1GRP_KEY( String, iterative, initial_beta_topology )
+OPT_1GRP_KEY( Integer, iterative, recompute_beta_Naccept )
+OPT_1GRP_KEY( String, iterative, flags_fullatom )
+OPT_1GRP_KEY( Boolean, iterative, force_topology_resampling )
+
+std::string const NOESY_CST_FILE_NAME("noe_auto_assign.cst");
+
+bool protocols::abinitio::IterativeBase::options_registered_( false );
+
+//Mike: when you want to remove these Macros... leave them at least here as comment - since they provide documentation
+void protocols::abinitio::IterativeBase::register_options() {
+	if ( !options_registered_ ) {
+		Parent::register_options();
+		noesy_assign::NoesyModule::register_options();
+		OPT( in::file::silent );
+		OPT( cluster::limit_cluster_size           );
+		OPT( cluster::limit_clusters               );
+		OPT( cluster::limit_total_structures       );
+
+		NEW_OPT( iterative::enumerate::Naccept, "use enumerated pairings until Naccept decoys were added to archive", 5000 );
+		NEW_OPT( iterative::enumerate::broker, "broker-file for enumerated_pairings", "" );
+		NEW_OPT( iterative::enumerate::skip_half, "run half of the batches without enumerated pairings -- even before Naccept is reached", false );
+		//		NEW_OPT( iterative::turnover_rate, "exchange of X percent of archive before new batch is started", 0.1 );
+		NEW_OPT( iterative::accept_ratio, "switch to new stage if accept_ratio is lower than", 0.2 );
+		NEW_OPT( iterative::rmsf_nstruct, "how many structures of pool used for computations of cores", 50 );
+		NEW_OPT( iterative::cen_score, "energy function for centroid pool", "score3" );
+		NEW_OPT( iterative::cen_score_patch, "patch of centroi_pool energy function", "NOPATCH" );
+		NEW_OPT( iterative::fa_score, "energy function for centroid pool", "score13_env_hb" );
+		NEW_OPT( iterative::fa_score_patch, "patch of centroi_pool energy function", "NOPATCH" );
+		NEW_OPT( iterative::max_nstruct, "give maximum numbers of structures generated for a given stage before switch -- 0 for infinite, -1 for skip stage", 0);
+
+		NEW_OPT( iterative::mix_frags, "mix frags with original fragset", false );
+		NEW_OPT( iterative::perturb_resampling, "perturb resample_stage2 start structures by this amount", 0.0 );
+		NEW_OPT( iterative::min_core_fraction_to_score, "use core (2, 3, 4A) for discriminiation if more than X% of residues", 2.0); //>1 == off
+		NEW_OPT( iterative::min_diversity, "don't accept structures that are closer than X to one of the pool", 1.5 );
+		NEW_OPT( iterative::copy_pool_for_convergence_check, "make a copy of the pool for each batch that uses the convergence check", true );
+		NEW_OPT( iterative::chainbreak_evaluator_weight, "weight for selection in pool...", 1.0 );
+
+		NEW_OPT( iterative::safety_hatch_scorecut, "in CEN2FULLATOM state use structures for innput that are below scorecut in individual batches", 0.1);
+		NEW_OPT( iterative::scored_ss_core, "selecte structures based on score restricted to the selected residues based on secondary structure", false );
+		NEW_OPT( iterative::force_scored_region, "as scored_ss_core, but residues for scoring are provided manually", "" );
+
+		NEW_OPT( iterative::cluster, "cluster archive with min_diversity_limit before each batch creation", false );
+
+		NEW_OPT( iterative::fix_core, "RIGID file for RigidChunkClaimer to fix residues in stage 1-3", "" );
+
+		NEW_OPT( iterative::cenpool_noesy_cst_weight, "weight to apply to centroid pool for noesy-autoassigned constraints", 5);
+		NEW_OPT( iterative::cenpool_chemicalshift_weight, "weight to apply to chemical shifts in centroid pool rescoring", 5 );
+		NEW_OPT( iterative::chemicalshift_column, "column name of the ChemicalShiftEvaluator used for chemical shift rescoring -- allows to have inactive shifts in score", "chem_shift" );
+		NEW_OPT( iterative::super_quick_relax_protocol, "provide a sequence file for super quick relax ", "none" );
+		NEW_OPT( iterative::centroid_before_quickrelax_weight, "add the centroid score of the decoy before it went into the <super_quick_relax> with this weight " , 1.0 );
+		NEW_OPT( iterative::fullatom_after_quickrelax_weight, "add the centroid score of the decoy before it went into the <super_quick_relax> with this weight " , 0.0 );
+		NEW_OPT( iterative::limit_decoys_for_noe_assign, "only use X first decoys for NOE assigment... ", 30 );
+		NEW_OPT( iterative::centroid_quickrelax, "run a quick relax on centroid structures... ", false );
+		NEW_OPT( iterative::skip_redundant_constraints, "skip constranits that have similar constraints within 1=same residue 2=neighbours (0=inactive)", 0 );
+
+		NEW_OPT( iterative::delay_noesy_reassign, "start reassigning NOE restraints after X structures have been generated", 500 );
+		NEW_OPT( iterative::initial_noe_auto_assign_csts, "initial nopool assignment of NOESY data.... ", "../initial_assignment/noe_auto_assign.cst" );
+		NEW_OPT( iterative::auto_assign_scheme,"select CONST, ADAPT1, ... ","CONST");
+		NEW_OPT( iterative::dcut,"in ADAPT1 what dcut should be chosen",7);
+		NEW_OPT( iterative::initial_beta_topology,"start with this file as beta.top in stage3","" );
+		NEW_OPT( iterative::force_topology_resampling,"if strand-fraction is low topology sampling is usually skipped. Override this with this flags", false );
+		NEW_OPT( iterative::recompute_beta_Naccept, "recompute beta-topology after minimum of Naccept structures -- if no initial_beta_topology always recompute", 2000 );
+		NEW_OPT( iterative::flags_fullatom, "point to flag-file to read flags for fullatom-refinement and loop-closing specify e.g., as ../flags_fullatom ","");
+		options_registered_ = true;
+	}
+}
+
+namespace protocols {
+namespace abinitio {
+
+static numeric::random::RandomGenerator RG(42089);  // <- rg needed for CEN2FULLATOM_NON_POOL_DECOYS
+
+using namespace jd2::archive;
+
+IterativeBase::IterativeBase(std::string name )
+	: EvaluatedArchive(),
+		scored_core_initialized_( false ),
+		super_quick_relax_of_centroids_( false ),
+		stage_( ENUMERATION ),
+		finish_stage_( LAST_CENTROID_START ),
+		first_batch_this_stage_ ( 1 ),
+		first_fullatom_batch_( 100000 ),
+		//		min_structures_for_accept_statistics_( 500 ),
+
+		bEnumeratedLastTime_( false ),
+
+		last_accepted_decoys_in_idle_( 0 ),
+
+		reference_pose_( NULL ),
+
+		cen_score_( option[ iterative::cen_score ]() ),
+		cen_score_patch_( option[ iterative::cen_score_patch ]() ),
+
+		fa_score_( option[ iterative::fa_score ]() ),
+		fa_score_patch_( option[ iterative::fa_score_patch ]() ),
+		noesy_assign_float_cycle_( 1.0 ), //changed OCT 20th 2010 ... start only in generation 3 of STAGE2_RESAMPLE with cyana-cycle 2
+		first_noesy_cst_file_( "n/a" ),
+		first_noesy_fa_cst_file_ ("n/a" ),
+		bCombineNoesyCst_( true ),
+		rdc_data_( NULL ),
+		cst_data_( NULL ),
+		cst_fa_data_( NULL )
+{
+	using namespace ObjexxFCL;
+	mem_tr << "IterativeBase CStor-Start" << std::endl;
+	//changes for debug mode
+	if ( option[ run::test_cycles ] || option[ run::dry_run ] ) {
+		//		min_structures_for_accept_statistics_ = 20;
+	}
+
+	//name is e.g., centroid_pool or fullatom_pool
+	set_name( name );
+
+
+	// --- setup scorefxn
+	core::scoring::ScoreFunctionOP scorefxn =
+		core::scoring::ScoreFunctionFactory::create_score_function( cen_score(), cen_score_patch() );
+	tr.Info << "create Archive Scorefunction with: "
+					<<  option[ iterative::cen_score]() << " "
+					<<  option[ iterative::cen_score_patch ]() << std::endl;
+
+
+	if (  option[ OptionKeys::iterative::force_scored_region ].user() ) {
+		std::ifstream is( option[ OptionKeys::iterative::force_scored_region ]().name().c_str() );
+
+		if (!is.good()) {
+			utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + option[ OptionKeys::iterative::force_scored_region ]().name() + "'" );
+		}
+		loops::LoopsFileIO loop_file_reader;
+		loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format( is, option[ OptionKeys::iterative::force_scored_region ](), false /*no strict checking */, "RIGID" );
+		scored_core_ = loops::Loops( loops );
+	}
+
+	mem_tr << "setup cen-scorefxn" << std::endl;
+
+	//constraints are done via patches
+	bool chainbreaks_in_patch( scorefxn->get_weight( scoring::linear_chainbreak ) > 0.0 );
+	core::Real extra_chainbreak_weight( basic::options::option[ basic::options::OptionKeys::jumps::increase_chainbreak ] );
+	if ( !chainbreaks_in_patch ) { //if chainbreak is not patched .. set it
+		core::Real lin_wgt( 4.0/3.0 * extra_chainbreak_weight );
+		core::Real overlap_wgt( 1.0 * extra_chainbreak_weight );
+		core::Real quad_wgt( 1.0 * extra_chainbreak_weight );
+		tr.Info << "no chainbreaks specified in  " << cen_score_patch() << ",..."
+						<< " set chainbreaks to " << lin_wgt << " and "
+						<< overlap_wgt <<" for linear- and overlap-chainbreak, respectively" << std::endl;
+		scorefxn->set_weight( scoring::chainbreak, quad_wgt );
+		scorefxn->set_weight( scoring::linear_chainbreak, lin_wgt );
+		scorefxn->set_weight( scoring::overlap_chainbreak, overlap_wgt );
+	}
+	set_scorefxn( scorefxn );
+
+	tr.Trace << "pool scorefxn as set to EvaluatedArchive: " << std::endl;
+	scorefxn->show( tr.Trace );
+
+	// --- setup pool-evaluation
+	if ( evaluate_local() ) {
+		set_weight( "score", 1.0 );
+	} else {
+		set_weight( "score", 0.0 ); //don't use score that comes back --- but the score_final thing
+		set_weight( "score_final", 1.0 );
+	}
+
+	super_quick_relax_of_centroids_ = option[ iterative::centroid_quickrelax ]();
+
+	if ( noesy_assign::NoesyModule::cmdline_options_activated() ) {
+		set_weight( "noesy_autoassign_cst", option[ iterative::cenpool_noesy_cst_weight ]() );
+		super_quick_relax_of_centroids_=true;
+
+		std::ostringstream hash_string;
+		hash_string << "NO_POOL " << std::endl;
+		noesy_assign_hash_ = hasher( hash_string.str() );
+
+		current_noesy_sampling_file_ = option[ iterative::initial_noe_auto_assign_csts ]();
+		using utility::file::file_exists;
+		if ( !file_exists( current_noesy_sampling_file_ ) ) {
+			utility_exit_with_message( "couldn't find initial NOESY-autoassign file "+current_noesy_sampling_file_ );
+		}
+	} // NoesyAssign
+
+	mem_tr << "setup evaluators" << std::endl;
+	if ( option[ iterative::cenpool_chemicalshift_weight ].user() ) {
+		chemshift_column_ = option[ iterative::chemicalshift_column ]();
+		set_weight( option[ iterative::chemicalshift_column ](), option[ iterative::cenpool_chemicalshift_weight ]() );
+		super_quick_relax_of_centroids_=true;
+		//this will make constraints probably invisible...
+		if ( option[ constraints::cst_file ].user() || option[ constraints::cst_fa_file ].user() ) set_weight( "filter_constraints", 5.0 );
+	}
+	if ( super_quick_relax_of_centroids_ ) {
+		set_weight( "prefa_centroid_score", option[ iterative::centroid_before_quickrelax_weight ]() );
+		set_weight( "score_fa", option[ iterative::fullatom_after_quickrelax_weight ]() );
+		set_weight( "score", 0 );
+	}
+
+	//OBSOLET	add_evaluation( new evaluation::JumpNrEvaluator );
+	//OBSOLET	set_weight( "nrjump_weighted_chainbreaks", option[ iterative::chainbreak_evaluator_weight ] );
+
+	// --- setup stage-steering parameters
+	// maximum of sampled structures per stage
+	max_nstruct_list_ = option[ iterative::max_nstruct ]();
+	if ( max_nstruct_list_.size() != ( FINISHED-1 ) ) {
+		throw EXCN_Archive("wrong number "+string_of( max_nstruct_list_.size() )
+			+" of values for max_nstruct -- needs exactly "+string_of( FINISHED - 1 )+" values.");
+	}
+	max_nstruct_list_.push_back( 0 ); //for FINISH_STAGE
+
+	// min cluster radius for diversification
+	min_diversity_list_ = option[ iterative::min_diversity ]();
+	if ( min_diversity_list_.size() != ( FINISHED-1 ) ) {
+		throw EXCN_Archive("wrong number "+string_of( min_diversity_list_.size() )
+			+" of values for min_diversity -- needs exactly "+string_of( FINISHED - 1 )+" values.");
+	}
+	min_diversity_list_.push_back( 0 ); //for FINISH_STAGE
+
+	// accept ratio to end stage
+	target_accept_ratio_ = option[ iterative::accept_ratio ]();
+	if ( target_accept_ratio_.size() != ( FINISHED-1 ) ) {
+		throw EXCN_Archive("wrong number "+string_of( target_accept_ratio_.size() )
+			+" of values for accept_ratio -- needs exactly "+string_of( FINISHED - 1 )+" values.");
+	}
+	target_accept_ratio_.push_back( 1 ); //for FINISH_STAGE
+
+	/// -- setup native pose
+	if ( option[ in::file::native ].user() ) {
+		core::pose::PoseOP native_pose = new core::pose::Pose;
+		core::import_pose::pose_from_pdb( *native_pose, option[ in::file::native ]() );
+		reference_pose_ = native_pose;
+		mem_tr << "setup native pose" << std::endl;
+	}
+
+
+	/// --- setup sequence
+	if ( option[ in::file::fasta ].user() ) {
+		target_sequence_ = core::sequence::read_fasta_file( option[ in::file::fasta ]()[1] )[1]->sequence();
+	} else {
+		if ( reference_pose_ ) {
+			target_sequence_ = reference_pose_->sequence();
+		} else {
+			throw EXCN_Archive("need either fasta-sequence (-in:file:fasta) or native structure ( -in:file:native )");
+		}
+	}
+
+	if ( tr.Trace.visible() ) {
+		if ( reference_pose_ ) reference_pose_->dump_pdb("reference_pose_in_IterativeBase.pdb");
+		tr.Trace << "target_sequence_:\n " << target_sequence_ << std::endl;
+	}
+
+	/// determine if we have enough strands to do jumping...
+	using namespace core::fragment;
+	FragSetOP frags_s = FragmentIO( option[ OptionKeys::abinitio::number_3mer_frags ]()	).read_data( option[ in::file::frag3 ] );
+	core::fragment::SecondaryStructure ss_def( *frags_s, true /*no JustUseCentralResidue */ );
+	Size ct_E( 0 );
+	for ( Size i=1; i<=ss_def.total_residue(); ++i ) {
+		if ( ss_def.strand_fraction( i ) > 0.7 ) ++ct_E;
+	}
+	mem_tr << "fragments loaded for ss-prediction" << std::endl;
+	//less than 15% strands and less than 40 residues in total and we skip jumping...
+	bDoBetaJumping_ = true;
+	if ( (ct_E*1.0)/(ss_def.total_residue()*1.0) < 0.15 && ct_E < 40 ) {
+		tr.Info << "skip beta-jumping since mostly alpha-helical protein" << std::endl;
+		tr.Info << "only " << (ct_E*1.0)/(ss_def.total_residue()*1.0)*100 << "% of residues display significant strand-character" << std::endl;
+		bDoBetaJumping_ = false;
+	}
+	if ( !bDoBetaJumping_ && option[ OptionKeys::iterative::force_topology_resampling ]() ) {
+		tr.Info << "force-topology-resampling despite low beta-sheet content due to flag -force_topology_resampling" << std::endl;
+		bDoBetaJumping_ = true;
+	}
+	if ( !bDoBetaJumping_ ) {
+		stage_ = PURE_TOPO_RESAMPLING;
+	}
+
+	test_for_stage_end();
+
+	mem_tr << "IterativeBase CStor-End" << std::endl;
+}
+
+IterativeBase::~IterativeBase() {}
+
+///@details ready for new batch .... if queue is empty batch will be generated any way, but otherwise we only generate if this yields true.
+///  logic here: new batch at beginning, but only if we are in startup phase ( not a reload of a full archive )
+///              otherwise make new batch if sufficiently many structures have been accepted since last batch
+// bool IterativeBase::ready_for_batch() const {
+// 	if ( !bStartedInitBatch_ && decoys().size() <= nstruct() ) return true;
+// 	if ( decoys().size() >= nstruct() && accepts_since_last_batch() > nstruct_accept_before_rerun_ && proposed_since_last_batch() > min_structures_for_accept_statistics_ ) return true;
+// 	return false;
+// }
+
+
+
+
+///  ----------------- stage control ----------------------
+// ---> outsource to extra class ?  --- might be reused by other protocols
+///@brief batch is expired ?
+bool IterativeBase::still_interested( Batch const& batch ) const {
+	return Parent::still_interested( batch ) && batch.id() >= first_batch_this_stage_;
+}
+
+
+void IterativeBase::read_structures( core::io::silent::SilentFileData& sfd, Batch const& batch ) {
+	Parent::read_structures( sfd, batch );
+	test_for_stage_end();
+}
+
+///@brief are we ready to switch to next stage ?
+void IterativeBase::test_for_stage_end() {
+	//switch to next stage ? want to have some significance to this ratio --- hence at least 1000 proposals
+	tr.Info << "current accept ratio: " << current_acceptance_ratio() << " this is "
+					<< ( current_acceptance_ratio() < target_accept_ratio() ? "" : "not" )
+					<< " lower than " << target_accept_ratio()
+					<< "\n"
+					<< proposed_since_last_batch() << " proposed decoys since last batch "
+					<< std::endl;
+
+
+	int last_stage_N( 0 );
+	if ( stage_ > 1 ) last_stage_N = max_nstruct_list_[ stage_ - 1 ];
+	if ( max_nstruct_list_[ stage_ ] && ( (int) total_proposed() - last_stage_N ) > max_nstruct_list_[ stage_ ] ) {
+		tr.Info << "maximum number of " << max_nstruct_list_[ stage_ ]
+						<< " decoys for stage " << stage_ << " is reached...switching!" << std::endl;
+		increment_stage();
+	}
+
+	if ( current_acceptance_ratio() < target_accept_ratio() ) {
+		increment_stage();
+	}
+}
+
+///@brief got to next stage
+void IterativeBase::increment_stage() {
+	if ( stage_ >= finish_stage_ ) return;
+	save_to_file( "_stage" + ObjexxFCL::string_of( stage_ ) );
+
+	//save current number of structures:
+	max_nstruct_list_[ stage_ ] = total_proposed(); 	//used in test_for_stage_end to no how-many new structures since last stage
+
+	//switch to next possible stage
+	stage_ = IterationStage( 1 + (int) stage_ );
+	while ( max_nstruct_list_[ stage_ ] < 0 && stage_ < finish_stage_ ) {
+		stage_ = IterationStage( 1 + (int) stage_ );
+	}
+	if ( !manager_ptr() ) {
+		tr.Info << "start with stage " << stage_ << std::endl;
+		return;
+	}
+	tr.Info << "manager_ptr() " << manager_ptr() << " logical " << !manager_ptr() << std::endl;
+	tr.Info << "switched to stage: " << stage_ << std::endl;
+
+	//safe status and reset counters
+	first_batch_this_stage_ = manager().last_batch_id()+1;
+	save_to_file();
+	reset_accept_counter();
+	manager().cancel_batches_previous_to( manager().last_batch_id(), true /*allow reading of decoys already in production*/ );
+
+	//if we are not doing enumeration anymore we don't need fragments.
+	using namespace core::fragment;
+	if ( stage_ >= PURE_TOPO_RESAMPLING ) FragmentIO().clean_frag_cache();
+
+}
+
+/// ------------------------ end stage control
+
+///@brief overload to check for pool_convergence data in incoming decoys
+bool IterativeBase::add_structure( core::io::silent::SilentStructOP from_batch ) {
+	core::io::silent::SilentStructOP evaluated_decoy = evaluate_silent_struct( from_batch );
+
+	//comes without pool-convergence ? nothing to do
+	if ( !from_batch->has_energy( "pool_converged_tag" ) || min_diversity_list_[ stage() ] == 0 ) {
+		return Parent::add_evaluated_structure( evaluated_decoy );
+	}
+
+	//okay, let's look at the rmsd to closest structure
+	runtime_assert( from_batch->has_energy( "pool_converged_rmsd" ) );
+	Real const rmsd_to_pool( from_batch->get_energy( "pool_converged_rmsd" ) );
+
+	if ( rmsd_to_pool > min_diversity_list_[ stage() ] ) { //structure is sufficiently different -- add via score
+		return Parent::add_evaluated_structure( evaluated_decoy );
+	} else { //structure is close in RMSD to one of archive
+		std::string const tag( from_batch->get_string_value( "pool_converged_tag" ) );
+
+		//find the pool-structure that is redundant with new decoy
+		SilentStructs::iterator it;
+		for ( it = decoys().begin(); it != decoys().end(); ++it ) {
+			if ( (*it)->decoy_tag() == tag ) break;
+		}
+
+		if ( it == decoys().end() ) {
+			//can't find tag ... (might be that we are close to a centroid structure and now add to fullatom pool ).
+			//                    might be that we have swapped away the original structure
+			return Parent::add_evaluated_structure( evaluated_decoy );
+		}
+		//improved score ?
+		if ( it != decoys().end() && select_score( evaluated_decoy ) < select_score( *it ) ) {
+			tr.Debug << "swap " << evaluated_decoy->decoy_tag() << " for " << (*it)->decoy_tag() << std::endl;
+			decoys().erase( it );
+			return Parent::add_evaluated_structure( evaluated_decoy );
+		}
+
+		tr.Trace << "decoy " << evaluated_decoy->decoy_tag() << " with original tag " << evaluated_decoy->get_comment( "tag_in_file" )
+						 << " declined because of min_diversity: rmsd is " << rmsd_to_pool
+						 << " limit: " << min_diversity_list_[ stage() ]
+						 << std::endl;
+
+		return false; //declined ... either tag not found or score not improved...
+	}
+	return false; //should never get here
+}
+
+
+
+///@details generate new batch...
+/// type of batch depends on stage_. we switch to next stage based on some convergence criteria:
+/// right now it is how many decoys were accepted from last batch.. if this number drops sufficiently ---> next stage...
+///    (maybe need to put a safeguard in here: ratio small but at least XXX decoys proposed since last batch... )
+///
+void IterativeBase::generate_batch() {
+	cluster();
+
+	mem_tr << "IterativeBase::start_new_batch " << std::endl;
+	Batch& batch( manager().start_new_batch() );
+	mem_tr << "IterativeBase::generate_batch " << stage_ << " " << batch.batch() << std::endl;
+
+	tr.Info << "\ngenerate batch from " <<name() << " " << batch.batch() << std::endl;
+
+	//want intermediate structures from abinitio runs
+	batch.set_intermediate_structs();
+
+	// --- run some of the gen_X methods to generate the type of run we want
+	gen_noe_assignments( batch );
+
+	// first 2 stages: enumerate pairings
+	if ( (int) stage_ < (int) PURE_TOPO_RESAMPLING ) gen_enumerate_pairings( batch );
+
+	// beta-sheet-topologies
+	if ( stage_ == TOPO_RESAMPLING || stage_ == PURE_TOPO_RESAMPLING ) gen_resample_topologies( batch );
+
+	if ( (int) stage_ < (int) STAGE2_RESAMPLING && option[ iterative::fix_core ].user() ) {
+		gen_start_structures( batch );
+	}
+
+	// reuse fragments and restart from stage2 structures
+	if ( stage_ == STAGE2_RESAMPLING ) {
+		gen_resample_stage2( batch );
+		gen_resample_fragments( batch );
+	}
+	bool result_is_fullatom = false;
+	// close loops - fullatom relax
+	if ( stage_ == CEN2FULLATOM ) {
+		gen_cen2fullatom( batch );
+		gen_resample_fragments( batch );
+		batch.set_intermediate_structs( false ); //otherwise the intermediate (centroid) structures will be scored by score_13_envhb
+		result_is_fullatom = true;
+	}
+	mem_tr.Debug << "before evaluation output" << std::endl;
+	//finalize batch
+	gen_evaluation_output( batch, result_is_fullatom );
+	mem_tr.Debug << "evaluation output" << std::endl;
+
+	test_broker_settings( batch );
+	manager().finalize_batch( batch );
+
+
+	//add extra batch if we have "safety_hatch"
+	if ( stage_ == CEN2FULLATOM && option [ iterative::safety_hatch_scorecut ].user() ) {
+		mem_tr.Debug << "make safety hatch..." << std::endl;
+		Batch& harvest_batch( manager().start_new_batch() );
+		tr.Info << "starting harvest batch at same time as normal cen2fullatom batch" << std::endl;
+		gen_cen2fullatom_non_pool_decoys( harvest_batch );
+
+		// add NOESY autoassign constraints
+		gen_noe_assignments( harvest_batch );
+
+		harvest_batch.set_intermediate_structs( false ); //otherwise the intermediate (centroid) structures will be scored by score_13_envhb
+		gen_evaluation_output( harvest_batch, true /*fullatom*/ );
+
+		test_broker_settings( batch );
+		manager().finalize_batch( harvest_batch );
+	}
+
+	tr.Info << std::endl;
+	// don't want to reset counters too often... if we run out of steam the QUEUE EMPTY pathway will make sure that we do more runs
+
+	mem_tr << "IterativeBase::generated_batch " << std::endl;
+	//now it is best time to do this... JobQueue is definitely filled up....
+	reassign_noesy_data( batch );
+
+
+}
+
+void IterativeBase::idle() {
+	if ( last_accepted_decoys_in_idle_ != ( accepts_since_last_batch() + total_accepts() ) ) {
+		last_accepted_decoys_in_idle_ = accepts_since_last_batch() + total_accepts();
+		compute_cores();
+	}
+}
+
+/// ============================================================================
+/// -----------           methods to make new batches               ------------
+/// -----          each method should only "append" to broker and flags    -----
+/// ============================================================================
+
+
+void IterativeBase::gen_evaluation_output( Batch& batch, bool fullatom ) {
+	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+	flags << "-evaluation:jump_nr" << std::endl; //add JumpNrEvaluator
+
+	//add score evaluator
+	if ( !fullatom && !super_quick_relax_of_centroids_ ) { //centroid
+		flags << "-evaluation:extra_score " << option[ iterative::cen_score]() << std::endl
+					<< "-evaluation:extra_score_column _final" << std::endl;
+		flags << "-evaluation:extra_score_patch " << option[ iterative::cen_score_patch ]() << std::endl;
+	} else { //fullatom
+		if ( super_quick_relax_of_centroids_ ) {
+			flags << "-evaluation:extra_score " << "empty " << option[ iterative::fa_score]() << std::endl
+						<< "-evaluation:extra_score_column _final _fa" << std::endl;
+			flags << "-evaluation:extra_score_patch " << option[ iterative::fa_score_patch ]() << " NOPATCH " << std::endl;
+		} else {
+			flags << "-evaluation:extra_score " << option[ iterative::fa_score]() << std::endl
+						<< "-evaluation:extra_score_column _final" << std::endl;
+			flags << "-evaluation:extra_score_patch " << option[ iterative::fa_score_patch ]() << std::endl;
+		}
+	}
+
+
+	if ( super_quick_relax_of_centroids_ ) {
+		if ( !fullatom ) {
+			if ( option[ iterative::super_quick_relax_protocol ].user() ) {
+				flags<< "-relax:sequence_file " <<  option[ iterative::super_quick_relax_protocol ]() << std::endl;
+			} else {
+				utility::io::ozstream sequence_file( batch.dir()+"/super_quick_relax.txt" );
+				sequence_file << "ramp_repack_min 0.02  0.01"      << std::endl;
+				sequence_file << "ramp_repack_min 0.250 0.01"      << std::endl;
+				sequence_file << "ramp_repack_min 0.550 0.01"      << std::endl;
+				sequence_file << "ramp_repack_min 1     0.00001"   << std::endl;
+				sequence_file << "accept_to_best"                  << std::endl;
+				flags << "-relax:sequence_file " << batch.dir()+"/super_quick_relax.txt" << std::endl;
+			}
+			flags << "-relax:sequence" << std::endl;
+			flags << "-out:user_tag centroid" << std::endl;
+		} else { //!fullatom
+			flags << "-out:user_tag fullatom" << std::endl;
+		}
+		if ( option[ constraints::cst_file ].user() && !option[ constraints::cst_fa_file ].user() ) {
+			flags << "-evaluation:constraints " << option[ constraints::cst_file ]()[1] << std::endl;
+			flags << "-evaluation:constraints_column " << "filter_constraints" << std::endl;
+		} else if ( option[ constraints::cst_fa_file ].user() ) {
+			flags << "-evaluation:constraints " << option[ constraints::cst_fa_file ]()[1] << std::endl;
+			flags << "-evaluation:constraints_column " << "filter_constraints" << std::endl;
+		}
+	}
+
+	//score only parts of the structure ?
+	if ( scored_core_initialized_ && scored_core_.nr_residues() > 30 ) { //hey if this is less something is seriously wrong and we ignore it.
+		flags << "-evaluation:extra_score_select " << batch.dir()+"/scored_core.rigid" ;
+		if ( super_quick_relax_of_centroids_ ) {
+			flags << " " << batch.dir()+"/scored_core.rigid" ;
+		}
+		flags << std::endl;
+		scored_core_.write_loops_to_file( batch.dir()+"/scored_core.rigid", "RIGID" );
+	}
+
+	if ( noesy_assign::NoesyModule::cmdline_options_activated() ) {
+		if ( first_noesy_cst_file_ == "n/a" ) {
+			if ( super_quick_relax_of_centroids_ ) {
+				first_noesy_cst_file_ = current_noesy_sampling_file_+".filter";
+			} else {
+				first_noesy_cst_file_ = current_noesy_sampling_file_+".filter.centroid";
+			}
+		}
+		if ( fullatom && first_noesy_fa_cst_file_ == "n/a" ) {
+			first_noesy_fa_cst_file_ = current_noesy_sampling_file_+".filter";
+		}
+		flags << "-evaluation::constraints " << ( fullatom ? first_noesy_fa_cst_file_ : first_noesy_cst_file_ ) << std::endl;
+		flags << "-evaluation::constraints_column " << ( evaluate_local() ? "noesy_autoassign_cst_worker" : "noesy_autoassign_cst" ) << std::endl;
+	}
+
+	//compute pool_convergence_XXX ?
+	if ( min_diversity_list_[ stage() ] > 0 ) {
+		if ( option[ iterative::copy_pool_for_convergence_check ]() ) {
+			io::silent::SilentFileData sfd;
+			for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+				sfd.add_structure( *it ); //not a copy, only adds OP to sfd
+			}
+			sfd.write_all( batch.dir()+"/pool.in" );
+			if ( sfd.size() == 0 ) {
+				// write a pool anyway so that we have the tags in the returning structures and don't mess
+				// up the columns in the pool decoys.out file... not crucial but makes post-analysis with scripts easier.
+				utility::io::ozstream empty_pool_file( batch.dir()+"/pool.in" );
+				empty_pool_file << "REMARK no structure in pool " << std::endl;
+			}
+			flags << "-mc:known_structures " << batch.dir() << "/pool.in" << std::endl;
+		} else 	flags << "-mc:known_structures " << name() << "/decoys.out" << std::endl;
+		flags << "-mc:max_rmsd_against_known_structures " << std::max( 0.0, min_diversity_list_[ stage() ] - 0.25 ) << std::endl;
+		if ( basic::options::option[ basic::options::OptionKeys::in::replonly_residues ].user() ) {
+			flags << "-mc:excluded_residues_from_rmsd ";
+			utility::vector1<Size> replonly_rsd = basic::options::option[ basic::options::OptionKeys::in::replonly_residues ]();
+			for ( utility::vector1<Size>::const_iterator it = replonly_rsd.begin(); it != replonly_rsd.end(); ++it ) {
+				flags << " "<< *it;
+			}
+			flags << std::endl;
+		}
+	}
+} //gen_evaluation
+
+///@brief in the comp. modelling protocol the topo-resampling stage might also contain a RigidChunkClaimer...
+/// provide start-structures for this as -in:file:silent
+void IterativeBase::gen_start_structures( Batch& batch ) {
+
+	batch.set_has_silent_in();
+	io::silent::SilentFileData sfd;
+	for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+		sfd.add_structure( *it ); //not a copy, only adds OP to sfd
+	}
+	sfd.write_all( batch.silent_in() );
+
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	broker << "\nUSE_INPUT_POSE\n" << std::endl;
+	broker << "CLAIMER RigidChunkClaimer" << std::endl
+				 << "REGION_FILE " << option[ iterative::fix_core ]() << std::endl
+				 << "END_CLAIMER" << std::endl;
+
+	//compute nstruct such that we get the usual amount of total structures
+	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*decoys().size() ) ) );
+}
+
+///@brief figure out beta-sheet topologies from pooled decoys and run with jumping
+void IterativeBase::gen_resample_topologies( Batch& batch) {
+	if ( !bDoBetaJumping_ ) return;
+	tr.Info << "resample topologies\n";
+
+
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	broker << "\nCLAIMER TemplateJumpClaimer \n"
+		     << "NO_USE_INPUT_POSE\n"
+				 << "topol_file "<< batch.dir() << "beta.top\n"
+				 << "END_CLAIMER\n\n" << std::endl;
+	broker.close();
+
+	if ( option[ iterative::initial_beta_topology ].user() &&  option[ iterative::recompute_beta_Naccept ]() > (int) total_accepts() ) {
+		//copy file to batch.dir() + "beta.top"
+		std::string input( option[ iterative::initial_beta_topology ]() );
+
+		utility::io::izstream beta_input( input );
+		if( beta_input.good() ) {
+			std::string line;
+			utility::io::ozstream beta_batch( batch.dir()+"beta.top" );
+			while ( getline( beta_input, line ) ) beta_batch << line << std::endl;
+		} else {
+			utility_exit_with_message("topology_file "+input+" not found. supply file or remove option -iterative::initial_beta_topology");
+		}
+	} else {
+		PairingStatisticsOP beta_topol = compute_beta_topology();
+		utility::io::ozstream file( batch.dir() + "beta.top" );
+		file << *beta_topol << std::endl;
+	}
+}
+
+///@brief restart runs from stage2-structures that correspond to those in the pool
+void IterativeBase::gen_resample_stage2( jd2::archive::Batch& batch ) {
+	tr.Info << "resample_stage2 \n";
+	mem_tr << "IterativeBase::gen_resample_stage2 start" << std::endl;
+	SilentStructVector start_decoys;
+	collect_alternative_decoys( decoys(), "decoys_stage2.out", start_decoys );
+// 	typedef std::map< std::string, utility::vector1< std::string > > SourceFiles;
+// 	typedef std::map< std::string, utility::vector1< core::io::silent::SilentStructOP > > AlternativeDecoys;
+
+// 	SourceFiles sources;
+// 	AlternativeDecoys alternative_decoys;
+// 	Size ct_in( 0 );
+
+// 	//to find the stage2 structures collect first all tags for a specific file
+// 	for ( const_decoy_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+// 		runtime_assert( (*it)->has_comment( TAG_IN_FILE ) );
+// 		std::string tag( (*it)->get_comment( TAG_IN_FILE ) );
+// 		utility::file::FileName file( (*it)->get_comment( SOURCE_FILE ) );
+// 		std::string stage2_file( file.path()+file.base() + "_stage2." + file.ext() );
+
+// 		//creates map <filename> <list of tags>
+// 		sources[ stage2_file ].push_back( tag );
+// 		alternative_decoys[ stage2_file ].push_back( (*it) );
+// 		++ct_in;
+// 	}
+
+// 	//read selected structures from each file
+// 	Size ct_read( 0 );
+// 	io::silent::SilentStructOPs start_decoys;
+// 	for ( SourceFiles::const_iterator it = sources.begin(); it != sources.end(); ++it ) {
+// 		/// it->first is filename, it->second are all tags collected for this file
+// 		io::silent::SilentFileData sfd;
+// 		try { //read structures
+// 			sfd._read_file( it->first, it->second, true /*throw exceptions */ );
+// 			if ( sfd.size() != it->second.size() ) {
+// 				tr.Warning << "[WARNING] multiple decoys with same tag detected in file " << it->first << std::endl;
+// 			}
+// 			copy( sfd.begin(), sfd.end(), std::back_inserter( start_decoys ) );
+// 			ct_read += sfd.size();
+// 		} catch ( utility::excn::EXCN_IO& excn ) { //ERROR
+// 			tr.Warning << "[WARNING] Problem reading silent-file " << it->first << " for " << it->second.size() << " structures " << std::endl;
+// 			excn.show( tr.Warning );
+// 			tr.Warning << std::endl;
+// 			tr.Warning << "use the respective structures in the pool as starting structure instead" << std::endl;
+// 			copy( alternative_decoys[ it->first ].begin(), alternative_decoys[ it->first ].end(), std::back_inserter( start_decoys ) );
+// 			ct_read += alternative_decoys[ it->first ].size();
+// 		}
+// 	}
+
+// 	tr.Debug << "structures from pool" << ct_in << " structure retrieved from stage2-files "
+// 					 << ct_read << " start structs: " << start_decoys.size() << std::endl;
+// 	if ( start_decoys.size() != decoys().size() ) {
+// 		tr.Warning << "[WARNING] why do we have a different number of decoys in pool and start_decoys ? " << std::endl;
+// 	}
+	///write flags and broker-file
+	if ( start_decoys.size() ) {
+		numeric::random::random_permutation( start_decoys, RG ); //permute to get rid of high fluctuation in acceptance rate
+		batch.set_has_silent_in();
+		core::io::silent::SilentFileData sfd;
+		for ( SilentStructVector::const_iterator
+						it = start_decoys.begin(); it != start_decoys.end(); ++it ) {
+			sfd.add_structure( **it );
+		}
+		sfd.write_all( batch.silent_in() );
+
+
+		utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+		broker << "\nUSE_INPUT_POSE\n"
+					 << "CLAIMER StartStructClaimer\n"
+			     << "PERTURB " << option[ iterative::perturb_resampling ] << std::endl
+					 << "END_CLAIMER\n\n"
+					 << "CLAIMER JumpClaimer\n"
+					 << "END_CLAIMER\n\n" << std::endl;
+
+
+		utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+		flags << "-abinitio::skip_stages 1 " << std::endl;
+	} else {
+		tr.Warning << "[WARNING] no stage2 decoys found ! " << std::endl;
+	}
+
+	//compute nstruct such that we get the usual amount of total structures
+	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*start_decoys.size() ) ) );
+	mem_tr << "IterativeBase::gen_resample_stage2 end" << std::endl;
+}
+
+void IterativeBase::gen_enumerate_pairings( Batch& batch ) {
+	if ( option[ iterative::enumerate::Naccept ]() < (int) total_accepts() ) return;
+	if ( option[ iterative::enumerate::skip_half ]() && bEnumeratedLastTime_ ) {
+		bEnumeratedLastTime_ = false;
+		return;
+	}
+	tr.Info << "enumerate pairings\n ";
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	runtime_assert( broker.good() );
+
+	if ( option[ iterative::enumerate::broker ].user() ) {
+		utility::io::izstream enum_broker( option[ iterative::enumerate::broker ]() );
+		if ( !enum_broker.good() ) throw ( utility::excn::EXCN_FileNotFound
+			( "-iterative::enumerate::broker: File "
+				+std::string( option[ iterative::enumerate::broker ]())+" not found! ") );
+		std::string line;
+		while ( getline( enum_broker, line ) ) broker << line << std::endl;
+	} else { //no explicit enumerate file is given
+		std::string frag_ss_file( batch.dir() + "psipred_ss2.dat" );
+		std::string pairings_file( batch.dir() + "pairings_guess.dat" );
+
+		using namespace core::fragment;
+		FragSetOP frags_s = FragmentIO(
+																	 option[ OptionKeys::abinitio::number_3mer_frags ]()
+		).read_data( option[ in::file::frag3 ] );
+
+		guess_pairings_from_secondary_structure( *frags_s, pairings_file, frag_ss_file );
+		broker << "CLAIMER TemplateJumpClaimer\n"
+					 << "RANDOM_SHEETS 2\n"
+					 << "SS_INFO " << frag_ss_file << "\n"
+					 << "PAIRING_FILE " << pairings_file << "\n"
+					 << "END_CLAIMER" << std::endl;
+	} //if enumerate::broker
+	bEnumeratedLastTime_ = true;
+}
+
+void IterativeBase::gen_resample_fragments( Batch& batch ) {
+	using namespace core::fragment;
+	ConstantLengthFragSet frags_9mer( 9 ); //steal good old 9mers
+	ConstantLengthFragSet frags_3mer( 3 ); //steal good old 9mers
+	mem_tr << "IterativeBase::gen_resample_fragments start" << std::endl;
+
+	Size ct( 1 );
+	Size const max_frags( 500 );
+	if ( option[ iterative::mix_frags ]() ) {
+		FragSetOP frags_l = FragmentIO(
+		   option[ OptionKeys::abinitio::number_9mer_frags ]()
+	  ).read_data( option[ in::file::frag9 ] );
+		FragSetOP frags_s = FragmentIO(
+		   option[ OptionKeys::abinitio::number_3mer_frags ]()
+	  ).read_data( option[ in::file::frag3 ] );
+		frags_9mer.add( *frags_l );//assuming we really have read 9mers and 3mers.
+		frags_3mer.add( *frags_s );
+	}
+	for ( const_decoy_iterator it = decoys().begin(); it != decoys().end() && ct <= max_frags; ++it, ++ct ) {
+		pose::Pose pose;
+		std::string tag;// = it->decoy_tag();
+		(*it)->fill_pose( pose );
+		steal_constant_length_frag_set_from_pose( pose, frags_9mer );
+		steal_constant_length_frag_set_from_pose( pose, frags_3mer );
+	}
+	std::string file_9mer( batch.dir() + "frags_9mer.dat" ); //using here gzipped files causes weird seg-fault on BG/P
+	std::string file_3mer( batch.dir() + "frags_3mer.dat" );
+	FragmentIO().write_data( file_9mer, frags_9mer );
+	FragmentIO().write_data( file_3mer, frags_3mer );
+
+	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+	flags << "-frag3 " << file_3mer << std::endl
+				<< "-frag9 " << file_9mer << std::endl
+				<< "-abinitio:number_3mer_frags 0" << std::endl
+				<< "-abinitio:number_9mer_frags 0" << std::endl;
+
+	bool rescore( false );
+	if ( stage_ >= STAGE2_RESAMPLING && !scored_core_initialized_
+		&& ( option[ OptionKeys::iterative::scored_ss_core ]() || option[ OptionKeys::iterative::force_scored_region ].user() ) ) {
+		if (  option[ OptionKeys::iterative::force_scored_region ].user() ) {
+			std::ifstream is( option[ OptionKeys::iterative::force_scored_region ]().name().c_str() );
+
+			if (!is.good()) {
+				utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + option[ OptionKeys::iterative::force_scored_region ]().name() + "'" );
+			}
+			loops::LoopsFileIO loop_file_reader;
+			loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format( is, option[ OptionKeys::iterative::force_scored_region ](), false /*no strict checking */, "RIGID" );
+			scored_core_ = loops::Loops( loops );
+		} else {
+			tr.Debug << "use refined secondary structure information to select scored_core " << std::endl;
+			// obtain secondary structure from fragments
+			core::fragment::SecondaryStructure ss_def( frags_9mer, true /*no JustUseCentralResidue */ );
+			//	utility::vector1< bool > loop( ss_def.total_residue(),false );
+			loops::define_scorable_core_from_secondary_structure( ss_def, scored_core_ );
+		}
+		rescore = true;
+	}
+	if ( stage_ >= STAGE2_RESAMPLING && noesy_assign::NoesyModule::cmdline_options_activated() && !scored_core_initialized_ &&
+		decoys().begin() != decoys().end() && (batch.id() > 1 )) {
+		rescore = true;
+		pose::Pose pose;
+		(*decoys().begin())->fill_pose( pose );
+		if ( scored_core_.size() == 0 ) scored_core_.add_loop( 1, pose.total_residue() );
+
+		// due to lazy reassignment protocol this batch might not actually have a noesy-cst file when this it is started.
+		/// need to ggo one batch back...
+
+// 		if ( super_quick_relax_of_centroids_ ) {
+// 			first_noesy_cst_file_ = batch.dir() + "/"+NOESY_CST_FILE_NAME+".filter";
+// 		} else {
+// 			first_noesy_cst_file_ = batch.dir()+"/"+NOESY_CST_FILE_NAME+".centroid.filter";
+// 		}
+// 		bool const fullatom( pose.is_fullatom() );
+// 		if ( fullatom ) first_noesy_fa_cst_file_ = batch.dir()+"/"+NOESY_CST_FILE_NAME+".filter";
+		if ( super_quick_relax_of_centroids_ ) {
+			first_noesy_cst_file_ = current_noesy_sampling_file_+".filter";
+		} else {
+			first_noesy_cst_file_ = current_noesy_sampling_file_+".filter.centroid";
+		}
+		bool const fullatom( pose.is_fullatom() );
+		if ( fullatom ) first_noesy_fa_cst_file_ = current_noesy_sampling_file_+".filter";
+
+
+	}
+	if ( rescore ) set_scored_core();
+	mem_tr << "IterativeBase::gen_resample_fragments end" << std::endl;
+}
+
+void IterativeBase::reassign_noesy_data( Batch& batch ) {
+	if ( !noesy_assign::NoesyModule::cmdline_options_activated() ) return;
+	if ( batch.id() == 1 || ( total_proposed() < (Size) option[ iterative::delay_noesy_reassign ]() ) ) return; //don't do this at very beginning
+	//this takes a while... make sure that backedup version of archive is up-to-date
+	manager().save_archive();
+
+	mem_tr << "IterativeBase reassign_noesy_data start" << std::endl;
+
+	SilentStructs calibration_decoys;
+	Size const n_decoys( option[ iterative::limit_decoys_for_noe_assign ] );
+	std::ostringstream hash_string;
+	hash_string << "NO_POOL " << std::endl;
+	if ( decoys().size() < n_decoys && decoys().size() < nstruct() ) {
+		calibration_decoys = decoys();
+		hash_string << "ONLY "<< decoys().size() << std::endl;
+	} else {
+		//  this seems to help a little bit: double cut take 90 decoys by score and then the lowest 30 by cst-score
+		// not a big difference though...
+		// bullshit probably helped because of other bug
+		// 		typedef std::list< std::pair< core::Real, core::io::silent::SilentStructOP > > Sorted_decoys;
+		// 		Sorted_decoys cst_sorted_decoys;
+		// 		Size ct1( 1 );
+		// 		for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end() && ct1 <= 3*n_decoys; ++ct1, ++it ) {
+		// 			cst_sorted_decoys.push_back( std::make_pair( (*it)->get_energy( "noesy_autoassign_cst" ), *it ));
+		// 		}
+		// 		cst_sorted_decoys.sort();
+		// 		cst_sorted_decoys.reverse();
+
+		// 		Size ct2 ( 1 );
+		// 		for ( Sorted_decoys::const_iterator it = cst_sorted_decoys.begin(); it != cst_sorted_decoys.end() && ct2 <= n_decoys; ++ct2, ++it ) {
+		// 			calibration_decoys.push_back( it->second );
+		// 			hash_string << it->second->decoy_tag() << std::endl;
+		// 		}
+
+		Size ct2 ( 1 );
+		for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end() && ct2 <= n_decoys; ++ct2, ++it ) {
+			calibration_decoys.push_back( *it );
+			hash_string << (*it)->decoy_tag() << std::endl;
+		}
+	}
+
+	size_t hash_val( hasher( hash_string.str() ) );
+	if ( hash_val == noesy_assign_hash_ ) {
+		tr.Info << "do not create new noesy assignment since low-energy structures have not changed..." << std::endl;
+		return; // don't do anything
+	}
+
+	noesy_assign_hash_ = hash_val;
+
+	if ( !noesy_module_ ) {
+		noesy_module_ = new protocols::noesy_assign::NoesyModule( target_sequence_ );
+	} else {
+		noesy_module_->reset();
+	}
+
+	noesy_assign::PeakAssignmentParameters& params( *noesy_assign::PeakAssignmentParameters::get_nonconst_instance() );
+
+	std::string scheme( option[ iterative::auto_assign_scheme ]() );
+	if ( scheme == "CONST" ) {
+		tr.Info << " reassign NOESY data with cmd-line settings " << std::endl;
+		bCombineNoesyCst_ = stage() <= STAGE2_RESAMPLING;
+	} else if ( scheme == "ADAPT1" ) {
+		tr.Info << " ADAPT1 scheme selected for NOESY data: " << std::endl;
+		tr.Info << "stage1-3: cycle7 - nodistViol - combine-cst " << std::endl;
+		tr.Info << "stage4: cycle7 - [dcut = -iterative:dcut ] - do not combine " << std::endl;
+		if ( stage() < STAGE2_RESAMPLING ) {
+			params.dcut_ = -1;
+			bCombineNoesyCst_ = true;
+		} else {
+			params.dcut_ = option[ iterative::dcut ]();
+			bCombineNoesyCst_ = false;
+		}
+	} else {
+		utility_exit_with_message("unknown auto_assign_scheme for NOESY data: choose ADAPT1 or CONST" + scheme);
+	}
+	//	if ( stage() < STAGE2_RESAMPLING ) {
+	params.show_on_tracer();
+	{
+		utility::io::ozstream param_out( batch.dir()+"/README_noe_auto_assign", std::ios::app );
+		params.show( param_out );
+	}
+
+		// 	} else {
+		// 		Size cycle ( std::min( (Size) 7, (Size) std::ceil( noesy_assign_float_cycle_ ) ) );
+		// 		params.set_cycle( cycle );
+		// 		utility::io::ozstream cycle_file( batch.dir()+"/README_noe_auto_assign" );
+		// 		cycle_file << noesy_assign_float_cycle_ << " " << cycle;
+		// 		noesy_assign_float_cycle_ += 0.5;
+		// 	}
+
+
+	noesy_module_->assign(
+		utility::DereferenceIterator< SilentStructs >( calibration_decoys.begin() ),
+		utility::DereferenceIterator< SilentStructs >( calibration_decoys.end() )
+	);
+
+	core::pose::Pose aPose;
+	if ( reference_pose_ ) aPose = *reference_pose_;
+	else 	core::pose::make_pose_from_sequence(
+				aPose,
+				target_sequence_,
+				*( chemical::ChemicalManager::get_instance()->residue_type_set( core::chemical::FA_STANDARD ))
+	);
+
+	std::string cst_file( batch.dir()+"/"+NOESY_CST_FILE_NAME );
+	std::string cst_centroid_file( cst_file + ".centroid");
+
+	noesy_module_->generate_constraint_files( aPose, cst_file, cst_centroid_file, 5 );
+	noesy_module_->generate_constraint_files( aPose, cst_file+".filter", cst_file+".filter.centroid", 2 );
+
+	noesy_module_->write_assignments( batch.dir()+"/NOE_out.dat" );
+
+	current_noesy_sampling_file_ = cst_file;
+	if ( evaluate_local() ) {
+		constraints_additional::ConstraintEvaluatorOP cst =
+			new constraints_additional::ConstraintEvaluator( "noesy_autoassign_cst", current_noesy_sampling_file_+".filter" );
+		cst->set_combine_ratio( /*bCombineNoesyCst_*/ false ? 2 : 1 );
+		add_evaluation( cst, get_weight( "noesy_autoassign_cst" ) );
+		rescore();
+	}
+	prof_show();
+	mem_tr << "IterativeBase reassign_noesy_data end" << std::endl;
+}
+
+
+void IterativeBase::gen_noe_assignments( Batch& batch ) {
+	if ( !noesy_assign::NoesyModule::cmdline_options_activated() ) return;
+	bool bCombine( bCombineNoesyCst_ );
+	mem_tr << "IterativeBase::gen_noe_assignments start" << std::endl;
+
+	if ( batch.id() > 1 && stage() > CEN2FULLATOM && first_noesy_cst_file_ == "n/a"  ) {
+		//now we are in a new instance of IterativeBase... need to recover the state data
+		for ( Size back = batch.id() - 1; back >= 1; --back ) {
+			Batch last_batch( back );
+			runtime_assert( last_batch.id() < batch.id() );
+			current_noesy_sampling_file_ = last_batch.dir()+"/"+NOESY_CST_FILE_NAME;
+			if ( utility::file::file_exists( current_noesy_sampling_file_ ) ) break;
+			current_noesy_sampling_file_ = option[ iterative::initial_noe_auto_assign_csts ]();
+		}
+		first_noesy_fa_cst_file_ = current_noesy_sampling_file_+".filter";
+	}
+
+	std::string cst_file( current_noesy_sampling_file_ );
+	std::string cst_centroid_file( cst_file + ".centroid");
+
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	if ( stage() >= CEN2FULLATOM ) { //don't add constraints in early stages... slows down super-quick relax to much...
+		broker << "\nCLAIMER ConstraintClaimer \n"
+					 << "CST_FILE " << cst_file << "\n"
+					 << "NO_CENTROID\n"
+					 << "FULLATOM\n"
+					 << "SKIP_REDUNDANT "<<option[ iterative::skip_redundant_constraints ]() << "\n";
+		if ( bCombine ) broker << "COMBINE_RATIO " << basic::options::option[ basic::options::OptionKeys::constraints::combine ]() << "\n";
+
+		broker << "END_CLAIMER\n" << std::endl;
+	}
+
+	broker << "\nCLAIMER ConstraintClaimer \n"
+				 << "CST_FILE " << cst_centroid_file << "\n"
+				 << "CENTROID\n"
+				 << "SKIP_REDUNDANT "<<option[ iterative::skip_redundant_constraints ]() << "\n";
+		//NO: 			 << "FULLATOM\n"
+	if ( bCombine ) broker << "COMBINE_RATIO " << basic::options::option[ basic::options::OptionKeys::constraints::combine ]() << "\n";
+	broker << "END_CLAIMER\n" << std::endl;
+
+	//if we have "normal constraints" supply them in addition...
+	if ( option[ constraints::cst_file ].user() ) {
+		for ( Size i = 1; i<= option[ constraints::cst_file ]().size(); i++ ) {
+			std::string cst_file( option[ constraints::cst_file ]()[i] );
+			broker << "\nCLAIMER ConstraintClaimer \n"
+						 << "CST_FILE " << cst_file << "\n"
+						 << "CENTROID\n";
+			if ( !option[ constraints::cst_fa_file ].user() ) broker << "FULLATOM\n";
+			broker << "END_CLAIMER\n" << std::endl;
+		}
+	}
+	if ( option[ constraints::cst_fa_file ].user() ) {
+		for ( Size i = 1; i<= option[ constraints::cst_fa_file ]().size(); i++ ) {
+			std::string cst_file( option[ constraints::cst_fa_file ]()[i] );
+			broker << "\nCLAIMER ConstraintClaimer \n"
+						 << "CST_FILE " << cst_file << "\n"
+						 << "NO_CENTROID\n"
+						 << "FULLATOM\n"
+						 << "END_CLAIMER\n" << std::endl;
+		}
+	}
+	mem_tr << "IterativeBase::gen_noe_assignments end" << std::endl;
+}
+
+void IterativeBase::guess_pairings_from_secondary_structure(
+	core::fragment::FragSet const& frags,
+	std::string const& out_pairings_file,
+	std::string const& out_frag_ss_file
+) const {
+	core::fragment::SecondaryStructure ss_def( frags, true /*no JustUseCentralResidue */ );
+	utility::io::ozstream out_ss( out_frag_ss_file );
+	ss_def.write_psipred_ss2( out_ss, target_sequence() ); // << ss_def << std::endl;
+
+	loops::Loops strands;
+	int last_sheet_pos=-1;
+	int new_sheet_start=0;
+
+	//find all sheets longer than 3 residues and put them into "strands"
+	for ( int pos=1; pos <= (int) ss_def.total_residue(); pos++ ) {
+		if ( ss_def.sheet_fraction( pos ) >= 0.7 ) {
+			if ( pos - 1 != last_sheet_pos ) {
+				if ( new_sheet_start > 0 && (last_sheet_pos - new_sheet_start >= 3 )) {
+					strands.push_back( new_sheet_start, last_sheet_pos );
+				}
+				new_sheet_start = pos;
+			}
+			last_sheet_pos = pos;
+		}
+	}
+	// last detected strand is still not pushed into "strands"
+	if ( new_sheet_start > 0 && (last_sheet_pos - new_sheet_start >= 3 ) ) {
+		strands.push_back( new_sheet_start, last_sheet_pos );
+	}
+	tr.Debug << "secondary structure in current fragset reveals following beta-strands: " << std::endl << strands;
+
+	//create pairings between all possible strand pairings
+	utility::io::ozstream os(out_pairings_file);
+	for ( Size i1 = 1; i1 <= strands.size(); i1++ ) {
+		for ( Size i2 = i1+1; i2 <= strands.size(); i2++ ) {
+			for ( Size pos1=strands[i1].start(); pos1<=strands[i1].stop(); pos1++ ) {
+				for ( Size pos2=strands[i2].start(); pos2<=strands[i2].stop(); pos2++ ) {
+					if ( pos2-pos1 > 25 ) {
+						os << pos1 << " " << pos2 << " A 1" << std::endl;
+						os << pos1 << " " << pos2 << " A 2" << std::endl;
+						os << pos1 << " " << pos2 << " P 1" << std::endl;
+						os << pos1 << " " << pos2 << " P 2" << std::endl;
+					}
+				}
+			}
+		}
+	}
+
+}
+
+void IterativeBase::set_scored_core() {
+
+	scored_core_initialized_ = true;
+	if ( evaluate_local() ) {
+		add_core_evaluator( scored_core_ , "_scored_core");
+		set_weight( "score", 0.0 );
+		set_weight( "score_scored_core", 1.0 );
+// 		remove_evaluation( "score_core4" );
+// 		remove_evaluation( "rms_core4" );
+
+// 		remove_evaluation( "score_core3" );
+// 		remove_evaluation( "rms_core3" );
+
+// 		remove_evaluation( "score_core2" );
+// 		remove_evaluation( "rms_core2" );
+
+	} else {
+		//cancel all running batches...
+		manager().cancel_batches_previous_to( manager().last_batch_id(), false /*don't allow reading of old decoys...*/ );
+
+		//make sure that archive gets re-evaluated...
+		set_evaluate_local( true );//set this temporarily
+
+		utility::vector1< Size> selection;
+		scored_core_.get_residues( selection );
+
+		core::scoring::ScoreFunctionOP scfxn( NULL );
+		std::string score_name;
+		std::string score_patch;
+
+		//check fullatom:
+		core::pose::Pose a_pose;
+		(*decoys().begin())->fill_pose( a_pose );
+		bool const fullatom( a_pose.is_fullatom() );
+
+		if ( !fullatom ) {
+			score_name=option[ iterative::cen_score]();
+			score_patch=option[ iterative::cen_score_patch ]();
+		} else {
+			score_name=option[ iterative::fa_score ]();
+			score_patch=option[ iterative::fa_score_patch ]();
+		}
+		if ( score_patch != "NOPATCH" ) {
+			scfxn = core::scoring::ScoreFunctionFactory::create_score_function( score_name, score_patch );
+		} else {
+			scfxn = core::scoring::ScoreFunctionFactory::create_score_function( score_name );
+		}
+
+		//constraints are done via patches
+		bool chainbreaks_in_patch( scfxn->get_weight( scoring::linear_chainbreak ) > 0.0 );
+		core::Real extra_chainbreak_weight( basic::options::option[ basic::options::OptionKeys::jumps::increase_chainbreak ] );
+		if ( !chainbreaks_in_patch ) { //if chainbreak is not patched .. set it
+			core::Real lin_wgt( 4.0/3.0 * extra_chainbreak_weight );
+			core::Real overlap_wgt( 1.0 * extra_chainbreak_weight );
+			core::Real quad_wgt( 1.0 * extra_chainbreak_weight );
+			tr.Info << "no chainbreaks specified in  " << score_patch << ",..."
+							<< " set chainbreaks to " << lin_wgt << " and "
+							<< overlap_wgt <<" for linear- and overlap-chainbreak, respectively" << std::endl;
+			scfxn->set_weight( scoring::chainbreak, quad_wgt );
+			scfxn->set_weight( scoring::linear_chainbreak, lin_wgt );
+			scfxn->set_weight( scoring::overlap_chainbreak, overlap_wgt );
+		}
+
+		// this needs work in EvaluatedArchive to make sure the right constraint files are used...
+		if ( noesy_assign::NoesyModule::cmdline_options_activated() ) {
+			std::string const cst_file( fullatom ? first_noesy_fa_cst_file_ : first_noesy_cst_file_ );
+			Real weight( get_weight( "noesy_autoassign_cst" ) );
+			if ( weight < 0.01 )  {
+				tr.Error << "why is the noesy_autoassign_cst weight 0 ? set it to 5" << std::endl;
+				weight = 5.0;
+			}
+			add_evaluation( new constraints_additional::ConstraintEvaluator( "noesy_autoassign_cst", cst_file ), weight );
+		}
+
+		if ( super_quick_relax_of_centroids_ ) {
+			std::string score_patch=option[ iterative::fa_score_patch ]();
+			if ( score_patch != "NOPATCH" ) {
+				scfxn = core::scoring::ScoreFunctionFactory::create_score_function( "empty", score_patch );
+			} else {
+				scfxn = core::scoring::ScoreFunctionFactory::create_score_function( "empty" );
+			}
+			// cannot compute this from fullatom-pose... keep energy term around in rescore...
+			// 			std::string cen_score = option[ iterative::cen_score ]();
+			// 			core::scoring::ScoreFunctionOP cen_scfxn( NULL );
+			// 			cen_scfxn = core::scoring::ScoreFunctionFactory::create_score_function( cen_score );
+			// 			add_evaluation( new evaluation::TruncatedScoreEvaluator( "prefa_centroid_score", selection, cen_scfxn, true /*fullname*/ ), 1.0 );
+
+			std::string fa_score = option[ iterative::fa_score ]();
+			core::scoring::ScoreFunctionOP fa_scfxn( NULL );
+			fa_scfxn = core::scoring::ScoreFunctionFactory::create_score_function( fa_score );
+			add_evaluation( new simple_filters::TruncatedScoreEvaluator( "score_fa", selection, fa_scfxn, true /*fullname*/ ), option[ iterative::fullatom_after_quickrelax_weight ]() );
+
+		}
+		set_scorefxn( scfxn );
+		add_evaluation( new simple_filters::TruncatedScoreEvaluator( "_final", selection, scfxn ), 1.0 );
+
+
+		rescore();
+		save_to_file();
+		set_scorefxn( NULL );
+		remove_evaluation("score_final");
+		set_weight("score_final",1.0); // need this for further scoring
+		set_evaluate_local( false );//have set this above to true, it was temporarily
+	} //no local evaluation
+}
+
+void IterativeBase::add_fullatom_flags( jd2::archive::Batch& batch ) {
+	if ( first_fullatom_batch_ > batch.id() ) first_fullatom_batch_ = batch.id();
+	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+	//these are many.... should there be some input file ?
+	//	flags << "@../flags_fullatom" << std::endl;
+	flags << "@"<< option[ iterative::flags_fullatom ]() << std::endl;
+
+	if ( option[ constraints::cst_fa_file ].user() ) {
+		utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+		broker << "\nCLAIMER ConstraintClaimer \n"
+					 << "CMD_FLAG\n"
+					 << "FULLATOM\n"
+					 << "NO_CENTROID\n";
+		broker << "END_CLAIMER\n"
+					 << std::endl;
+	}
+	if ( option[ constraints::cst_file ].user() ) {
+		utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+		broker << "\nCLAIMER ConstraintClaimer \n"
+					 << "CMD_FLAG\n"
+			//					 << "FULLATOM\n"
+			//			if ( option[ constraints::cst_fa_file ].user() ) {
+					 << "CENTROID \n"
+					 << "END_CLAIMER\n"
+					 << std::endl;
+	}
+
+}
+
+void IterativeBase::gen_cen2fullatom( Batch& batch ) {
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	broker << "\nUSE_INPUT_POSE\n"
+				 << "CLAIMER StartStructClaimer\n"
+				 << "END_CLAIMER\n\n"
+				 << "CLAIMER JumpClaimer\n"
+				 << "END_CLAIMER\n\n" << std::endl;
+
+
+	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+	flags << "-abinitio::skip_stages 1 2 3 4" << std::endl;
+
+	add_fullatom_flags( batch );
+	io::silent::SilentStructOPs start_decoys;
+	std::copy( decoys().begin(), decoys().end(), std::back_inserter( start_decoys ) );
+
+	if ( start_decoys.size() ) {
+		batch.set_has_silent_in();
+		core::io::silent::SilentFileData sfd;
+		for ( core::io::silent::SilentStructOPs::const_iterator
+						it = start_decoys.begin(); it != start_decoys.end(); ++it ) {
+			sfd.add_structure( **it );
+		}
+		sfd.write_all( batch.silent_in() );
+	}
+
+	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*start_decoys.size() ) ) );
+
+}
+
+void IterativeBase::gen_cen2fullatom_non_pool_decoys( Batch& batch ) {
+	using namespace core::io::silent;
+	utility::io::ozstream broker( batch.broker_file(), std::ios::app );
+	broker << "\nUSE_INPUT_POSE\n"
+				 << "CLAIMER StartStructClaimer\n"
+				 << "END_CLAIMER\n\n"
+				 << "CLAIMER JumpClaimer\n"
+				 << "END_CLAIMER\n\n" << std::endl;
+
+
+	utility::io::ozstream flags( batch.flag_file(), std::ios::app );
+	flags << "-abinitio::skip_stages 1 2 3 4" << std::endl;
+	add_fullatom_flags( batch );
+
+	//count total decoys
+	Size total( 0 );
+	for ( ArchiveManager::BatchList::const_iterator it = manager().batches().begin(); it != manager().batches().end(); ++it ) {
+		if ( it->id() >= first_fullatom_batch_ ) break;
+		if ( !it->has_silent_in() ) continue;
+		total += it->decoys_returned();
+		tr.Debug << "harvest old decoys for safety hatch: batch " << it->id() << " " << it->decoys_returned() << " " << total << std::endl;
+	}
+
+	Real score_cut_per_batch( option[ OptionKeys::iterative::safety_hatch_scorecut ] );
+	//now go thru batches and select percentage_per_batch structures randomly from the pool created by score_cut_per_batch...
+	//use score_final for this ? or can we use EvaluatedArchive methods to get a reasonable score ???
+	//ACHTUNG:  need also to know final centroid batch id...
+	SilentStructOPs start_decoys;
+	for ( ArchiveManager::BatchList::const_iterator it = manager().batches().begin(); it != manager().batches().end(); ++it ) {
+		Real percentage_per_batch( 1.0*batch.nstruct() / (1.0*total) );
+		if ( it->id() >= first_fullatom_batch_ ) break;
+		if ( !it->has_silent_in() ) continue; //usually only the resampling decoys are interesting...
+		if ( !it->decoys_returned() ) continue; //avoid looking for empty files
+		//		it->silent_out();
+		SilentFileData sfd;
+			std::list< std::pair< core::Real, SilentStructOP > > score_cut_decoys;
+		Size ct( 0 );
+		tr.Debug << "read and score decoys in " << it->silent_out() << "..." << std::endl;
+		sfd.read_file( it->silent_out() );
+		for ( SilentFileData::iterator sit=sfd.begin(), esit=sfd.end(); sit!=esit; ++sit ) {
+			std::string tag = sit->decoy_tag();
+			sit->set_decoy_tag( "harvest_"+batch.batch()+"_"+ObjexxFCL::lead_zero_string_of( ++ct, 6 ) );
+
+			//note this does nothing but return *it, if b_evaluate_incoming_decoys_ is false
+			core::io::silent::SilentStructOP pss = evaluate_silent_struct( *sit );
+			score_cut_decoys.push_back( std::make_pair( select_score( pss ), pss ) );
+		}
+		score_cut_decoys.sort();
+		tr.Debug << "select " << percentage_per_batch*100 << "% from batch from the lowest scoring " << score_cut_per_batch*100 << "% of structures" << std::endl;
+
+		// if we have less structures below score cut than what we want to harvest,.... take them all
+		while ( score_cut_per_batch < percentage_per_batch ) {
+			Size ind_max( static_cast< Size > ( score_cut_decoys.size()*score_cut_per_batch ) );
+			for ( std::list< std::pair< core::Real, core::io::silent::SilentStructOP > >::const_iterator sit = score_cut_decoys.begin();
+						sit != score_cut_decoys.end(); ++sit ) {
+				start_decoys.push_back( sit->second );
+				if ( --ind_max <= 1 ) break;
+			}
+			percentage_per_batch-=score_cut_per_batch;
+		}
+		// for the remaining structures we want to harvest, they clearly will be less than what the score-cut yields... choose randomly...
+		if ( percentage_per_batch > 0.01 ) {
+			Size ind_max( static_cast< Size > ( score_cut_decoys.size()*score_cut_per_batch ) );
+			for ( std::list< std::pair< core::Real, core::io::silent::SilentStructOP > >::const_iterator sit = score_cut_decoys.begin();
+						sit != score_cut_decoys.end(); ++sit ) {
+				if ( RG.uniform() < ( percentage_per_batch / score_cut_per_batch ) ) {
+					start_decoys.push_back( sit->second );
+				}
+				if ( --ind_max <= 1 ) break;
+			}
+		}
+	}
+
+	if ( start_decoys.size() ) {
+		batch.set_has_silent_in();
+		core::io::silent::SilentFileData sfd;
+		Size ct( 0 );
+		for ( core::io::silent::SilentStructOPs::const_iterator
+						it = start_decoys.begin(); it != start_decoys.end(); ++it ) {
+			if ( ++ct > batch.nstruct() ) break;
+			sfd.add_structure( **it );
+		}
+		sfd.write_all( batch.silent_in() );
+	}
+
+	batch.nstruct() = std::max( 1, int( 1.0*batch.nstruct() / ( 1.0*start_decoys.size() ) ) );
+
+}
+
+/// ============================================================================
+/// -----------           methods to compute stuff from archive     ------------
+/// -----------             these may be called from idle()         ------------
+/// ============================================================================
+
+PairingStatisticsOP IterativeBase::compute_beta_topology() {
+	using namespace ObjexxFCL;
+	PairingStatisticsOP beta_topol;
+
+	//use -jumps::max_strand_gap_allowed 10 -jumps:contact_score 0.2
+	if ( !option[ jumps::max_strand_gap_allowed ].user() ) {
+		option[ jumps::max_strand_gap_allowed ].def( 10 );
+	}
+	if ( !option[ jumps::contact_score ].user() ) {
+		option[ jumps::contact_score ].def( 0.2 );
+	}
+
+	beta_topol = new PairingStatistics;
+	PairingStatistics::ModelFreq model_freq;
+	core::Size ct( 1 );
+	for ( const_decoy_iterator it = decoys().begin(); it != decoys().end(); ++it, ++ct ) {
+		pose::Pose pose;
+		std::string tag;// = it->decoy_tag();
+		(*it)->fill_pose( pose );
+
+		// get strand pairings
+		core::scoring::dssp::StrandPairingSet strand_pairings( pose );
+
+		tag = right_string_of( ct, 4, '0');
+		beta_topol->add_topology( strand_pairings, tag );
+		model_freq[ tag.substr(0, 4) ] += 1;
+
+	} // for decoys
+	// set score terms
+	beta_topol->compute_model_weights( model_freq );
+	return beta_topol;
+}
+
+
+void get_core( toolbox::DecoySetEvaluation& eval, core::Real cutoff, loops::Loops& rigid ) {
+	ObjexxFCL::FArray1D_double weights( eval.n_atoms(), 1.0 );
+	eval.superimpose();
+	eval.wRMSD( cutoff, 0.00001, weights );
+
+	utility::vector1< Real > result;
+	eval.rmsf( result );
+
+	rigid.clear();
+	for ( Size i=1; i<=result.size(); ++i ) {
+		if ( result[ i ] < cutoff ) rigid.add_loop( loops::Loop(  i, i ), 5 );
+	}
+	tr.Debug << "make rigid with cutoff " << cutoff << "  " << std::endl << rigid << std::endl;
+}
+
+
+void IterativeBase::compute_cores() {
+	tr.Info << "compute converged regions " << std::endl;
+	core::Size const opt_nstruct( option[ iterative::rmsf_nstruct ]() );
+	core::Size const nstruct( std::min( int( opt_nstruct ), int( decoys().size() ) ));
+
+	if ( nstruct==0 ) return;
+	toolbox::DecoySetEvaluation eval;
+	eval.reserve( nstruct );
+	Size nres(decoys().begin()->nres());
+	//	Size ct( 1 );
+	//for ( const_decoy_iterator iss = decoys().begin(); iss != decoys().end(); ++iss, ++ct ) {
+	//		if ( ct > nstruct ) break;
+	//		pose::Pose pose;
+	//		(*iss)->fill_pose( pose );
+	//		eval.push_back( pose );
+	//		nres = pose.total_residue();
+	//	}
+	eval.push_back_CA_xyz_from_silent_file( nstruct, decoys().begin(), decoys().end(), false );
+
+	loops::Loops old_core2 = core2_;
+	loops::Loops old_core3 = core3_;
+	loops::Loops old_core4 = core4_;
+
+	get_core( eval, 2, core2_ );
+	get_core( eval, 3, core3_ );
+	get_core( eval, 4, core4_ );
+
+	//	if ( old_core2 != core2_ ) add_core_evaluator( core2_, "_core2" );
+	//	if ( old_core3 != core3_ ) add_core_evaluator( core3_, "_core3" );
+	//	if ( old_core4 != core4_ ) add_core_evaluator( core4_, "_core4" );
+
+	if ( evaluate_local() ) {
+		set_weight( "score_core2", 0.0 );
+		set_weight( "score_core3", 0.0 );
+		set_weight( "score_core4", 0.0 );
+		set_weight( "score", 0.0 );
+
+		if ( ( 1.0*core2_.loop_size() / nres ) > option[ iterative::min_core_fraction_to_score ] ) {
+			set_weight( "score_core2", 1.0);
+			return;
+		}
+
+		if ( ( 1.0*core3_.loop_size() / nres ) > option[ iterative::min_core_fraction_to_score ] ) {
+			set_weight( "score_core3", 1.0);
+			return;
+		}
+
+		if ( ( 1.0*core4_.loop_size() / nres ) > option[ iterative::min_core_fraction_to_score ] ) {
+			set_weight( "score_core4", 1.0);
+			return;
+		}
+
+		set_weight( "score", 1.0 );
+	}
+	tr.Info << "finished computing converged regions" << std::endl;
+}
+
+void IterativeBase::add_core_evaluator( loops::Loops const& core, std::string const& core_tag ) {
+	utility::vector1< Size> selection;
+	core.get_residues( selection );
+	if ( reference_pose_ ) add_evaluation( new simple_filters::SelectRmsdEvaluator( reference_pose_, selection, core_tag ) );
+	add_evaluation( new simple_filters::TruncatedScoreEvaluator( core_tag, selection ) );
+	core.write_loops_to_file( name()+"/"+core_tag+".rigid", "RIGID" ); //so we have them for other evaluations
+}
+
+
+
+
+// void IterativeBase::restore_from_file( std::string const& dirname ) {
+// 	EvaluatedArchive::restore_from_file( dirname );
+// 	utility::io::izstream stage( dirname+"/IterationStage" );
+// 	int bla;
+// 	stage >> bla;
+// 	stage_ = IterationStage( bla );
+// }
+
+// void IterativeBase::save_to_file( std::string const& dirname ) {
+// 	EvaluatedArchive::save_to_file( dirname );
+// 	utility::io::ozstream stage( dirname+"/IterationStage" );
+// 	stage << stage_;
+// }
+
+void IterativeBase::restore_status( std::istream& is ) {
+	EvaluatedArchive::restore_status( is );
+	int bla; std::string tag;
+	is >> tag >> bla;
+	runtime_assert( tag == "IterationStage:" );
+	stage_ = IterationStage( bla );
+	tr.Info << "restored iteration stage: " << stage_ << std::endl;
+	is >> tag >> bla;
+	runtime_assert( tag == "first_batch_this_stage:");
+	first_batch_this_stage_ = bla;
+	is >> tag >> bla;
+	runtime_assert( tag == "first_fullatom_batch:" );
+	first_fullatom_batch_ = bla;
+	compute_cores();
+	is >> tag;
+	if ( is.good() && tag == "SCORED_CORE:" ) {
+		loops::LoopsFileIO loop_file_reader;
+		loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format( is, name()+"STATUS file", false /*no strict checking */, "RIGID" );
+		scored_core_ = loops::Loops( loops );
+		scored_core_initialized_ = true;
+	}
+	is >> tag;
+	if ( is.good() && tag == "NOESY_CYCLE:" ) {
+		is >> noesy_assign_float_cycle_;
+	}
+	is >> tag;
+	if ( is.good() && tag == "NOESY_FIRST_CST:" ) {
+		is >> first_noesy_cst_file_;
+	}
+	is >> tag;
+	if ( is.good() && tag == "NOESY_FIRST_FA_CST:" ) {
+		is >> first_noesy_fa_cst_file_;
+	}
+	is >> tag;
+	if ( is.good() && tag == "NOESY_CURRENT_CST:" ) {
+		is >> current_noesy_sampling_file_;
+	}
+	bCombineNoesyCst_ = stage() < STAGE2_RESAMPLING; //will be overwritten in next reassign NOESY... take guess until then...
+}
+
+void IterativeBase::save_status( std::ostream& os ) const {
+	EvaluatedArchive::save_status( os );
+	os << "IterationStage: " << stage_;
+	os << "   first_batch_this_stage: " << first_batch_this_stage_;
+	os << "   first_fullatom_batch: " << first_fullatom_batch_;
+	os << std::endl;
+	if ( scored_core_initialized_ ) {
+		os << "SCORED_CORE:\n";
+		scored_core_.write_loops_to_stream( os, "RIGID" );
+		os << "END_SCORED_CORE" << std::endl;
+	}
+	os << "NOESY_CYCLE: " << noesy_assign_float_cycle_ << std::endl;
+	os << "NOESY_FIRST_CST: " << first_noesy_cst_file_ << std::endl;
+	os << "NOESY_FIRST_FA_CST: " << first_noesy_fa_cst_file_ << std::endl;
+	os << "NOESY_CURRENT_CST: " << current_noesy_sampling_file_ << std::endl;
+}
+
+
+void IterativeBase::setup_default_evaluators() {
+	Parent::setup_default_evaluators();
+	add_evaluation( new simple_filters::JumpNrEvaluator );
+}
+
+
+void IterativeBase::cluster() {
+	using namespace protocols::cluster;
+	//	using namespace basic::options::OptionKeys;
+	using namespace basic::options::OptionKeys::cluster;
+	using namespace basic::options;
+	using namespace toolbox;
+
+	//jump out if inactive
+	if ( !option[ iterative::cluster ]() ) return;
+	if ( decoys().size() < 50 ) return;
+  if ( min_diversity_list_[ stage() ] == 0 ) return;
+
+	mem_tr << "IterativeBase cluster-start" << std::endl;
+
+	SilentStructs kept_decoys;
+	toolbox::ClusterOptions cluster_opts( false /*don't change tags to c.XXX.NNN */ );
+	cluster_opts.cluster_radius = min_diversity_list_[ stage() ];
+	cluster_opts.keep_center = false; /* keep the lowest energy structures -- not interested in the most central structure */
+
+ //read CA coords into DecoySetEvaluation
+  DecoySetEvaluation CA_set;
+	CA_set.push_back_CA_xyz_from_silent_file( decoys().size(),
+		utility::DereferenceIterator< SilentStructs >( decoys().begin() ),
+		utility::DereferenceIterator< SilentStructs >( decoys().end() ),
+		false /*don't store plain energies */
+	);
+
+	//we have our special score... so need to gather this information
+	utility::vector1< core::Real > all_energies;
+	all_energies.reserve( decoys().size() );
+	for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+		all_energies.push_back( select_score( *it ) );
+	}
+	CA_set.set_all_energies( all_energies );
+
+	//now do the clustering
+	toolbox::cluster_silent_structs( CA_set,
+  	utility::DereferenceIterator< SilentStructs >( decoys().begin() ),
+		utility::DereferenceIterator< SilentStructs >( decoys().end() ),
+		kept_decoys,
+		cluster_opts
+	);
+
+	//how many were removed ?
+	Size n_removed = decoys().size() - kept_decoys.size();
+	tr.Info << "removed " << n_removed << " structures.   " << kept_decoys.size() << " structures remaining after clustering " << std::endl;
+	decoys()=kept_decoys;
+	count_removed_structures( n_removed );
+
+	//finally...
+	mem_tr << "IterativeBase cluster-end" << std::endl;
+}
+
+
+
+///@detail before we can apply score-fxn we have to add extra data: RDC, NOES, (not supported yet: PCS, ... )
+void IterativeBase::score( pose::Pose & pose ) const {
+
+	//to speed up things we cache the RDC data in the archive
+	if ( basic::options::option[ basic::options::OptionKeys::in::file::rdc ].user() ) {
+		if ( !rdc_data_ ) rdc_data_ = new core::scoring::ResidualDipolarCoupling;
+		core::scoring::store_RDC_in_pose( rdc_data_, pose );
+	}
+
+	//set fullatom or centroid constraints
+	// remove cutpoints from pose used to setup the constraint-set--> at least we will not have higher atom-indices than
+	// in standard residues (which causes seg-faults, down the line.. ). Some constraints will be slightly messed up... but can't be that bad...
+	tr.Trace << "checking for constraints when rescoring" << std::endl;
+	using namespace core::scoring::constraints;
+	bool const fullatom( pose.is_fullatom() );
+	if ( basic::options::option[ basic::options::OptionKeys::constraints::cst_file ].user() || basic::options::option[ basic::options::OptionKeys::constraints::cst_fa_file ].user() ) {
+		core::pose::Pose cutfree_pose( pose );
+		protocols::jumping::JumpSample jumps( pose.fold_tree() );
+		jumps.remove_chainbreaks( cutfree_pose );
+
+		if ( !fullatom && basic::options::option[ basic::options::OptionKeys::constraints::cst_file ].user() ) {
+			if ( !cst_data_ ) {
+				std::string filename( core::scoring::constraints::get_cst_file_option() );
+				tr.Info << "read centroid constraint set " << filename << std::endl;
+				cst_data_ = ConstraintIO::get_instance()->read_constraints( filename, new ConstraintSet, cutfree_pose );
+			}
+			pose.constraint_set( cst_data_ );
+		} else if ( fullatom ) {
+			if ( basic::options::option[ basic::options::OptionKeys::constraints::cst_fa_file ].user() ) {
+				if ( !cst_fa_data_ ) {
+					std::string filename( core::scoring::constraints::get_cst_fa_file_option() );
+					tr.Info << "read fullatom constraint set " << filename << std::endl;
+				cst_fa_data_ = ConstraintIO::get_instance()->read_constraints( filename, new ConstraintSet, cutfree_pose );
+				}
+			} else if ( basic::options::option[ basic::options::OptionKeys::constraints::cst_file ].user() ) {
+				if ( !cst_fa_data_ ) {
+					std::string const filename( core::scoring::constraints::get_cst_file_option() );
+					tr.Info << "read centroid constraint set " << filename  << " for fullatom " << std::endl;
+					cst_fa_data_ = ConstraintIO::get_instance()->read_constraints( filename, new ConstraintSet, cutfree_pose );
+				}
+			}
+			if ( cst_fa_data_ ) cutfree_pose.constraint_set( cst_fa_data_ );
+		} //fullatom
+
+
+		core::pose::Pose chainbreak_pose( pose );
+		jumping::JumpSample js( pose.fold_tree() );
+		js.add_chainbreaks( chainbreak_pose );
+		scoring::ScoreFunction chainbreaks_scfxn;
+		scoring::ScoreFunction no_chainbreak_scorefxn( scorefxn() );
+		chainbreaks_scfxn.set_weight(  scoring::linear_chainbreak, no_chainbreak_scorefxn.get_weight(  scoring::linear_chainbreak ) );
+		chainbreaks_scfxn.set_weight(  scoring::overlap_chainbreak, no_chainbreak_scorefxn.get_weight(  scoring::overlap_chainbreak ) );
+		chainbreaks_scfxn.set_weight(  scoring::chainbreak, no_chainbreak_scorefxn.get_weight(  scoring::chainbreak ) );
+		no_chainbreak_scorefxn.set_weight(  scoring::linear_chainbreak, 0);
+		no_chainbreak_scorefxn.set_weight(  scoring::overlap_chainbreak, 0);
+		no_chainbreak_scorefxn.set_weight(  scoring::chainbreak, 0);
+		//mjo commenting out 'val' because it is unused and causes a warning
+		//core::Real val = scorefxn( cutfree_pose );
+		//mjo commenting out 'chains' because it is unused and causes a warning
+		//core::Real chains = chainbreaks_scfxn( chainbreak_pose );
+		//score
+		scorefxn()( pose ); //get the weights into the pose
+		pose.energies().total_energies() = cutfree_pose.energies().total_energies();
+		pose.energies().total_energies()[ scoring::linear_chainbreak ] = chainbreak_pose.energies().total_energies()[ scoring::linear_chainbreak ];
+		pose.energies().total_energies()[ scoring::overlap_chainbreak ] = chainbreak_pose.energies().total_energies()[ scoring::overlap_chainbreak ];
+		pose.energies().total_energies()[ scoring::chainbreak ] = chainbreak_pose.energies().total_energies()[ scoring::chainbreak ];
+		if ( tr.Trace.visible() ) {
+			scorefxn().show( tr.Trace, pose );
+		}
+	} else {
+		scorefxn()( pose );
+	}
+}
+
+
+/// Helper functions
+
+void IterativeBase::collect_alternative_decoys( SilentStructs primary_decoys, std::string alternative_decoy_file, SilentStructVector& output_decoys ) {
+
+	tr.Info << "resample_stage2 \n";
+	typedef std::map< std::string, utility::vector1< std::string > > SourceFiles;
+	typedef std::map< std::string, utility::vector1< core::io::silent::SilentStructOP > > AlternativeDecoys;
+
+	SourceFiles sources;
+	AlternativeDecoys alternative_decoys;
+	Size ct_in( 0 );
+
+	//to find the stage2 structures collect first all tags for a specific file
+	for ( const_decoy_iterator it = primary_decoys.begin(); it != primary_decoys.end(); ++it ) {
+		runtime_assert( (*it)->has_comment( TAG_IN_FILE ) );
+		std::string tag( (*it)->get_comment( TAG_IN_FILE ) );
+		utility::file::FileName file( (*it)->get_comment( SOURCE_FILE ) );
+		std::string stage2_file( file.path()+"/"+alternative_decoy_file );
+
+		//creates map <filename> <list of tags>
+		sources[ stage2_file ].push_back( tag );
+		alternative_decoys[ stage2_file ].push_back( (*it) );
+		++ct_in;
+	}
+
+	//read selected structures from each file
+	Size ct_read( 0 );
+
+	for ( SourceFiles::const_iterator it = sources.begin(); it != sources.end(); ++it ) {
+		/// it->first is filename, it->second are all tags collected for this file
+		io::silent::SilentFileData sfd;
+		try { //read structures
+			sfd._read_file( it->first, it->second, true /*throw exceptions */ );
+			if ( sfd.size() > it->second.size() ) {
+				tr.Warning << "[WARNING] multiple decoys with same tag detected in file " << it->first << std::endl;
+			}
+			copy( sfd.begin(), sfd.end(), std::back_inserter( output_decoys ) );
+			ct_read += sfd.size();
+		} catch ( utility::excn::EXCN_IO& excn ) { //ERROR
+			tr.Warning << "[WARNING] Problem reading silent-file " << it->first << " for " << it->second.size() << " structures " << std::endl;
+			excn.show( tr.Warning );
+			tr.Warning << std::endl;
+			tr.Warning << "use the respective structures in the pool as starting structure instead" << std::endl;
+			copy( alternative_decoys[ it->first ].begin(), alternative_decoys[ it->first ].end(), std::back_inserter( output_decoys ) );
+			ct_read += alternative_decoys[ it->first ].size();
+		}
+	}
+
+	tr.Debug << "structures from pool" << ct_in << " structure retrieved from " << alternative_decoy_file << "-files "
+					 << ct_read << " start structs: " << output_decoys.size() << std::endl;
+	if ( output_decoys.size() != primary_decoys.size() ) {
+		tr.Warning << "[WARNING] why do we have a different number of decoys in pool and start_decoys ? " << std::endl;
+	}
+}
+
+void
+IterativeBase::test_broker_settings( Batch const& batch ) {
+	tr.Debug << "test broker settings...." << std::endl;
+	OptionCollection vanilla_options( option );
+  option.load_options_from_file( batch.flag_file() );
+	try {
+		topology_broker::TopologyBrokerOP topology_broker = new topology_broker::TopologyBroker();
+		topology_broker::add_cmdline_claims( *topology_broker );
+		tr.Debug << "setting of broker::setup  ";
+		utility::vector1< std::string > files( option[ OptionKeys::broker::setup ]() );
+		std::copy( files.begin(), files.end(), std::ostream_iterator<std::string>( tr.Debug, " "));
+	} catch ( utility::excn::EXCN_Exception &excn ) {  // clean up options and rethrow
+		tr.Error << "[ERROR] problems with broker setup in " << batch.all_broker_files() << " aborting... " << std::endl;
+		// excn.show( tr.Error );
+		option = vanilla_options;
+		throw ( EXCN_Archive( batch.all_broker_files() + " contains errors: " + excn.msg() ) );
+	}
+	option = vanilla_options;
+}
+
+
+///@detail load decoys into archive from -archive:input_pool or so
+void IterativeBase::init_from_decoy_set( core::io::silent::SilentFileData const& sfd ) {
+	//make bogus batch that contains init-file
+
+	//if non-local evaluation we need to add score_final to decoys --- switch temporarily to local evaluation
+	bool b_old_eval_state( evaluate_local() );
+	if ( !b_old_eval_state ) {
+		tr.Debug << "switch to local evaluation for reading of initial pool" << std::endl;
+		set_evaluate_local( true );//set this temporarily
+		add_evaluation( new simple_filters::ScoreEvaluator( "_final", scorefxn_non_const() ), 1.0 );
+	}
+
+	//read decoys and evaluate
+	ArchiveBase::init_from_decoy_set( sfd );
+
+	//switch back to non-local evaluation if applicable
+	if ( !b_old_eval_state ) {
+		remove_evaluation( "score_final" );
+		set_weight( "score_final", 1.0 );
+		set_evaluate_local( b_old_eval_state );
+	}
+}
+
+
+} //abinitio
+} //protocols
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/IterativeBase.hh patched/rosetta_source/src/protocols/abinitio/IterativeBase.hh
--- vanilla/rosetta_source/src/protocols/abinitio/IterativeBase.hh	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/IterativeBase.hh	2012-06-10 16:12:40.474040713 +0200
@@ -17,9 +17,10 @@
 //#include <protocols/abinitio/IterativeAbrelax.fwd.hh>
 
 // Package Headers
-#include <protocols/jd2/archive/EvaluatedArchive.hh>
+#include <protocols/jd2/archive/NormalizedEvaluatedArchive.hh>
 #include <protocols/jd2/archive/ArchiveManager.fwd.hh>
 
+
 // Project Headers
 #include <protocols/abinitio/PairingStatistics.fwd.hh>
 #include <protocols/loops/Loops.hh>
@@ -32,8 +33,9 @@
 // AUTO-REMOVED #include <protocols/noesy_assign/NoesyModule.hh>
 
 // Utility headers
-// AUTO-REMOVED #include <utility/vector1.hh>
-
+//for dynamic patching
+#include <utility/options/keys/FileVectorOptionKey.hh>
+#include <utility/io/ozstream.fwd.hh>
 
 // Third-party Headers
 #include <boost/functional/hash.hpp>
@@ -49,8 +51,8 @@
 namespace protocols {
 namespace abinitio {
 
-class IterativeBase : public jd2::archive::EvaluatedArchive {
-	typedef jd2::archive::EvaluatedArchive Parent;
+class IterativeBase : public jd2::archive::NormalizedEvaluatedArchive {
+	typedef jd2::archive::NormalizedEvaluatedArchive Parent;
 	typedef utility::vector1< core::io::silent::SilentStructOP > SilentStructVector;
 public:
 	enum IterationStage {
@@ -58,6 +60,8 @@ public:
 		TOPO_RESAMPLING,
 		PURE_TOPO_RESAMPLING,
 		STAGE2_RESAMPLING,
+		NOESY_PHASEII_TOPO,
+		NOESY_PHASEII_S2_RESAMPLING,
 		CEN2FULLATOM,
 		//		CEN2FULLATOM_NON_POOL_DECOYS,
 		LAST_CENTROID_START = CEN2FULLATOM,
@@ -72,11 +76,17 @@ public:
 	///@brief archive is finished when at last stage
   virtual bool finished() const { return stage_ >= finish_stage_; };
 
+	///@brief do initializing work that requires fully setup object here
+	virtual void initialize();
+
 	///@brief where to stop ?
 	void set_finish_stage( IterationStage setting ) {
 		finish_stage_ = setting;
 	}
 
+	///@brief  calls increment_stage() if appropriate
+	void test_for_stage_end();
+
 	///@brief overloaded to make input decoys appear the same as decoys coming from batches
 	virtual void init_from_decoy_set( core::io::silent::SilentFileData const& sfd );
 
@@ -111,19 +121,20 @@ public:
 	// cen2fullatom-stage ( stage5 )
 	virtual void gen_evaluation_output( jd2::archive::Batch& batch, bool fullatom = false );
 
+	// cen2fullatom-stage ( stage5 )
+	virtual void gen_dynamic_patches( jd2::archive::Batch& batch );
 
-// ///@brief need to get these from the IterativeCentroid to IterativeFullatom at end of stage5 ;
+	// ///@brief need to get these from the IterativeCentroid to IterativeFullatom at end of stage5 ;
 // 	std::string const& first_noesy_fa_cst_file() const { return first_noesy_fa_cst_file_; }
 protected:
  	//void set_first_noesy_fa_cst_file( std::string setting ) { first_noesy_fa_cst_file_ = setting; }
 
 // 	core::Real noesy_assign_float_cycle() const { return noesy_assign_float_cycle_; }
 	void set_noesy_assign_float_cycle( core::Real setting ) { noesy_assign_float_cycle_ = setting; }
-	bool scored_core_initialized_;
+	bool never_switched_noe_filter_;
 	loops::Loops scored_core_;
-	///@brief even in centroid mode the end of abinitio will have a fast relax... enables cs-score and noe-assignment
-	bool super_quick_relax_of_centroids_;
 
+	bool super_quick_relax_of_centroids() const { return super_quick_relax_of_centroids_; }
 	/// ------------- helper functions to be used from generate_batch() --------------------
 
 	void gen_resample_topologies( jd2::archive::Batch& batch );
@@ -166,8 +177,19 @@ protected:
 		return cen_score_patch_;
 	}
 
+	///@brief this is set from score::atom_pair_constraint of the pool-scorefunction
+	core::Real overall_cstfilter_weight() const {
+		return overall_cstfilter_weight_;
+	}
+
+	///@brief this is set from score::atom_pair_constraint of the pool-scorefunction
+	void set_overall_cstfilter_weight( core::Real setting ) {
+		overall_cstfilter_weight_ = setting;
+	}
+
 	///OBSOLET cores are computed by compute_cores() in idle()
 	loops::Loops const& core( core::Size i ) {
+		if ( i == 1 ) { return core15_; };
 		if ( i == 2 ) { return core2_; };
 		if ( i == 3 ) { return core3_; };
 		if ( i == 4 ) { return core4_; };
@@ -198,7 +220,7 @@ protected:
 	}
 
 	void test_broker_settings( jd2::archive::Batch const& batch );
-
+	void setup_filter_cst( core::Real weight );
 private:
 
 	///@brief score a pose with Pool-Scoring function (adds necessary data to pose (RDC, constraints,  etc ) )
@@ -212,17 +234,21 @@ private:
 	///@brief [OBSOLET] add score_coreX and rms_coreX evaluators (and columns) with 0.0 weight
 	void add_core_evaluator( loops::Loops const& core, std::string const& core_tag );
 
-	///@brief restrict scoring to core-regions
-	void set_scored_core();
-
-	///@brief  calls increment_stage() if appropriate
-	void test_for_stage_end();
-
 	///@brief necessary steps to go to next stage... e.g., saving snapshot of archive
 	void increment_stage();
 
 	void read_noisy_assing_data_from_last_batch();
 
+	void replace_noesy_filter_constraints();
+	void rescore_nonlocal_archive();
+
+	void setup_autoNOE();
+	void do_dynamic_patching(
+			jd2::archive::Batch& batch,
+			utility::io::ozstream& flags,
+			std::string score,
+			utility::options::FileVectorOptionKey const& key
+	) const;
 private:
 	///  ----------------- -- private data members -- --------------------
 
@@ -245,6 +271,7 @@ private:
 	core::Size last_accepted_decoys_in_idle_;
 
 	///core-regions --- used in IterativeFullatom for the "rigid-core" sampling step...
+	loops::Loops core15_;
 	loops::Loops core2_;
 	loops::Loops core3_;
 	loops::Loops core4_;
@@ -271,6 +298,9 @@ private:
 	std::string fa_score_;
 	std::string fa_score_patch_;
 
+	///@brief this is set from score::atom_pair_constraint of the pool-scorefunction
+	core::Real overall_cstfilter_weight_;
+
 	std::string target_sequence_; //read from in:file:fasta in c'stor
 
 	protocols::noesy_assign::NoesyModuleOP noesy_module_;
@@ -288,17 +318,22 @@ private:
 	boost::hash<std::string> hasher;
 
 	///@brief even in centroid mode the end of abinitio will have a fast relax... enables cs-score and noe-assignment
-	//bool super_quick_relax_of_centroids_;
 	bool recover_centroid_structure_for_pool_;
 
 	std::string chemshift_column_;
 	bool bDoBetaJumping_;
 
+	///@brief even in centroid mode the end of abinitio will have a fast relax... enables cs-score and noe-assignment
+	bool super_quick_relax_of_centroids_;
+
+
+	///@brief use the score_variations from EvaluatedArchive to determine new sampling weights
+	bool use_dynamic_weights_for_sampling_;
+
 	///@brief cache some of the experimental data so we don't reload from file for each evaluation
 	mutable core::scoring::ResidualDipolarCouplingOP rdc_data_; //need to cache this to avoid reading RDC file each time...
 	mutable core::scoring::constraints::ConstraintSetOP cst_data_;
 	mutable core::scoring::constraints::ConstraintSetOP cst_fa_data_;
-
 	/// ------------------ register cmdline options ---------------------------
 
 private:
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/IterativeFullatom.cc patched/rosetta_source/src/protocols/abinitio/IterativeFullatom.cc
--- vanilla/rosetta_source/src/protocols/abinitio/IterativeFullatom.cc	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/IterativeFullatom.cc	2012-06-10 16:12:40.477039965 +0200
@@ -84,8 +84,15 @@ using namespace jd2::archive;
 IterativeFullatom::IterativeFullatom()
 	: IterativeBase( "fullatom_pool" )
 {
+	perturb_start_structures_ = option[ iterative::perturb_fa_resampling ];
+}
+
+void IterativeFullatom::initialize() {
+	Parent::initialize();
+	// --- setup scorefxn
 	set_stage( LAST_CENTROID_START );
 	set_finish_stage( FINISHED );
+	test_for_stage_end();
 	mem_tr << "before setup fa-score function" << std::endl;
 
 	core::scoring::ScoreFunctionOP scorefxn =
@@ -93,9 +100,7 @@ IterativeFullatom::IterativeFullatom()
 
 	// if local evaluation done by cmdline_cst evaluator
 	set_scorefxn( scorefxn );
-	perturb_start_structures_ = option[ iterative::perturb_fa_resampling ];
 
-	mem_tr << "after setup fa-score function" << std::endl;
 	//Base class sets chainbreak scores as convenience if not in patches..
 	// this will go wrong in fullatom mode, since chainbreaks not returned ... remove here
 	if ( !evaluate_local() ) {
@@ -103,17 +108,30 @@ IterativeFullatom::IterativeFullatom()
 		remove_evaluation( "overlap_chainbreak" );
 
 		if ( noesy_assign::NoesyModule::cmdline_options_activated() ) {
-			set_weight( "noesy_autoassign_cst", option[ iterative::fapool_noesy_cst_weight ]() );
+			set_weight( "noesy_autoassign_cst", option[ iterative::fapool_noesy_cst_weight ]()*overall_cstfilter_weight());
 		}
 		if ( option[ iterative::fapool_chemicalshift_weight ].user() ) {
 			set_weight( chemshift_column(), option[ iterative::fapool_chemicalshift_weight ]() );
 		}
+	} else { //evaluate local
+		set_weight( "score", 1.0 );
+		set_weight( "atom_pair_constraint", 0 ); //this is now done via FILTER mechanism of ConstraintClaimer only !
+		if ( std::abs( scorefxn->get_weight( scoring::atom_pair_constraint ) - overall_cstfilter_weight() ) > 0.1 ) {
+			set_overall_cstfilter_weight( scorefxn->get_weight( scoring::atom_pair_constraint ) );
+			setup_filter_cst( overall_cstfilter_weight() );
+		}
+		scorefxn->set_weight( scoring::atom_pair_constraint, 0 );
+
+		set_weight( "rdc", scorefxn->get_weight( scoring::rdc ) );
+		scorefxn->set_weight( scoring::rdc, 0 );
+
+		set_scorefxn( scorefxn );
 	}
 	set_noesy_assign_float_cycle( option[ iterative::fapool_first_noesy_cycle_nr ]() );
-	scored_core_initialized_ = true;
-	if ( super_quick_relax_of_centroids_ ) {
-		set_weight( "score_fa", 1.0 );
+	if ( super_quick_relax_of_centroids() ) {
+		set_weight( "score_fa", evaluate_local() ? 0.0 : 1.0 );
 		set_weight( "prefa_centroid_score", 0.0 );
+		set_weight( "prefa_clean_score3", 0.0 );
 	}
 }
 
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/IterativeFullatom.hh patched/rosetta_source/src/protocols/abinitio/IterativeFullatom.hh
--- vanilla/rosetta_source/src/protocols/abinitio/IterativeFullatom.hh	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/IterativeFullatom.hh	2012-06-10 16:12:40.479074643 +0200
@@ -44,10 +44,15 @@ namespace protocols {
 namespace abinitio {
 
 class IterativeFullatom : public IterativeBase {
+	typedef IterativeBase Parent;
 public:
 	static void register_options();
 
   IterativeFullatom();
+
+///@brief do initializing work that requires fully setup object here
+	virtual void initialize();
+
 	virtual bool ready_for_batch() const;
 
 	virtual void generate_batch();
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/MembraneAbinitio.cc patched/rosetta_source/src/protocols/abinitio/MembraneAbinitio.cc
--- vanilla/rosetta_source/src/protocols/abinitio/MembraneAbinitio.cc	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/MembraneAbinitio.cc	2012-06-10 16:12:40.483039795 +0200
@@ -111,7 +111,7 @@ using namespace basic::options::OptionKe
 
 /*!
 @detail call this:
-MembraneAbinitio::register_options() before protocols::init::init().
+MembraneAbinitio::register_options() before devel::init().
  Derived classes that overload this function should also call Parent::register_options()
 */
 
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/PairingStatistics.cc patched/rosetta_source/src/protocols/abinitio/PairingStatistics.cc
--- vanilla/rosetta_source/src/protocols/abinitio/PairingStatistics.cc	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/PairingStatistics.cc	2012-06-10 16:12:40.486040774 +0200
@@ -112,6 +112,7 @@ PairingStatEntry::PairingStatEntry( core
 bool PairingStatEntry::add_pairing( core::scoring::dssp::StrandPairing const& new_strand, Model const& id ) {
   bool success( true );
   if ( models_.size() ) {
+		//queries 'mergeable'
     success = strand_pairing_.merge( new_strand, true /*do_merge */);
   } else {
     strand_pairing_ = new_strand;
@@ -132,16 +133,49 @@ bool PairingStatEntry::has_model( std::s
 	return false;
 }
 
+bool PairingStatEntry::operator==( PairingStatEntry const& other) const {
+	return strand_pairing_.mergeable( other.pairing() );
+}
+
+bool PairingStatEntry::operator!=( PairingStatEntry const& other) const {
+	return !strand_pairing_.mergeable( other.pairing() );
+}
+
+bool _MergableEntries::operator() (core::scoring::dssp::StrandPairing const& p1, core::scoring::dssp::StrandPairing const& p2) const {
+	return p1.mergeable( p2 );
+}
+
+void PairingStatistics::add_entry(core::scoring::dssp::StrandPairing const& ps, Model const& id ) {
+	StatEntries::iterator itentry = entries_.find( ps );
+	bool merged( false );
+	if ( itentry != entries_.end() ) {
+		//			tr.Trace << "found that it matches with " << itentry->first << std::endl;
+		merged = itentry->second.add_pairing( ps, id );
+		//			if (!merged) tr.Trace << "strangely couldn't merge the matched one..."<< std::endl;
+		//			else tr.Trace << "new merged strand is " << itentry->second.pairing() << std::endl;
+		core::scoring::dssp::StrandPairing const& key( itentry->first );
+		core::scoring::dssp::StrandPairing const& new_pairing( itentry->second.pairing() );
+		if ( merged && ( !entries_.key_eq()( new_pairing, key ) ) ) {
+			core::scoring::dssp::StrandPairing new_pairing( itentry->second.pairing() ); //need a copy
+			entries_.erase( itentry );
+			add_entry( new_pairing, id );
+			//			entries_[ itentry->second.pairing() ] = itentry->second;
+		}
+	}
+	if ( !merged ) entries_[ ps ]=PairingStatEntry( ps, id );
+		//for ( StatEntries::iterator itentry = entries_.begin(), eitentry = entries_.end();
+		//	  itentry != eitentry && !merged; ++itentry ) {
+		//      merged = itentry->add_pairing( *it, id );
+		//    }
+}
+
 void PairingStatistics::add_topology( core::scoring::dssp::StrandPairingSet const& topology, Model const& id ) {
 	//	if (! topology.size() ) return; //also add empty sets  -- otherwise the modelname floats around and can't be found in this list
   for ( core::scoring::dssp::StrandPairingSet::const_iterator it = topology.begin(), eit = topology.end();
 	it != eit; ++it  ) {
     bool merged ( false );
-    for ( StatEntries::iterator itentry = entries_.begin(), eitentry = entries_.end();
-	  itentry != eitentry && !merged; ++itentry ) {
-      merged = itentry->add_pairing( *it, id );
-    }
-    if ( !merged ) entries_.push_back( PairingStatEntry( *it, id ) );
+		tr.Trace << "adding stand pairing to hash.. " << *it << std::endl;
+		add_entry( *it, id );
   }
   topols_[ id ] = topology;
 }
@@ -170,12 +204,16 @@ PairingStatistics::PairingStatistics( co
 }
 
 core::Real PairingStatistics::strand_weight( core::scoring::dssp::StrandPairing const& pairing ) const {
-  for ( StatEntries::const_iterator entry= entries_.begin(), eentry = entries_.end();
-	entry != eentry; ++entry ) {
-    if ( entry->compatible( pairing ) ) {
-      return entry->weight();
-    }
-  }
+	StatEntries::const_iterator itentry = entries_.find( pairing );
+	if ( itentry != entries_.end() ) {
+		return itentry->second.weight();
+	}
+	//  for ( StatEntries::const_iterator entry= entries_.begin(), eentry = entries_.end();
+	//	entry != eentry; ++entry ) {
+	//    if ( entry->compatible( pairing ) ) {
+	//      return entry->weight();
+	//    }
+	//  }
   return 0.0;
 }
 
@@ -189,6 +227,7 @@ core::Real PairingStatistics::weight( Mo
 }
 
 void PairingStatistics::compute_model_weights(  ModelFreq& model_freq ) {
+	Real const contact_order_weight( basic::options::option[ basic::options::OptionKeys::jumps::contact_score ] );
   std::list< std::pair< core::Real, Model > > weight_list;
   for ( Topologies::const_iterator top = topols_.begin(), etop=topols_.end();
 	top != etop; ++top ) {
@@ -198,19 +237,28 @@ void PairingStatistics::compute_model_we
     for ( core::scoring::dssp::StrandPairingSet::const_iterator pairing = top->second.begin(),
 	    epairing = top->second.end(); pairing != epairing; ++pairing ) {
       // find pairing in entries
-      for ( StatEntries::iterator entry= entries_.begin(), eentry = entries_.end();
-	    entry != eentry; ++entry ) {
-				if ( entry->compatible( *pairing ) ) {
-					Real const contact_order_weight( basic::options::option[ basic::options::OptionKeys::jumps::contact_score ] );
-					Real const weight( 1.0/norm * entry->frequency() * ( entry->size()-1.0
-							+ contact_order_weight * ( std::max( 0, (int) entry->contact_order() - 20)) ) );
-					entry->set_weight( weight );//so far only used for output later on
-					score += weight;
-					break;
-				}
-      }
-    } // added score for each pairing
-    weight_list.push_back( std::make_pair( score, top->first ) );
+			StatEntries::iterator itentry = entries_.find( *pairing );
+			if ( itentry != entries_.end() ) {
+				Real const weight( 1.0/norm * itentry->second.frequency() * ( itentry->second.size()-1.0
+						+ contact_order_weight * ( std::max( 0, (int) itentry->second.contact_order() - 20)) ) );
+				itentry->second.set_weight( weight );//so far only used for output later on
+				score += weight;
+			}
+		}
+//
+//       for ( StatEntries::iterator entry= entries_.begin(), eentry = entries_.end();
+// 	    entry != eentry; ++entry ) {
+// 				if ( entry->compatible( *pairing ) ) {
+// 					Real const contact_order_weight( basic::options::option[ basic::options::OptionKeys::jumps::contact_score ] );
+// 					Real const weight( 1.0/norm * entry->frequency() * ( entry->size()-1.0
+// 							+ contact_order_weight * ( std::max( 0, (int) entry->contact_order() - 20)) ) );
+// 					entry->set_weight( weight );//so far only used for output later on
+// 					score += weight;
+// 					break;
+// 				}
+//       }
+    //} // added score for each pairing
+		weight_list.push_back( std::make_pair( score, top->first ) );
     //		weights_[ top->first ] = score; //also want the score in a map NAME --> score
   } // score for each model/topology
   weight_list.sort();
@@ -318,7 +366,7 @@ std::istream& operator>> ( std::istream&
 std::ostream& operator<< (std::ostream& out, StatEntries const& ps ) {
   for ( StatEntries::const_iterator it = ps.begin(), eit = ps.end();
 				it != eit; ++it ) {
-		out << *it << "\n";
+		out << it->second << "\n";
   }
 	return out;
 }
@@ -327,7 +375,7 @@ std::istream& operator>> (std::istream& 
 	pslist.clear();
 	PairingStatEntry ps;
 	while ( is >> ps ) { //not perfect because it fucks up the stream and the next line...
-		pslist.push_back(  ps );
+		pslist[ ps.pairing() ] = ps;
 	}
 	return is;
 }
@@ -342,6 +390,11 @@ std::istream & operator>>( std::istream 
 		return is;
 	}
 	tr.Trace << " read " << ntops << " topologies from file... " << std::endl;
+	ps.model_weight_.reserve( ntops+10 );
+
+	//cause the hash-container to have at least ntops*3+10 buckets
+	ps.entries_.rehash( ntops*3+10 );
+
 	for ( Size ct_top = 1; ct_top <= ntops; ct_top++ ) {
 		Size nstrand;
 		Real model_weight;
@@ -352,6 +405,7 @@ std::istream & operator>>( std::istream 
 			is.setstate( std::ios_base::failbit );
 			return is;
 		}
+		tr.Debug << "reading strand-topology " << model_ID << " with " << nstrand << " strands... "<<std::endl;
 		core::scoring::dssp::StrandPairingSet sps;
 		for ( Size ct = 1; ct <= nstrand; ct++ ) {
 			core::scoring::dssp::StrandPairing pairing;
@@ -375,23 +429,33 @@ std::istream & operator>>( std::istream 
 			sps.push_back( pairing );
 
 			//maintain also an extra list of all individual strand-pairings found... "PairingStatEntry"
-			bool found( false );
-			for ( StatEntries::iterator try_entry= ps.entries_.begin(), eentry = ps.entries_.end();
-						try_entry != eentry; ++try_entry ) {
-				if ( try_entry->compatible( pairing ) ) {
-					found = true;
-					if ( try_entry->weight() != weight ) {
-						tr.Warning << "inconsistent weights in topology " << *try_entry << std::endl;
-						tr.Warning << "new weight: " << weight << " for strand " << pairing << std::endl;
-					}
-					try_entry->models().push_back( model_ID );
-					break;
-				} // if
-			} //for
-			if ( !found ) {
+			//too slow: option one, skip this condensing test -> check memory
+			// otpion two,
+			//	bool found( false );
+			// for ( StatEntries::iterator try_entry= ps.entries_.begin(), eentry = ps.entries_.end();
+// 						try_entry != eentry; ++try_entry ) {
+// 				if ( try_entry->compatible( pairing ) ) {
+// 					found = true;
+// 					if ( try_entry->weight() != weight ) {
+// 						tr.Warning << "inconsistent weights in topology " << *try_entry << std::endl;
+// 						tr.Warning << "new weight is ignored: " << weight << " for strand " << pairing << "which had weight " << try_entry->weight() << std::endl;
+// 					}
+// 					try_entry->models().push_back( model_ID );
+// 					break;
+// 				} // if
+// 			}
+			StatEntries::iterator try_entry = ps.entries_.find( pairing );
+			if ( try_entry != ps.entries_.end() ) {
+				if ( try_entry->second.weight() != weight ) {
+					tr.Warning << "inconsistent weights in topology " << try_entry->second << std::endl;
+					tr.Warning << "new weight is ignored: " << weight << " for strand " << pairing << "which had weight " << try_entry->second.weight() << std::endl;
+				}
+				try_entry->second.models().push_back( model_ID );
+			} else {
 				PairingStatEntry entry( pairing, model_ID );
+				entry.models().reserve( ntops );
 				entry.set_weight( weight );
-				ps.entries_.push_back( entry );
+				ps.entries_[ pairing ] = entry;
 			}
 
 		} // finished reading this topology
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/PairingStatistics.hh patched/rosetta_source/src/protocols/abinitio/PairingStatistics.hh
--- vanilla/rosetta_source/src/protocols/abinitio/PairingStatistics.hh	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/PairingStatistics.hh	2012-06-10 16:12:40.488042414 +0200
@@ -53,7 +53,7 @@
 
 #include <protocols/abinitio/Templates.fwd.hh>
 #include <utility/vector1.hh>
-
+#include <boost/unordered_map.hpp>
 
 namespace protocols {
 namespace abinitio {
@@ -105,6 +105,8 @@ public:
 
 	friend std::istream& operator>> ( std::istream& is, PairingStatEntry& ps );
 
+	bool operator==(PairingStatEntry const& other) const;
+	bool operator!=(PairingStatEntry const& other) const;
 private:
   ModelList models_;
   core::scoring::dssp::StrandPairing strand_pairing_;
@@ -116,11 +118,38 @@ inline std::ostream& operator<< ( std::o
 	return out;
 }
 
-typedef utility::vector1< PairingStatEntry > StatEntries;
+inline std::size_t hash_value(PairingStatEntry const& val ) {
+	return val.pairing().hash_value();
+}
+inline std::size_t hash_value(core::scoring::dssp::StrandPairing const& val ) {
+	return val.hash_value();
+}
+
+class _MergableEntries {
+public:
+	bool operator() (
+				core::scoring::dssp::StrandPairing const&,
+   			core::scoring::dssp::StrandPairing const&
+	) const;
+};
+class _HashEntry {
+public:
+	std::size_t operator() ( core::scoring::dssp::StrandPairing const& ps) const {
+		return hash_value( ps );
+	}
+};
+
+typedef utility::vector1< PairingStatEntry > StatEntryList;
+typedef boost::unordered_map<
+	core::scoring::dssp::StrandPairing,
+	PairingStatEntry,
+	_HashEntry,
+	_MergableEntries
+	> StatEntries;
 
 class PairingStatistics : public utility::pointer::ReferenceCount {
 public:
-  typedef StatEntries::const_iterator const_iterator;
+	typedef StatEntries::const_iterator const_iterator;
   typedef PairingStatEntry::Model Model; //String ID !!!
   typedef std::map< Model, core::scoring::dssp::StrandPairingSet > Topologies;
   typedef std::map< Model, core::Size > ModelFreq;
@@ -190,7 +219,7 @@ public:
   }
 
 	static void register_options();
-
+	void add_entry(core::scoring::dssp::StrandPairing const& ps, Model const& id );
   void add_topology( core::scoring::dssp::StrandPairingSet const& topology, Model const& id );
 
   void compute_model_weights( ModelFreq& );
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/StrandConstraints.cc patched/rosetta_source/src/protocols/abinitio/StrandConstraints.cc
--- vanilla/rosetta_source/src/protocols/abinitio/StrandConstraints.cc	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/StrandConstraints.cc	2012-06-10 16:12:40.491040356 +0200
@@ -277,7 +277,7 @@ void StrandConstraints::add_pairing( Pai
 StrandConstraints::StrandConstraints( PairingStatistics const& strand_stats ) {
   for ( PairingStatistics::const_iterator it = strand_stats.begin(), eit = strand_stats.end();
 	it != eit; ++it ) {
-    add_pairing( *it );
+    add_pairing( it->second );
   }
   tr.Info << (*this) << std::endl;
 }
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/TemplateJumpSetup.cc patched/rosetta_source/src/protocols/abinitio/TemplateJumpSetup.cc
--- vanilla/rosetta_source/src/protocols/abinitio/TemplateJumpSetup.cc	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/TemplateJumpSetup.cc	2012-06-10 16:12:40.494040686 +0200
@@ -220,7 +220,7 @@ TemplateJumpSetup::clean_jumps( JumpSamp
 		core::scoring::dssp::Pairing target_pairing( target_jumps.get_pairing( (*jump_frame)->start(), (*jump_frame)->stop() ) );
 		bool found( false );
 		for ( PairingStatistics::const_iterator it = strand_stats_->begin(); !found && it != strand_stats_->end(); ++it ) {
-			found =  it->pairing().has_pairing( target_pairing );
+			found =  it->second.pairing().has_pairing( target_pairing );
 		}
 		if ( found ) {
 			filtered_jumps.push_back( target_pairing );//add
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/TemplateJumpSetup.hh patched/rosetta_source/src/protocols/abinitio/TemplateJumpSetup.hh
--- vanilla/rosetta_source/src/protocols/abinitio/TemplateJumpSetup.hh	2012-03-20 19:43:31.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/TemplateJumpSetup.hh	2012-06-10 16:12:40.497040634 +0200
@@ -59,6 +59,9 @@ public:
 	);
 
 	~TemplateJumpSetup();
+	std::string type_name() const {
+		return "TemplateJumpSetup";
+	}
 
 	virtual
   jumping::JumpSample create_jump_sample() const;
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.cc patched/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.cc
--- vanilla/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.cc	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.cc	2012-06-10 16:12:40.499074648 +0200
@@ -0,0 +1,73 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file IterativeAbrelax
+/// @brief iterative protocol starting with abinitio and getting progressively more concerned with full-atom relaxed structures
+/// @detailed
+/// @author Oliver Lange
+
+// Unit Headers
+#include <protocols/abinitio/VarianceStatisticsArchive.hh>
+
+// Package Headers
+#include <core/io/silent/SilentStruct.hh>
+
+// Utility Headers
+#include <basic/Tracer.hh>
+#include <basic/MemTracer.hh>
+#include <numeric/random/random.hh>
+
+
+static basic::Tracer tr("protocols.iterative.VarianceStatistics");
+using basic::mem_tr;
+
+static numeric::random::RandomGenerator RG(410142); // <- Magic number, do not change
+
+using core::Real;
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+
+
+VarianceStatisticsArchive::VarianceStatisticsArchive( std::string name )
+	: insertion_prob_( 0.1 )
+{
+	set_name( name );
+}
+
+
+bool VarianceStatisticsArchive::add_evaluated_structure( core::io::silent::SilentStructOP evaluated_decoy ) {
+	if ( decoys().size() < nstruct() ) {
+		tr.Debug << "added " << evaluated_decoy->decoy_tag() << " to " << name() << std::endl;
+		decoys().insert( decoys().begin(), evaluated_decoy );
+		invalidate_score_variations();
+		return true;
+	}
+
+	if ( RG.uniform() < insertion_prob_ ) { //keep or not ?
+		//replace with random element
+		Size rg_pos( static_cast< int >( RG.uniform() * decoys().size() ) );
+		runtime_assert( rg_pos < decoys().size() && rg_pos >= 0 );
+		SilentStructs::iterator it=decoys().begin();
+		while ( rg_pos-- > 0 ) {
+			++it;
+		}
+		runtime_assert( it != decoys().end() );
+		*it=evaluated_decoy;
+		invalidate_score_variations();
+		return true;
+	}
+
+	return false;
+}
+
+}
+} //abinitio
+} //protocols
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.fwd.hh patched/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.fwd.hh
--- vanilla/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.fwd.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.fwd.hh	2012-06-10 16:12:40.502039647 +0200
@@ -0,0 +1,30 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   protocols/abinito/VarianceStatisticsArchive.fwd.hh
+/// @author Oliver Lange
+
+#ifndef INCLUDED_protocols_abinitio_VarianceStatisticsArchive_fwd_hh
+#define INCLUDED_protocols_abinitio_VarianceStatisticsArchive_fwd_hh
+
+#include <utility/pointer/owning_ptr.fwd.hh>
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+
+class VarianceStatisticsArchive;
+typedef utility::pointer::owning_ptr<VarianceStatisticsArchive> VarianceStatisticsArchiveOP;
+typedef utility::pointer::owning_ptr<VarianceStatisticsArchive const> VarianceStatisticsArchiveCOP;
+
+}
+}
+}
+
+#endif  // INCLUDED_protocols_abinitio_VarianceStatisticsArchive_fwd_hh
diff -rupN vanilla/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.hh patched/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.hh
--- vanilla/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/abinitio/VarianceStatisticsArchive.hh	2012-06-10 16:12:40.505041012 +0200
@@ -0,0 +1,71 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+///
+/// @author Oliver Lange
+/// Archive class to collect structures such that variances of scores can be computed to determine normalized weights
+
+
+#ifndef INCLUDED_protocols_abinitio_VarianceStatisticsArchive_hh
+#define INCLUDED_protocols_abinitio_VarianceStatisticsArchive_hh
+
+// Unit Headers
+//#include <protocols/abinitio/IterativeAbrelax.fwd.hh>
+
+// Package Headers
+#include <protocols/jd2/archive/EvaluatedArchive.hh>
+#include <protocols/jd2/archive/ArchiveManager.fwd.hh>
+#include <protocols/abinitio/VarianceStatisticsArchive.fwd.hh>
+// Project Headers
+#include <core/types.hh>
+#include <core/pose/Pose.fwd.hh>
+
+// Utility headers
+#include <utility/vector1.hh>
+
+// Third-party Headers
+
+//// C++ headers
+
+#include <string>
+
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+
+class VarianceStatisticsArchive : public EvaluatedArchive {
+	typedef EvaluatedArchive Parent;
+	typedef utility::vector1< core::io::silent::SilentStructOP > SilentStructVector;
+
+public:
+	VarianceStatisticsArchive( std::string name );
+
+	virtual bool add_evaluated_structure( core::io::silent::SilentStructOP );
+
+  virtual void generate_batch() {};
+	///@brief overloaded to make input decoys appear the same as decoys coming from batches
+	virtual void init_from_decoy_set( core::io::silent::SilentFileData const& sfd ) {};
+
+	void set_insertion_prob( core::Real setting ) {
+		insertion_prob_ = setting;
+	}
+
+protected:
+
+private:
+	core::Real insertion_prob_;
+};
+
+
+}
+}
+}
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/constraints_additional/CombinedConstraintEvaluatorCreator.hh patched/rosetta_source/src/protocols/constraints_additional/CombinedConstraintEvaluatorCreator.hh
--- vanilla/rosetta_source/src/protocols/constraints_additional/CombinedConstraintEvaluatorCreator.hh	2012-03-20 19:43:45.000000000 +0100
+++ patched/rosetta_source/src/protocols/constraints_additional/CombinedConstraintEvaluatorCreator.hh	2012-06-10 16:12:40.507040118 +0200
@@ -11,8 +11,8 @@
 /// @brief  Header for CombinedConstraintsEvaluatorCreator
 /// @author Matthew O'Meara
 
-#ifndef INCLUDED_protocols_constraints_additional_CombinedConstraintsEvaluatorCreator_hh
-#define INCLUDED_protocols_constraints_additional_CombinedConstraintsEvaluatorCreator_hh
+#ifndef INCLUDED_protocols_constraints_additional_CombinedConstraintEvaluatorCreator_hh
+#define INCLUDED_protocols_constraints_additional_CombinedConstraintEvaluatorCreator_hh
 
 // Unit Headers
 #include <protocols/evaluation/EvaluatorCreator.hh>
diff -rupN vanilla/rosetta_source/src/protocols/constraints_additional/CombinedConstraintEvaluator.hh patched/rosetta_source/src/protocols/constraints_additional/CombinedConstraintEvaluator.hh
--- vanilla/rosetta_source/src/protocols/constraints_additional/CombinedConstraintEvaluator.hh	2012-03-20 19:43:45.000000000 +0100
+++ patched/rosetta_source/src/protocols/constraints_additional/CombinedConstraintEvaluator.hh	2012-06-10 16:12:40.510040688 +0200
@@ -17,8 +17,8 @@
 
 
 
-#ifndef INCLUDED_protocols_evaluation_CombinedConstraintEvaluator_hh
-#define INCLUDED_protocols_evaluation_CombinedConstraintEvaluator_hh
+#ifndef INCLUDED_protocols_constraints_additional_CombinedConstraintEvaluator_hh
+#define INCLUDED_protocols_constraints_additional_CombinedConstraintEvaluator_hh
 
 #ifdef WIN32
 #include <protocols/constraints_additional/ConstraintEvaluator.hh>
diff -rupN vanilla/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluator.cc patched/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluator.cc
--- vanilla/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluator.cc	2012-03-20 19:43:45.000000000 +0100
+++ patched/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluator.cc	2012-06-10 16:12:40.513039669 +0200
@@ -47,6 +47,7 @@
 
 // Utility headers
 #include <basic/Tracer.hh>
+#include <basic/prof.hh>
 // AUTO-REMOVED #include <core/scoring/rms_util.hh>
 #include <utility/file/file_sys_util.hh>
 
@@ -74,7 +75,8 @@ ConstraintEvaluator::ConstraintEvaluator
 		viol_level_ ( viol_level  ),
 		threshold_( threshold ),
 		max_seq_sep_( max_seq_sep ),
-		constraints_combine_ratio_( 1 )
+		constraints_combine_ratio_( 1 ),
+		cst_source_( "n/a" )
 {}
 
 ConstraintEvaluator::ConstraintEvaluator( std::string tag, ConstraintCOPs const& csts, Size viol_level, Real threshold, Size max_seq_sep )
@@ -86,7 +88,8 @@ ConstraintEvaluator::ConstraintEvaluator
 		viol_level_ ( viol_level  ),
 		threshold_( threshold ),
 		max_seq_sep_( max_seq_sep ),
-		constraints_combine_ratio_( 1 )
+		constraints_combine_ratio_( 1 ),
+		cst_source_( "n/a" )
 {
 	constraints_->add_constraints( csts );
 }
@@ -100,7 +103,8 @@ ConstraintEvaluator::ConstraintEvaluator
 		viol_level_ ( viol_level  ),
 		threshold_( threshold ),
 		max_seq_sep_( max_seq_sep ),
-		constraints_combine_ratio_( 1 )
+		constraints_combine_ratio_( 1 ),
+		cst_source_( "n/a" )
 {
 	//check file exists
 	if ( !utility::file::file_exists( file_name_ ) ) {
@@ -128,9 +132,9 @@ void ConstraintEvaluator::prepare_pose( 
 		runtime_assert( utility::file::file_exists( file_name_) ); //it has already been checked... here it is an assertion
 
 		using namespace core::scoring::constraints;
-		ConstraintCreatorCOP new_atom_pair_creator( new constraints_additional::NamedAtomPairConstraintCreator );
-		ConstraintCreatorCOP orig_atom_pair_creator( ConstraintFactory::get_instance()->get_creator( "AtomPair" ) ); // <-- this may actually be a NamedAtomPairConstraintCreator, we don't know; restore it, when done.
-		ConstraintFactory::get_instance()->replace_creator( new_atom_pair_creator );
+		//		ConstraintCreatorCOP new_atom_pair_creator( new constraints_additional::NamedAtomPairConstraintCreator );
+		//		ConstraintCreatorCOP orig_atom_pair_creator( ConstraintFactory::get_instance()->get_creator( "AtomPair" ) ); // <-- this may actually be a NamedAtomPairConstraintCreator, we don't know; restore it, when done.
+		//		ConstraintFactory::get_instance()->replace_creator( new_atom_pair_creator );
 		try{
 			now_cst = ConstraintIO::get_instance()->read_constraints( file_name_, new ConstraintSet, pose );
 			scoring::constraints::ConstraintCOPs added_constraints = now_cst->get_all_constraints();
@@ -152,7 +156,7 @@ void ConstraintEvaluator::prepare_pose( 
 
 		//restore original cst-type
 		//ConstraintIO::get_cst_factory().add_type( orig_atom_pair_type );
-		ConstraintFactory::get_instance()->replace_creator( orig_atom_pair_creator );
+		//ConstraintFactory::get_instance()->replace_creator( orig_atom_pair_creator );
 
 	}
 
@@ -183,11 +187,21 @@ void ConstraintEvaluator::prepare_pose( 
 }
 
 Real ConstraintEvaluator::apply( core::pose::Pose& pose_in ) const {
+	//	PROF_START( basic::TEST1 );
 	pose::Pose pose( pose_in );
+	//	PROF_STOP( basic::TEST1 );
+
+	//	PROF_START( basic::TEST2 );
 	prepare_pose( pose_in, pose );
+	//	PROF_STOP( basic::TEST2 );
+
+	//	PROF_START( basic::TEST3 );
 	ScoreFunction scfxn;
 	scfxn.set_weight( atom_pair_constraint, 1.0 );
-	return scfxn( pose );
+	core::Real score( scfxn( pose ) );
+	//	PROF_STOP( basic::TEST3 );
+
+	return score;
 }
 
 std::string ConstraintEvaluator::name( core::Size i ) const {
@@ -199,14 +213,24 @@ std::string ConstraintEvaluator::name( c
 
 
 void ConstraintEvaluator::apply( core::pose::Pose& pose_in, std::string, core::io::silent::SilentStruct &pss ) const {
+	//	PROF_START( basic::TEST1 );
 	pose::Pose pose( pose_in );
+	//	PROF_STOP( basic::TEST1 );
 
+	//	PROF_START( basic::TEST2 );
 	prepare_pose( pose_in, pose );
+	//	PROF_STOP( basic::TEST2 );
 
+	//	PROF_START( basic::TEST3 );
 	ScoreFunction scfxn;
 	scfxn.set_weight( atom_pair_constraint, 1.0 );
+	core::Real score( scfxn( pose ) );
+	//	PROF_STOP( basic::TEST3 );
 
-	pss.add_energy( name( 1 ), scfxn( pose ) );
+	pss.add_energy( name( 1 ), score );
+	if ( cst_source_ != "n/a" ) {
+		pss.add_string_value( "cst_source_"+name(1), cst_source_ );
+	}
 	//	pss.add_energy( name( 2 ), pose.constraint_set()->show_violations( tr.Info, pose, viol_level_, threshold_ ) );
 	//	return scfxn( pose );
 
diff -rupN vanilla/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluatorCreator.hh patched/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluatorCreator.hh
--- vanilla/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluatorCreator.hh	2012-03-20 19:43:45.000000000 +0100
+++ patched/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluatorCreator.hh	2012-06-10 16:12:40.515077338 +0200
@@ -11,8 +11,8 @@
 /// @brief  Header for ConstraintsEvaluatorCreator
 /// @author Matthew O'Meara
 
-#ifndef INCLUDED_protocols_constraints_additional_ConstraintsEvaluatorCreator_hh
-#define INCLUDED_protocols_constraints_additional_ConstraintsEvaluatorCreator_hh
+#ifndef INCLUDED_protocols_constraints_additional_ConstraintEvaluatorCreator_hh
+#define INCLUDED_protocols_constraints_additional_ConstraintEvaluatorCreator_hh
 
 // Unit Headers
 #include <protocols/evaluation/EvaluatorCreator.hh>
diff -rupN vanilla/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluator.hh patched/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluator.hh
--- vanilla/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluator.hh	2012-03-20 19:43:45.000000000 +0100
+++ patched/rosetta_source/src/protocols/constraints_additional/ConstraintEvaluator.hh	2012-06-10 16:12:40.518039788 +0200
@@ -17,8 +17,8 @@
 
 
 
-#ifndef INCLUDED_protocols_evaluation_ConstraintEvaluator_hh
-#define INCLUDED_protocols_evaluation_ConstraintEvaluator_hh
+#ifndef INCLUDED_protocols_constraints_additional_ConstraintEvaluator_hh
+#define INCLUDED_protocols_constraints_additional_ConstraintEvaluator_hh
 
 #include <protocols/constraints_additional/ConstraintEvaluator.fwd.hh>
 
@@ -79,6 +79,9 @@ public:
 	void set_combine_ratio( core::Size setting ) {
 		constraints_combine_ratio_ = setting;
 	}
+	void set_cst_source( std::string const& tag ) {
+		cst_source_ = tag;
+	}
 
 private:
 	//add constraint set to pose --- ready for scoring
@@ -94,6 +97,7 @@ private:
 	core::Real threshold_;
 	Size max_seq_sep_;
 	Size constraints_combine_ratio_;
+	std::string cst_source_;
 };
 
 
diff -rupN vanilla/rosetta_source/src/protocols/constraints_additional/SequenceCouplingConstraint.cc patched/rosetta_source/src/protocols/constraints_additional/SequenceCouplingConstraint.cc
--- vanilla/rosetta_source/src/protocols/constraints_additional/SequenceCouplingConstraint.cc	2012-03-20 19:43:45.000000000 +0100
+++ patched/rosetta_source/src/protocols/constraints_additional/SequenceCouplingConstraint.cc	2012-06-10 16:12:40.521041090 +0200
@@ -62,7 +62,7 @@ SequenceCouplingConstraint::SequenceCoup
 {}
 
 SequenceCouplingConstraint::SequenceCouplingConstraint(
-	Pose const & pose,
+	Pose const &,
 	Size seqpos1,
 	Size seqpos2,
 	SequenceCouplingOP coupling/* = NULL */
diff -rupN vanilla/rosetta_source/src/protocols/constraints_additional/SequenceCouplingConstraint.hh patched/rosetta_source/src/protocols/constraints_additional/SequenceCouplingConstraint.hh
--- vanilla/rosetta_source/src/protocols/constraints_additional/SequenceCouplingConstraint.hh	2012-03-20 19:43:45.000000000 +0100
+++ patched/rosetta_source/src/protocols/constraints_additional/SequenceCouplingConstraint.hh	2012-06-10 16:12:40.523074395 +0200
@@ -23,6 +23,7 @@
 // AUTO-REMOVED #include <utility/vector1.hh>
 
 #include <core/sequence/SequenceCoupling.hh>
+#include <core/id/AtomID.hh>
 #include <utility/vector1.hh>
 
 
@@ -86,7 +87,11 @@ public:
 	SequenceCouplingCOP sequence_coupling() const;
 
 	virtual core::Size natoms() const { return 0; };
-	virtual	AtomID const & atom( Size const ) const { utility_exit_with_message("SequenceCouplingConstraint is not atom-based!."); }
+	virtual	AtomID const & atom( Size const ) const { 
+		utility_exit_with_message("SequenceCouplingConstraint is not atom-based!."); 
+		return core::id::BOGUS_ATOM_ID;  // required for compilation on Windows
+	}
+	
 	virtual utility::vector1< core::Size > residues() const;
 
 	//virtual ConstraintOP remap_resid( SequenceMapping const & ) const;
diff -rupN vanilla/rosetta_source/src/protocols/constraints_additional/svn-commit.tmp patched/rosetta_source/src/protocols/constraints_additional/svn-commit.tmp
--- vanilla/rosetta_source/src/protocols/constraints_additional/svn-commit.tmp	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/constraints_additional/svn-commit.tmp	2012-06-10 16:12:40.526039914 +0200
@@ -0,0 +1,7 @@
+remove the use of NamedAtomPair constraints from ConstraintEvaluator. 
+It wouldn't work for AmbiguousNMRDistanceRestraints anyway. Hence better take care of atom-name problems 
+the hard way. 
+
+--This line, and those below, will be ignored--
+
+M    ConstraintEvaluator.cc
diff -rupN vanilla/rosetta_source/src/protocols/evaluation/EvaluatorCreator.hh patched/rosetta_source/src/protocols/evaluation/EvaluatorCreator.hh
--- vanilla/rosetta_source/src/protocols/evaluation/EvaluatorCreator.hh	2012-03-20 19:43:50.000000000 +0100
+++ patched/rosetta_source/src/protocols/evaluation/EvaluatorCreator.hh	2012-06-10 16:12:40.529041270 +0200
@@ -11,8 +11,8 @@
 /// @brief  Base class for EvaluatorCreators for the Evaluator load-time factory registration scheme
 /// @author Matthew O'Meara
 
-#ifndef INCLUDED_protocols_evaluator_EvaluatorCreator_hh
-#define INCLUDED_protocols_evaluator_EvaluatorCreator_hh
+#ifndef INCLUDED_protocols_evaluation_EvaluatorCreator_hh
+#define INCLUDED_protocols_evaluation_EvaluatorCreator_hh
 
 // Unit Headers
 #include <protocols/evaluation/EvaluatorCreator.fwd.hh>
diff -rupN vanilla/rosetta_source/src/protocols/evaluation/EvaluatorFactory.cc patched/rosetta_source/src/protocols/evaluation/EvaluatorFactory.cc
--- vanilla/rosetta_source/src/protocols/evaluation/EvaluatorFactory.cc	2012-03-20 19:43:50.000000000 +0100
+++ patched/rosetta_source/src/protocols/evaluation/EvaluatorFactory.cc	2012-06-10 16:12:40.532041013 +0200
@@ -22,7 +22,6 @@
 
 // Project Headers
 #include <core/scoring/ScoreFunction.fwd.hh>
-#include <protocols/jobdist/Jobs.hh>
 #include <utility/vector0.hh>
 
 // Boost Headers
diff -rupN vanilla/rosetta_source/src/protocols/evaluation/EvaluatorFactory.fwd.hh patched/rosetta_source/src/protocols/evaluation/EvaluatorFactory.fwd.hh
--- vanilla/rosetta_source/src/protocols/evaluation/EvaluatorFactory.fwd.hh	2012-03-20 19:43:50.000000000 +0100
+++ patched/rosetta_source/src/protocols/evaluation/EvaluatorFactory.fwd.hh	2012-06-10 16:12:40.534040110 +0200
@@ -11,8 +11,8 @@
 /// @brief  report data to database
 /// @author Matthew O'Meara
 
-#ifndef INCLUDED_protocols_evaluator_EvaluatorFactory_fwd_hh
-#define INCLUDED_protocols_evaluator_EvaluatorFactory_fwd_hh
+#ifndef INCLUDED_protocols_evaluation_EvaluatorFactory_fwd_hh
+#define INCLUDED_protocols_evaluation_EvaluatorFactory_fwd_hh
 
 namespace protocols{
 namespace evaluation{
diff -rupN vanilla/rosetta_source/src/protocols/evaluation/EvaluatorFactory.hh patched/rosetta_source/src/protocols/evaluation/EvaluatorFactory.hh
--- vanilla/rosetta_source/src/protocols/evaluation/EvaluatorFactory.hh	2012-03-20 19:43:50.000000000 +0100
+++ patched/rosetta_source/src/protocols/evaluation/EvaluatorFactory.hh	2012-06-10 16:12:40.537040767 +0200
@@ -12,8 +12,8 @@
 /// @author Matthew O'Meara (mattjomeara@gmail.com)
 
 
-#ifndef INCLUDED_protocols_evaluator_EvaluatorFactory_hh
-#define INCLUDED_protocols_evaluator_EvaluatorFactory_hh
+#ifndef INCLUDED_protocols_evaluation_EvaluatorFactory_hh
+#define INCLUDED_protocols_evaluation_EvaluatorFactory_hh
 
 // Unit Headers
 #include <protocols/evaluation/EvaluatorFactory.fwd.hh>
diff -rupN vanilla/rosetta_source/src/protocols/evaluation/PCA.cc patched/rosetta_source/src/protocols/evaluation/PCA.cc
--- vanilla/rosetta_source/src/protocols/evaluation/PCA.cc	2012-03-20 19:43:50.000000000 +0100
+++ patched/rosetta_source/src/protocols/evaluation/PCA.cc	2012-06-10 16:12:40.540039777 +0200
@@ -51,7 +51,7 @@ using namespace core;
 
 
 /// @brief A function (not a macro) that will not print a square matrix to tr.Debug
-template< class T > void dump_matrix( Size nr, T const & a, basic::Tracer & tr) {}
+template< class T > void dump_matrix( Size, T const &, basic::Tracer & ) {}
 
 /// @brief A function (not a macro) that will print a square matrix to tr.Debug
 template< class T > void dump_matrix_no( Size nr, T const & a, basic::Tracer & tr)
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/ContactCounts.hh patched/rosetta_source/src/protocols/frag_picker/ContactCounts.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/ContactCounts.hh	2012-03-20 19:43:16.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/ContactCounts.hh	2012-06-10 16:12:40.556040299 +0200
@@ -11,8 +11,8 @@
 /// @brief  Contact counts.
 /// @author David E. Kim (dekim@u.washington.edu)
 
-#ifndef INCLUDED_protocols_frag_picker_contact_counts_hh
-#define INCLUDED_protocols_frag_picker_contact_counts_hh
+#ifndef INCLUDED_protocols_frag_picker_ContactCounts_hh
+#define INCLUDED_protocols_frag_picker_ContactCounts_hh
 
 // unit headers
 #include <protocols/frag_picker/ContactCounts.fwd.hh>
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/ContactTypes.hh patched/rosetta_source/src/protocols/frag_picker/ContactTypes.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/ContactTypes.hh	2012-03-20 19:43:16.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/ContactTypes.hh	2012-06-10 16:12:40.559040719 +0200
@@ -11,8 +11,8 @@
 /// @brief  fragment picker type declarations
 /// @author David E. Kim (dekim@u.washington.edu)
 
-#ifndef INCLUDED_protocols_frag_picker_contact_types_hh
-#define INCLUDED_protocols_frag_picker_contact_types_hh
+#ifndef INCLUDED_protocols_frag_picker_ContactTypes_hh
+#define INCLUDED_protocols_frag_picker_ContactTypes_hh
 
 // C++ headers
 #include <string>
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/CustomScoreSelector.fwd.hh patched/rosetta_source/src/protocols/frag_picker/CustomScoreSelector.fwd.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/CustomScoreSelector.fwd.hh	2012-03-20 19:43:16.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/CustomScoreSelector.fwd.hh	2012-06-10 16:12:40.561042159 +0200
@@ -7,12 +7,12 @@
 // (c) For more information, see http://www.rosettacommons.org. Questions about this can be
 // (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
 
-/// @file   protocols/frag_picker/BestTotalScoreSelector.fwd.hh
+/// @file
 /// @brief
-/// @author Dominik Gront (dgront@chem.uw.edu.pl)
+/// @author
 
-#ifndef INCLUDED_protocols_frag_picker_BestTotalScoreSelector_fwd_hh
-#define INCLUDED_protocols_frag_picker_BestTotalScoreSelector_fwd_hh
+#ifndef INCLUDED_protocols_frag_picker_CustomScoreSelector_fwd_hh
+#define INCLUDED_protocols_frag_picker_CustomScoreSelector_fwd_hh
 
 // utility headers
 #include <utility/pointer/access_ptr.hh>
@@ -21,15 +21,15 @@
 namespace protocols {
 namespace frag_picker {
 
-class BestTotalScoreSelector;
+class CustomScoreSelector;
 
-typedef utility::pointer::owning_ptr<BestTotalScoreSelector>
-		BestTotalScoreSelectorOP;
-typedef utility::pointer::owning_ptr<BestTotalScoreSelector const>
-		BestTotalScoreSelectorCOP;
+typedef utility::pointer::owning_ptr<CustomScoreSelector>
+		CustomScoreSelectorOP;
+typedef utility::pointer::owning_ptr<CustomScoreSelector const>
+		CustomScoreSelectorCOP;
 
 } // frag_picker
 } // protocols
 
 
-#endif /* INCLUDED_protocols_frag_picker_BestTotalScoreSelector_FWD_HH */
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/FragmentPicker.cc patched/rosetta_source/src/protocols/frag_picker/FragmentPicker.cc
--- vanilla/rosetta_source/src/protocols/frag_picker/FragmentPicker.cc	2012-03-20 19:43:16.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/FragmentPicker.cc	2012-06-10 16:12:40.565041165 +0200
@@ -85,7 +85,7 @@
 
 #include <ObjexxFCL/format.hh>
 
-#ifdef MULTI_THREADED
+#ifdef USE_BOOST_THREAD
 // Boost headers
 #include <boost/thread.hpp>
 #include <boost/bind.hpp>
@@ -101,7 +101,7 @@ using namespace protocols::frag_picker::
 using namespace basic::options;
 using namespace basic::options::OptionKeys;
 
-//#ifdef MULTI_THREADED
+//#ifdef USE_BOOST_THREAD
 //boost::mutex picker_mutex;
 //#endif
 
@@ -591,7 +591,7 @@ void FragmentPicker::nonlocal_pairs( Siz
 		if (qPosi_to_run[thread].size() >= qPosi_per_thread && thread < max_threads_) ++thread;
 	}
 	utility::vector1<utility::vector1<nonlocal::NonlocalPairOP> > thread_pairs(max_threads_);
-#ifdef MULTI_THREADED
+#ifdef USE_BOOST_THREAD
 	boost::thread_group threads;
 	trPicker.super_mute(true); // lets suppress tracer output when running multi threads
 	for (Size j = 1; j <= max_threads_; ++j) {
@@ -946,7 +946,7 @@ void FragmentPicker::pick_candidates() {
 
 	time_t time_start = time(NULL);
 
-#ifdef MULTI_THREADED
+#ifdef USE_BOOST_THREAD
 	if (max_threads_ > 1) {
 		utility::vector1<utility::vector1<VallChunkOP> > chunks_to_run( max_threads_ );
 		Size valid_chunks_cnt = 0;
@@ -983,7 +983,7 @@ void FragmentPicker::pick_candidates() {
 
 		return;
 	}
-#endif // MULTI_THREADED
+#endif // USE_BOOST_THREAD
 
 	scores::FragmentScoreMapOP empty_map = scores_[1]->create_empty_map();
 
@@ -1295,7 +1295,7 @@ void FragmentPicker::pick_candidates(Siz
 // called in main
 void FragmentPicker::parse_command_line() {
 
-#ifdef MULTI_THREADED
+#ifdef USE_BOOST_THREAD
 	//## multi-threaded?
 	if (option[ frags::j ].user()) max_threads_ = option[ frags::j ]();
 #endif
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFrags.fwd.hh patched/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFrags.fwd.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFrags.fwd.hh	2012-03-20 19:43:13.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFrags.fwd.hh	2012-06-10 16:12:40.568040085 +0200
@@ -10,8 +10,8 @@
 /// @file protocols/frag_picker/nonlocal/NonlocalFrags.fwd.hh
 /// @author David Kim (dekim@u.washington.edu)
 
-#ifndef PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGS_FWD_HH_
-#define PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGS_FWD_HH_
+#ifndef INCLUDED_PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGS_FWD_HH
+#define INCLUDED_PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGS_FWD_HH
 
 #include <utility/pointer/owning_ptr.fwd.hh>
 
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFrags.hh patched/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFrags.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFrags.hh	2012-03-20 19:43:13.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFrags.hh	2012-06-10 16:12:40.570064850 +0200
@@ -10,8 +10,8 @@
 /// @file protocols/frag_picker/nonlocal/NonlocalFrags.hh
 /// @author David Kim (dekim@u.washington.edu)
 
-#ifndef PROTOCOLS_FRAG_PICKER_NONLOCAL_FRAGS_NONLOCALFRAGS_HH_
-#define PROTOCOLS_FRAG_PICKER_NONLOCAL_FRAGS_NONLOCALFRAGS_HH_
+#ifndef INCLUDED_PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGS_HH
+#define INCLUDED_PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGS_HH
 
 // Unit header
 #include <protocols/frag_picker/nonlocal/NonlocalFrags.fwd.hh>
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFragsMain.hh patched/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFragsMain.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFragsMain.hh	2012-03-20 19:43:13.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalFragsMain.hh	2012-06-10 16:12:40.573040680 +0200
@@ -10,8 +10,8 @@
 /// @file protocols/frag_picker/nonlocal/NonlocalFragsMain.hh
 /// @author David Kim
 
-#ifndef PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGSMAIN_HH_
-#define PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGSMAIN_HH_
+#ifndef INCLUDED_PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGSMAIN_HH
+#define INCLUDED_PROTOCOLS_FRAG_PICKER_NONLOCAL_NONLOCALFRAGSMAIN_HH
 
 
 namespace protocols {
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalPair.hh patched/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalPair.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalPair.hh	2012-03-20 19:43:13.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/nonlocal/NonlocalPair.hh	2012-06-10 16:12:40.576039660 +0200
@@ -12,8 +12,8 @@
 /// @author David E. Kim (dekim@u.washington.edu)
 
 
-#ifndef INCLUDED_protocols_frag_picker_NonlocalPair_hh
-#define INCLUDED_protocols_frag_picker_NonlocalPair_hh
+#ifndef INCLUDED_protocols_frag_picker_nonlocal_NonlocalPair_hh
+#define INCLUDED_protocols_frag_picker_nonlocal_NonlocalPair_hh
 
 // unit headers
 #include <protocols/frag_picker/nonlocal/NonlocalPair.fwd.hh>
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/PhiPsiTalosIO.cc patched/rosetta_source/src/protocols/frag_picker/PhiPsiTalosIO.cc
--- vanilla/rosetta_source/src/protocols/frag_picker/PhiPsiTalosIO.cc	2012-03-20 19:43:16.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/PhiPsiTalosIO.cc	2012-06-10 16:12:40.578067651 +0200
@@ -53,6 +53,7 @@ void PhiPsiTalosIO::read(std::string con
 	last_residue_index_ = 0;
 	first_residue_index_ = 0;
 	bool first_not_found = true;
+	utility::vector1< std::string > vars;
 	while (!data.eof()) {
 		getline(data, line);
 		std::istringstream line_stream(line);
@@ -60,8 +61,10 @@ void PhiPsiTalosIO::read(std::string con
 		while (!line_stream.eof()) {
 			std::string token;
 			line_stream >> token;
-			strs.push_back(token);
+			if ( !line_stream.eof() )	strs.push_back(token);
 		}
+		if ( strs.size()==0 ) continue;
+		trPhiPsiTalosIO.Trace << "token: " << strs.size() << " in line " << line << std::endl;
 		if (strs[1] == "DATA") {
 			if (strs[2] == "SEQUENCE") {
 				for (Size i = 3; i <= strs.size(); ++i) {
@@ -76,9 +79,20 @@ void PhiPsiTalosIO::read(std::string con
 		}
 		if (strs[1] == "VARS") {
 			for (Size i = 2; i <= strs.size(); ++i) {
-				sequence_ += strs[i];
+				vars.push_back(strs[i]);
+			}
+			if ( ( vars.size()!=10 and vars.size()!=11 ) or vars[1]!="RESID" or vars[2]!="RESNAME" or vars[9]!="COUNT" or vars.back()!="CLASS" ) {
+				trPhiPsiTalosIO.Warning << "incompatible format in TALOS+ file "+file_name
+					+".\n Expected VARS  RESID RESNAME PHI PSI DPHI DPSI DIST S2 COUNT CS_COUNT CLASS\n "
+					+" or      VARS  RESID RESNAME PHI PSI DPHI DPSI DIST S2 COUNT CLASS\n "
+					+" found instead: ";
+				trPhiPsiTalosIO.Warning << vars.size() << " VARS: ";
+				for (Size i=1; i<=vars.size(); ++i) {
+					trPhiPsiTalosIO.Warning << vars[i] << " ";
+				}
+				trPhiPsiTalosIO.Warning << " LAST VAR: ->" << vars.back() << ":";
+				trPhiPsiTalosIO.Warning << std::endl;
 			}
-
 		}
 		if (strs[1] == "FORMAT") {
 			data_format_ = line.substr(7);
@@ -90,9 +104,15 @@ void PhiPsiTalosIO::read(std::string con
 			Real phi, psi, d_phi, d_psi, dist, s2;
 			Size res_id, count;
 			std::string cls;
-			line_stream >> res_id >> aa >> phi >> psi >> d_phi >> d_psi >> dist
-					>> s2 >> count >> cls;
-			sequence_ += aa;
+			if ( vars.size()==10 ) {
+				line_stream >> res_id >> aa >> phi >> psi >> d_phi >> d_psi >> dist
+										>> s2 >> count >> cls;
+			} else {
+				Size cs_count;
+				line_stream >> res_id >> aa >> phi >> psi >> d_phi >> d_psi >> dist
+										>> s2 >> count >> cs_count >> cls;
+			}
+			//this adds sequence twice		sequence_ += aa;
 
 			boost::tuple<Size, char, Real, Real, Real, Real, Real, Real, Size,
 					std::string> t(res_id, aa, phi, psi, d_phi, d_psi, dist,
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/quota/ABEGO_SS_Pool.hh patched/rosetta_source/src/protocols/frag_picker/quota/ABEGO_SS_Pool.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/quota/ABEGO_SS_Pool.hh	2012-03-20 19:43:15.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/quota/ABEGO_SS_Pool.hh	2012-06-10 16:12:40.581040729 +0200
@@ -113,7 +113,7 @@ public:
 
 	/// @brief Inserts candidates from another Collector for a give position in the query
 	/// Candidates may or may not get inserted depending on the candidate
-	void insert(Size pos, CandidatesCollectorOP collector) {
+	void insert(Size, CandidatesCollectorOP collector) {
 		ABEGO_SS_Pool *c = dynamic_cast<ABEGO_SS_Pool*> (collector());
 		if (c == 0)
 			utility_exit_with_message("Cant' cast candidates' collector to ABEGO_SS_Pool.");
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/quota/SecondaryStructurePool.hh patched/rosetta_source/src/protocols/frag_picker/quota/SecondaryStructurePool.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/quota/SecondaryStructurePool.hh	2012-03-20 19:43:15.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/quota/SecondaryStructurePool.hh	2012-06-10 16:12:40.584040441 +0200
@@ -99,7 +99,7 @@ public:
 
 	/// @brief Inserts candidates from another Collector for a give position in the query
 	/// Candidates may or may not get inserted depending on the candidate
-	void insert(Size pos, CandidatesCollectorOP collector) {
+	void insert(Size, CandidatesCollectorOP collector) {
 		SecondaryStructurePool *c = dynamic_cast<SecondaryStructurePool*> (collector());
 		if (c == 0)
 			utility_exit_with_message("Cant' cast candidates' collector to SecondaryStructurePool.");
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/scores/ConstScore.hh patched/rosetta_source/src/protocols/frag_picker/scores/ConstScore.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/scores/ConstScore.hh	2012-03-20 19:43:15.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/scores/ConstScore.hh	2012-06-10 16:12:40.587040981 +0200
@@ -64,7 +64,7 @@ public:
 	}
 
 	FragmentScoringMethodOP make(Size priority, Real lowest_acceptable_value,
-			bool use_lowest, FragmentPickerOP picker, std::string /* params */) {
+			bool use_lowest, FragmentPickerOP, std::string /* params */) {
 		return (FragmentScoringMethodOP) new ConstScore(priority,
 				lowest_acceptable_value, use_lowest);
 	}
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/scores/CSScore.cc patched/rosetta_source/src/protocols/frag_picker/scores/CSScore.cc
--- vanilla/rosetta_source/src/protocols/frag_picker/scores/CSScore.cc	2012-03-20 19:43:15.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/scores/CSScore.cc	2012-06-10 16:12:40.589056067 +0200
@@ -62,9 +62,9 @@ CSScore::CSScore(Size priority, Real low
 	//outfile_ = utility::io::ozstream tmp("allcomparisons.out");
 	//outfile_.open("allcomparisons.out");
 
-	trCSScore << "READING SHIFTS!" << std::endl;
+	trCSScore.Debug << "READING SHIFTS!" << std::endl;
 	CS2ndShift secondary_shift_calculator(reader, true);
-	trCSScore << "SHOULD BE DONE WRITING 2nd SHIFTS" << std::endl;
+	trCSScore.Debug << "SHOULD BE DONE WRITING 2nd SHIFTS" << std::endl;
 
 	target_shifts_ = secondary_shift_calculator.shifts();
 }
@@ -80,7 +80,7 @@ void CSScore::do_caching(VallChunkOP cur
 	//Real const clip_factor(3.0);
 
 	bool vall_data(false);
-	trCSScore << "caching CS score for " << current_chunk->get_pdb_id()
+	trCSScore.Debug << "caching CS score for " << current_chunk->get_pdb_id()
 	                        << " of size " << current_chunk->size() << std::endl;
 
 	//Check to see if the cache needs to be recalculated
@@ -124,6 +124,16 @@ void CSScore::do_caching(VallChunkOP cur
 				//on v_shifts for that type of atom at the vall residue's specific phi/psi location
 				// (Think of v_shift as a phi/psi dependent and atom type dependent weight constant)
 				VallResidueOP res = current_chunk->at(i);
+
+				if ( res->secondary_shifts().size() < q_shift_type*2 ) {
+					trCSScore.Debug << "Chunk has not enough secondary shifts to perform this query at position "
+														<< i << " " << std::endl
+														<< "pdb_id: " << current_chunk->get_pdb_id() << std::endl
+														<< "chain_id: " << current_chunk->get_chain_id() << std::endl
+														<< "sequence: " << current_chunk->get_sequence() << std::endl;
+					continue;
+				}
+
 				Real v_shift(res->secondary_shifts()[(q_shift_type*2)-1]);
 				//q_shift_type*2-1 because the array of 12 numbers goes shift1, sigma1, shift2, sigma2...
 				Real v_sigma(res->secondary_shifts()[ q_shift_type*2 ]);
@@ -174,7 +184,7 @@ void CSScore::do_caching(VallChunkOP cur
 
 	scores_ = temp;
 
-	trCSScore << "caching CS score for " << current_chunk->get_pdb_id()
+	trCSScore.Debug << "caching CS score for " << current_chunk->get_pdb_id()
 	                << " of size " << current_chunk->size()
 	                << ". The matrix is: "<<scores_.size()<<" x "<<scores_[1].size()<<std::endl;
 }
@@ -234,7 +244,7 @@ FragmentScoringMethodOP MakeCSScore::mak
 
 	if (option[in::file::talos_cs].user()) {
 	  CSTalosIO in(option[in::file::talos_cs]());
-	  in.write(std::cerr);
+		//  in.write(std::cerr);
 	  return (FragmentScoringMethodOP) new CSScore(priority,
 	                                  lowest_acceptable_value, use_lowest,in);
 	}
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/scores/FragmentAllAtomCrmsd.cc patched/rosetta_source/src/protocols/frag_picker/scores/FragmentAllAtomCrmsd.cc
--- vanilla/rosetta_source/src/protocols/frag_picker/scores/FragmentAllAtomCrmsd.cc	2012-03-20 19:43:15.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/scores/FragmentAllAtomCrmsd.cc	2012-06-10 16:12:40.592041997 +0200
@@ -87,11 +87,11 @@ FragmentAllAtomCrmsd::FragmentAllAtomCrm
 		}
 		trRmsScore.Trace <<std::endl;
 	}
-	core::pose::make_pose_from_sequence(*fragment_pose_, reference_pose_->sequence(), *(chemical::ChemicalManager::get_instance()->residue_type_set("centroid")));	
+	core::pose::make_pose_from_sequence(*fragment_pose_, reference_pose_->sequence(), *(chemical::ChemicalManager::get_instance()->residue_type_set("centroid")));
 }
 
 void FragmentAllAtomCrmsd::fill_coords(core::pose::Pose const& pose,
-		FArray2_double& coords, Size n_res, std::string aa_sequence) {
+		FArray2_double& coords, Size n_res, std::string ) {
 
 	trRmsScore.Debug << "Copying coordinates from ... The first residues are: "
 			<< pose.residue(1).name3() << " " << pose.residue(2).name3() << " "
@@ -105,7 +105,7 @@ void FragmentAllAtomCrmsd::fill_coords(c
 			coords(d, n_at) = xyzN[d - 1];
 		}
 		n_at++;
-		
+
 		id::NamedAtomID idCA("CA", i);
 		PointPosition const& xyzCA = pose.xyz(idCA);
 		for (core::Size d = 1; d <= 3; ++d) {
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/scores/GunnCost.hh patched/rosetta_source/src/protocols/frag_picker/scores/GunnCost.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/scores/GunnCost.hh	2012-03-20 19:43:15.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/scores/GunnCost.hh	2012-06-10 16:12:40.595040176 +0200
@@ -13,8 +13,8 @@
 /// @date   Wed Aug 22 12:08:31 2007
 ///
 
-#ifndef protocols_frag_picker_scores_GunnCost_HH
-#define protocols_frag_picker_scores_GunnCost_HH
+#ifndef INCLUDED_protocols_frag_picker_scores_GunnCost_HH
+#define INCLUDED_protocols_frag_picker_scores_GunnCost_HH
 
 
 // Project Headers
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/scores/PCS_FragDistance.hh patched/rosetta_source/src/protocols/frag_picker/scores/PCS_FragDistance.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/scores/PCS_FragDistance.hh	2012-03-20 19:43:15.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/scores/PCS_FragDistance.hh	2012-06-10 16:12:40.598039854 +0200
@@ -11,8 +11,8 @@
 /// @brief  Scores fragments by disulfide-linke Calpha distances
 /// @author Robert Vernon
 
-#ifndef INCLUDED_protocols_frag_picker_PCS_FragDistance_HH
-#define INCLUDED_protocols_frag_picker_PCS_FragDistance_HH
+#ifndef INCLUDED_protocols_frag_picker_scores_PCS_FragDistance_HH
+#define INCLUDED_protocols_frag_picker_scores_PCS_FragDistance_HH
 
 // package headers
 #include <protocols/frag_picker/FragmentCandidate.fwd.hh>
diff -rupN vanilla/rosetta_source/src/protocols/frag_picker/SidechainContactDistCutoff.fwd.hh patched/rosetta_source/src/protocols/frag_picker/SidechainContactDistCutoff.fwd.hh
--- vanilla/rosetta_source/src/protocols/frag_picker/SidechainContactDistCutoff.fwd.hh	2012-03-20 19:43:16.000000000 +0100
+++ patched/rosetta_source/src/protocols/frag_picker/SidechainContactDistCutoff.fwd.hh	2012-06-10 16:12:40.600040706 +0200
@@ -10,8 +10,8 @@
 /// @file protocols/frag_picker/SidechainContactDistCutoff.fwd.hh
 /// @author David Kim (dekim@u.washington.edu)
 
-#ifndef PROTOCOLS_FRAG_PICKER_SIDECHAIN_CONTACT_DIST_CUTOFF_FWD_HH_
-#define PROTOCOLS_FRAG_PICKER_SIDECHAIN_CONTACT_DIST_CUTOFF_FWD_HH_
+#ifndef INCLUDED_PROTOCOLS_FRAG_PICKER_SIDECHAINCONTACTDISTCUTOFF_FWD_HH
+#define INCLUDED_PROTOCOLS_FRAG_PICKER_SIDECHAINCONTACTDISTCUTOFF_FWD_HH
 
 #include <utility/pointer/owning_ptr.fwd.hh>
 
diff -rupN vanilla/rosetta_source/src/protocols/init/init.ConstraintRegistrators.ihh patched/rosetta_source/src/protocols/init/init.ConstraintRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.ConstraintRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.ConstraintRegistrators.ihh	2012-06-06 11:24:23.495039932 +0200
@@ -19,12 +19,9 @@ namespace protocols {
 using core::scoring::constraints::ConstraintRegistrator;
 
 //from protocols/constraints_additional/AdditionalConstraintCreators.hh
-static ConstraintRegistrator< protocols::constraints_additional::BindingSiteConstraintCreator > BindingSiteConstraintCreator_registrator;
-static ConstraintRegistrator< protocols::constraints_additional::SequenceCoupling1BDConstraintCreator > SequenceCoupling1BDConstraintCreator_registrator;
-static ConstraintRegistrator< protocols::constraints_additional::SequenceCouplingConstraintCreator > SequenceCouplingConstraintCreator_registrator;
 //This ConstraintRegistrator cannot exist because someone has really silly code that modifies the ConstraintFactory midstream and this breaks it.
 //static ConstraintRegistrator< protocols::constraints_additional::NamedAtomPairConstraintCreator > NamedAtomPairConstraintCreator_registrator;
 
-static ConstraintRegistrator< protocols::pockets::PocketConstraintCreator > PocketConstraintCreator_registrator;
+//static ConstraintRegistrator< protocols::pockets::PocketConstraintCreator > PocketConstraintCreator_registrator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.DataLoaderRegistrators.ihh patched/rosetta_source/src/protocols/init/init.DataLoaderRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.DataLoaderRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.DataLoaderRegistrators.ihh	2012-06-06 01:08:41.152040025 +0200
@@ -19,11 +19,7 @@ namespace protocols {
 using namespace jd2::parser;
 static DataLoaderRegistrator< ScoreFunctionLoaderCreator > reg_ScoreFunctionLoaderCreator;
 static DataLoaderRegistrator< TaskOperationLoaderCreator > reg_TaskOperationLoaderCreator;
-static DataLoaderRegistrator< protocols::qsar::scoring_grid::ScoringGridLoaderCreator > reg_ScoringGridLoaderCreator;
 static DataLoaderRegistrator< FragSetLoaderCreator > reg_FragSetLoaderCreator;
 static DataLoaderRegistrator< MonteCarloLoaderCreator > reg_MonteCarloLoaderCreator;
-static DataLoaderRegistrator< ligand_docking::InterfaceBuilderLoaderCreator > reg_InterfaceBuilderLoaderCreator;
-static DataLoaderRegistrator< ligand_docking::MoveMapBuilderLoaderCreator > reg_MoveMapBuilderLoaderCreator;
-static DataLoaderRegistrator< ligand_docking::LigandAreaLoaderCreator > reg_LigandAreaLoaderCreator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.EnergyMethodRegistrators.ihh patched/rosetta_source/src/protocols/init/init.EnergyMethodRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.EnergyMethodRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.EnergyMethodRegistrators.ihh	2012-06-06 01:09:02.809040049 +0200
@@ -24,7 +24,5 @@ static EnergyMethodRegistrator< scoring:
 static EnergyMethodRegistrator< scoring::methods::EnsembleEnergyCreator > EnsembleEnergyCreator_registrator;
 static EnergyMethodRegistrator< scoring::methods::InterchainEnvEnergyCreator > InterchainEnvEnergyCreator_registrator;
 static EnergyMethodRegistrator< scoring::methods::InterchainPairEnergyCreator > InterchainPairEnergyCreator_registrator;
-static EnergyMethodRegistrator< protocols::scoring::methods::saxs::PDDFEnergyCreator > PDDFEnergyCreator_registrator;
-static EnergyMethodRegistrator< protocols::fldsgn::potentials::sspot::NatbiasSecondaryStructureEnergyCreator > NatbiasSecondaryStructureEnergyCreator_registrator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.EvaluatorRegistrators.ihh patched/rosetta_source/src/protocols/init/init.EvaluatorRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.EvaluatorRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.EvaluatorRegistrators.ihh	2012-06-06 11:08:36.296040715 +0200
@@ -19,7 +19,6 @@ namespace protocols {
 //The order of EvaluatorRegistrators must be in this order or silent file column order will change.
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::RmsdTargetEvaluatorCreator> RmsdTargetEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::PredictedBurialFnEvaluatorCreator> PredictedBurialFnEvaluatorCreator_registrator;
-static protocols::evaluation::EvaluatorRegistrator<protocols::comparative_modeling::AlignRmsdTargetEvaluatorCreator> AlignRmsdTargetEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::StructureSimilarityEvaluatorCreator> StructureSimilarityEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::JScoreEvaluatorCreator> JScoreEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::ContactMapEvaluatorCreator> ContactMapEvaluatorCreator_registrator;
@@ -31,8 +30,8 @@ static protocols::evaluation::EvaluatorR
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::RdcSelectEvaluatorCreator> RdcSelectEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::RdcEvaluatorCreator> RdcEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::constraints_additional::ConstraintEvaluatorCreator> ConstraintEvaluatorCreator_registrator;
-static protocols::evaluation::EvaluatorRegistrator<protocols::constraints_additional::CombinedConstraintEvaluatorCreator> CombinedConstraintEvaluatorCreator_registrator;
-	static protocols::evaluation::EvaluatorRegistrator<protocols::sparta::ChemicalShiftEvaluatorCreator> ChemicalShiftEvaluatorCreator_registrator;
+//static protocols::evaluation::EvaluatorRegistrator<protocols::constraints_additional::CombinedConstraintEvaluatorCreator> CombinedConstraintEvaluatorCreator_registrator;
+static protocols::evaluation::EvaluatorRegistrator<protocols::sparta::ChemicalShiftEvaluatorCreator> ChemicalShiftEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::CamShiftEvaluatorCreator> CamShiftEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::PalesEvaluatorCreator> PalesEvaluatorCreator_registrator;
 static protocols::evaluation::EvaluatorRegistrator<protocols::simple_filters::ExtraScoreEvaluatorCreator> ExtraScoreEvaluatorCreator_registrator;
diff -rupN vanilla/rosetta_source/src/protocols/init/init.FeaturesReporterRegistrators.ihh patched/rosetta_source/src/protocols/init/init.FeaturesReporterRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.FeaturesReporterRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.FeaturesReporterRegistrators.ihh	2012-06-06 01:10:02.733040455 +0200
@@ -17,38 +17,5 @@
 namespace protocols {
 
 using namespace protocols::features;
-static FeaturesReporterRegistrator< AtomAtomPairFeaturesCreator > AtomAtomPairFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< AtomTypesFeaturesCreator > AtomTypesFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< AtomInResidueAtomInResiduePairFeaturesCreator > AtomInResidueAtomInResiduePairFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< BetaTurnDetectionFeaturesCreator > BetaTurnDetectionFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< GeometricSolvationFeaturesCreator > GeometricSolvationFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< HBondFeaturesCreator > HBondFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< HBondParameterFeaturesCreator > HBondParameterFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< JobDataFeaturesCreator > JobDataFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< LoopAnchorFeaturesCreator > LoopAnchorFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< OrbitalsFeaturesCreator > OrbitalsFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< PairFeaturesCreator > PairFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< PdbDataFeaturesCreator > PdbDataFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< PoseCommentsFeaturesCreator > PoseCommentsFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< PoseConformationFeaturesCreator > PoseConformationFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ProteinBackboneAtomAtomPairFeaturesCreator > ProteinBackboneAtomAtomPairFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ProteinBackboneTorsionAngleFeaturesCreator > ProteinBackboneTorsionAngleFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ProteinResidueConformationFeaturesCreator > ProteinResidueConformationFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ProteinRMSDFeaturesCreator > ProteinRMSDFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ProtocolFeaturesCreator > ProtocolFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< RadiusOfGyrationFeaturesCreator > RadiusOfGyrationFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ResidueBurialFeaturesCreator > ResidueBurialFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ResidueConformationFeaturesCreator > ResidueConformationFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ResidueFeaturesCreator > ResidueFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ResidueScoresFeaturesCreator > ResidueScoresFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ResidueSecondaryStructureFeaturesCreator > ResidueSecondaryStructureFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ResidueTypesFeaturesCreator > ResidueTypesFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< RotamerBoltzmannWeightFeaturesCreator > RotamerBoltzmannWeightFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< RotamerRecoveryFeaturesCreator > RotamerRecoveryFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< SaltBridgeFeaturesCreator > SaltBridgeFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< ScoreTypeFeaturesCreator > ScoreTypeFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< StructureFeaturesCreator > StructureFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< StructureScoresFeaturesCreator > StructureScoresFeaturesCreator_registrator;
-static FeaturesReporterRegistrator< helixAssembly::HelixBundleFeaturesCreator > HelixBundleFeaturesCreator_registrator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.FilterRegistrators.ihh patched/rosetta_source/src/protocols/init/init.FilterRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.FilterRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.FilterRegistrators.ihh	2012-06-06 01:10:25.515956599 +0200
@@ -18,13 +18,6 @@ namespace protocols {
 
 using protocols::filters::FilterRegistrator;
 
-static FilterRegistrator< protocols::enzdes::DiffAtomSasaFilterCreator > reg_DiffAtomSasaFilterCreator;
-static FilterRegistrator< protocols::enzdes::EnzdesScorefileFilterCreator > reg_EnzdesScorefileFilterCreator;
-static FilterRegistrator< protocols::enzdes::EnzScoreFilterCreator > reg_EnzScoreFilterCreator;
-static FilterRegistrator< protocols::enzdes::LigBurialFilterCreator > reg_LigBurialFilterCreator;
-static FilterRegistrator< protocols::enzdes::LigDSasaFilterCreator > reg_LigDSasaFilterCreator;
-static FilterRegistrator< protocols::enzdes::LigInterfaceEnergyFilterCreator > reg_LigInterfaceEnergyFilterCreator;
-static FilterRegistrator< protocols::enzdes::RepackWithoutLigandFilterCreator > reg_RepackWithoutLigandFilterCreator;
 
 static FilterRegistrator< protocols::filters::CombinedFilterCreator > reg_CombinedFilterCreator;
 static FilterRegistrator< protocols::filters::CompoundFilterCreator > reg_CompoundFilterCreator;
@@ -34,35 +27,7 @@ static FilterRegistrator< protocols::fil
 static FilterRegistrator< protocols::filters::StochasticFilterCreator > reg_StochasticFilterCreator;
 static FilterRegistrator< protocols::filters::TimeFilterCreator > reg_TimeFilterCreator;
 
-static FilterRegistrator< protocols::fldsgn::filters::CoreDunbrackFilterCreator > reg_CoreDunbrackFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::FragQualFilterCreator > reg_FragQualFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::HelixKinkFilterCreator > reg_HelixKinkFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::HelixPairingFilterCreator > reg_HelixPairingFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::HSSTripletFilterCreator > reg_HSSTripletFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::InterlockingAromaFilterCreator > reg_InterlockingAromaFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::NcontactsFilterCreator > reg_NcontactsFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::ParallelBetaPairingPreferenceFilterCreator > reg_ParallelBetaPairingPreferenceFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::SecondaryStructureFilterCreator > reg_SecondaryStructureFilterCreator;
-static FilterRegistrator< protocols::fldsgn::filters::SheetTopologyFilterCreator > reg_SheetTopologyFilterCreator;
-
-static FilterRegistrator< protocols::ligand_docking::CompleteConnectionsFilterCreator > reg_CompleteConnectionsFilterCreator;
-static FilterRegistrator< protocols::ligand_docking::HeavyAtomFilterCreator > reg_HeavyAtomFilterCreator;
-
-static FilterRegistrator< protocols::protein_interface_design::filters::AverageDegreeFilterCreator > reg_AverageFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::BindingStrainFilterCreator > reg_BindingStrainFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::BoltzmannFilterCreator > reg_BoltzmannCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::DeltaFilterCreator > reg_DeltaFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::DesignableResiduesFilterCreator > reg_DesignableResiduesFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::DisulfideFilterCreator > reg_DisulfideFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::FilterScanFilterCreator > reg_FilterScanFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::HbondsToResidueFilterCreator > reg_HbondsToResidueFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::InterfaceHolesFilterCreator > reg_InterfaceHolesFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::RelativePoseFilterCreator > reg_RelativePoseFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::RelativeSegmentFilterCreator > reg_RelativeSegmentFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::RmsdFilterCreator > reg_RmsdFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::SequenceRecoveryFilterCreator > reg_SequenceRecoveryFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::StubScoreFilterCreator > reg_StubScoreFilterCreator;
-static FilterRegistrator< protocols::protein_interface_design::filters::TorsionCreator > reg_TorsionCreator;
+
 
 static FilterRegistrator< protocols::simple_filters::AlaScanFilterCreator > reg_AlaScanFilterCreator;
 static FilterRegistrator< protocols::simple_filters::AtomicContactFilterCreator > reg_AtomicContactFilterCreator;
diff -rupN vanilla/rosetta_source/src/protocols/init/init.GridRegistrators.ihh patched/rosetta_source/src/protocols/init/init.GridRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.GridRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.GridRegistrators.ihh	2012-06-06 01:10:43.895981698 +0200
@@ -16,13 +16,5 @@
 
 namespace protocols {
 
-using namespace qsar::scoring_grid;
-static GridRegistrator<AtrGridCreator> reg_AtrGridCreator;
-static GridRegistrator<RepGridCreator> reg_RepGridCreator;
-static GridRegistrator<ClassicGridCreator> reg_ClassicGridCreator;
-static GridRegistrator<HbaGridCreator> reg_HbaGridCreator;
-static GridRegistrator<HbdGridCreator> reg_HbdGridCreator;
-static GridRegistrator<polarizGridCreator> reg_polarizGridCreator;
-static GridRegistrator<VdwGridCreator> reg_VdwGridCreator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.JobInputterRegistrators.ihh patched/rosetta_source/src/protocols/init/init.JobInputterRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.JobInputterRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.JobInputterRegistrators.ihh	2012-06-06 12:16:54.667040076 +0200
@@ -17,14 +17,9 @@
 namespace protocols {
 
 using namespace protocols::jd2;
-static JobInputterRegistrator< enzdes::EnzdesJobInputterCreator > reg_EnzdesJobInputterCreator;
-static JobInputterRegistrator< protein_interface_design::ParserJobInputterCreator > reg_ParserJobInputterCreator;
 static JobInputterRegistrator< PDBJobInputterCreator > reg_PDBJobInputterCreator;
-static JobInputterRegistrator< LazySilentFileJobInputterCreator > reg_LazySilentFileJobInputterCreator;
 static JobInputterRegistrator< SilentFileJobInputterCreator > reg_SilentFileJobInputterCreator;
-static JobInputterRegistrator< AtomTreeDiffJobInputterCreator > reg_AtomTreeDiffJobInputterCreator;
 static JobInputterRegistrator< comparative_modeling::ThreadingJobInputterCreator > reg_ThreadingJobInputterCreator;
-static JobInputterRegistrator< features::DatabaseJobInputterCreator > reg_DatabaseJobInputterCreator;
 static JobInputterRegistrator< comparative_modeling::GenericJobInputterCreator > reg_GenericJobInputterCreator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.JobOutputterRegistrators.ihh patched/rosetta_source/src/protocols/init/init.JobOutputterRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.JobOutputterRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.JobOutputterRegistrators.ihh	2012-06-06 01:11:31.226039760 +0200
@@ -22,7 +22,5 @@ static JobOutputterRegistrator< SilentFi
 static JobOutputterRegistrator< AtomTreeDiffJobOutputterCreator > reg_AtomTreeDiffJobOutputterCreator;
 static JobOutputterRegistrator< NoOutputJobOutputterCreator > reg_NoOutputJobOutputterCreator;
 static JobOutputterRegistrator< ScoreOnlyJobOutputterCreator > reg_ScoreOnlyJobOutputterCreator;
-static JobOutputterRegistrator< enzdes::EnzdesJobOutputterCreator > reg_EnzdesJobOutputterCreator;
-static JobOutputterRegistrator< features::DatabaseJobOutputterCreator > reg_DatabaseJobOutputterCreator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.MoverRegistrators.ihh patched/rosetta_source/src/protocols/init/init.MoverRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.MoverRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.MoverRegistrators.ihh	2012-06-06 11:15:40.672039602 +0200
@@ -18,204 +18,5 @@ namespace protocols {
 
 using protocols::moves::MoverRegistrator;
 
-static MoverRegistrator< abinitio::DomainAssemblyCreator > reg_DomainAssemblyCreator;
-
-static MoverRegistrator< analysis::InterfaceAnalyzerMoverCreator > reg_InterfaceAnalyzerMoverCreator;
-
-static MoverRegistrator< backrub::BackrubMoverCreator > reg_BackrubMoverCreator;
-static MoverRegistrator< backrub::BackrubSidechainMoverCreator > reg_BackrubSidechainMoverCreator;
-
-static MoverRegistrator< canonical_sampling::MetricRecorderCreator > reg_MetricRecorderCreator;
-static MoverRegistrator< canonical_sampling::MetropolisHastingsMoverCreator > reg_MetropolisHastingsMoverCreator;
-static MoverRegistrator< canonical_sampling::ParallelTemperingCreator > reg_ParallelTemperingCreator;
-static MoverRegistrator< canonical_sampling::HamiltonianExchangeCreator > reg_HamiltonianExchangeCreator;
-static MoverRegistrator< canonical_sampling::PDBTrajectoryRecorderCreator > reg_PDBTrajectoryRecorderCreator;
-static MoverRegistrator< canonical_sampling::SilentTrajectoryRecorderCreator > reg_SilentTrajectoryRecorderCreator;
-static MoverRegistrator< canonical_sampling::SimulatedTemperingCreator > reg_SimulatedTemperingCreator;
-static MoverRegistrator< canonical_sampling::TrialCounterObserverCreator > reg_TrialCounterObserverCreator;
-
-static MoverRegistrator< comparative_modeling::LoopRelaxMoverCreator > reg_LoopRelaxMoverCreator;
-static MoverRegistrator< comparative_modeling::hybridize::HybridizeProtocolCreator > reg_HybridizeProtocolCreator;
-
-static MoverRegistrator< contact_map::ContactMapCreator> reg_ContactMapCreator;
-
-static MoverRegistrator< dna::DesignProteinBackboneAroundDNACreator > reg_DesignProteinBackboneAroundDNACreator;
-static MoverRegistrator< dna::DnaInterfaceMinMoverCreator > reg_DnaInterfaceMinMoverCreator;
-static MoverRegistrator< dna::DnaInterfaceMultiStateDesignCreator > reg_DnaInterfaceMultiStateDesignCreator;
-static MoverRegistrator< dna::DnaInterfacePackerCreator > reg_DnaInterfacePackerCreator;
-static MoverRegistrator< dna::SeparateDnaFromNonDnaCreator > reg_SeparateDnaFromNonDnaCreator;
-
-static MoverRegistrator< docking::ConformerSwitchMoverCreator > reg_ConformerSwitchMoverCreator;
-static MoverRegistrator< docking::DockingProtocolCreator > DockingProtocolCreator;
-static MoverRegistrator< docking::DockSetupMoverCreator > reg_DockSetupMoverCreator;
-
-static MoverRegistrator< electron_density::SetupForDensityScoringMoverCreator > reg_SetupForDensityScoringMoverCreator;
-
-static MoverRegistrator< enzdes::AddOrRemoveMatchCstsCreator > reg_AddOrRemoveMatchCstsCreator;
-static MoverRegistrator< enzdes::BackboneSamplerCreator > reg_BackboneSamplerCreator;
-static MoverRegistrator< enzdes::EnzRepackMinimizeCreator > reg_EnzRepackMinimizeCreator;
-static MoverRegistrator< enzdes::PredesignPerturbMoverCreator > reg_PredesignPerturbMoverCreator;
-
-static MoverRegistrator< features::ReportToDBCreator > reg_ReportToDBCreator;
-
-static MoverRegistrator< fldsgn::BluePrintBDRCreator > reg_BluePrintBDRCreator;
-static MoverRegistrator< fldsgn::CircularPermutationCreator > reg_CircularPermutationCreator;
-
-static MoverRegistrator< fldsgn::potentials::SetAACompositionPotentialCreator > reg_AACompositionPotentialCreator;
-static MoverRegistrator< fldsgn::potentials::SetSecStructEnergiesCreator > reg_SetSecStructEnergiesCreator;
-
-static MoverRegistrator< flexpep_docking::FlexPepDockingProtocolCreator > reg_FlexPepDockingProtocolCreator;
-
-static MoverRegistrator< flxbb::FlxbbDesignCreator > reg_FlxbbDesignCreator;
-static MoverRegistrator< flxbb::InterlockAromaCreator > reg_InterlockAromaCreator;
-
-static MoverRegistrator< forge::remodel::RemodelLoopMoverCreator > reg_RemodelLoopMoverCreator;
-static MoverRegistrator< forge::remodel::RemodelMoverCreator > reg_RemodelMoverCreator;
-
-static MoverRegistrator< idealize::IdealizeMoverCreator > reg_IdealizeMoverCreator;
-
-static MoverRegistrator< ligand_docking::AddHydrogensCreator > reg_AddHydrogensCreator;
-static MoverRegistrator< ligand_docking::CompoundTranslateCreator > reg_CompoundTranslateCreator;
-static MoverRegistrator< ligand_docking::FinalMinimizerCreator > reg_FinalMinimizerCreator;
-static MoverRegistrator< ligand_docking::GrowLigandCreator > reg_GrowLigandCreator;
-static MoverRegistrator< ligand_docking::HighResDockerCreator > reg_HighResDockerCreator;
-static MoverRegistrator< ligand_docking::InterfaceScoreCalculatorCreator > reg_InterfaceScoreCalculatorCreator;
-static MoverRegistrator< ligand_docking::LigandDesignCreator > reg_LigandDesignCreator;
-static MoverRegistrator< ligand_docking::MinimizeBackboneCreator > reg_MinimizeBackboneCreator;
-static MoverRegistrator< ligand_docking::RandomConformersCreator > reg_RandomConformersCreator;
-static MoverRegistrator< ligand_docking::RotateCreator > reg_RotateCreator;
-static MoverRegistrator< ligand_docking::RotatesCreator > reg_RotatesCreator;
-static MoverRegistrator< ligand_docking::SlideTogetherCreator > reg_SlideTogetherCreator;
-static MoverRegistrator< ligand_docking::StartFromCreator > reg_StartFromCreator;
-static MoverRegistrator< ligand_docking::TransformCreator > reg_TransformCreator;
-static MoverRegistrator< ligand_docking::TranslateCreator > reg_TranslateCreator;
-
-static MoverRegistrator< loop_build::LoopMover_SlidingWindowCreator > reg_LoopMover_SlidingWindowCreator;
-
-static MoverRegistrator< loophash::LoopHashMoverWrapperCreator > reg_LoopHashMoverWrapperCreator;
-
-static MoverRegistrator< loops::FoldTreeFromLoopsCreator > reg_FoldTreeFromLoops_Creator;
-static MoverRegistrator< loops::loop_mover::perturb::LoopMover_Perturb_CCDCreator > reg_LoopMover_Perturb_CCDCreator;
-static MoverRegistrator< loops::loop_mover::perturb::LoopMover_Perturb_KICCreator > reg_LoopMover_Perturb_KIC;
-static MoverRegistrator< loops::loop_mover::perturb::LoopMover_Perturb_QuickCCDCreator > reg_LoopMover_Perturb_QuickCCDCreator;
-static MoverRegistrator< loops::loop_mover::perturb::LoopMover_Perturb_QuickCCD_MovesCreator > reg_LoopMover_Perturb_QuickCCD_MovesCreator;
-static MoverRegistrator< loops::loop_mover::refine::LoopMover_Refine_BackrubCreator > reg_LoopMover_Refine_Backrub;
-static MoverRegistrator< loops::loop_mover::refine::LoopMover_Refine_CCDCreator > reg_LoopMover_Refine_CCDCreator;
-static MoverRegistrator< loops::loop_mover::refine::LoopMover_Refine_KICCreator > reg_LoopMover_Refine_KIC;
-
-static MoverRegistrator< match::MatcherMoverCreator > reg_MatcherMoverCreator;
-
-static MoverRegistrator< motifs::MotifDnaPackerCreator > reg_MotifDnaPackerCreator;
-
-static MoverRegistrator< moves::DsspMoverCreator > reg_DsspMoverCreator;
-static MoverRegistrator< moves::GenericMonteCarloMoverCreator > reg_GenericMonteCarloMoverCreator;
-static MoverRegistrator< moves::IfMoverCreator > reg_IfMoverCreator;
-static MoverRegistrator< moves::RandomMoverCreator > reg_RandomMoverCreator;
-static MoverRegistrator< moves::IteratedConvergenceMoverCreator > reg_IteratedConvergenceMoverCreator;
-static MoverRegistrator< moves::MonteCarloRecoverCreator > reg_GenericMonteCarloRecoverCreator;
-static MoverRegistrator< moves::MonteCarloTestCreator > reg_MonteCarloTestCreator;
-
-static MoverRegistrator< nonlocal::SingleFragmentMoverCreator > reg_SingleFragmentMoverCreator;
-
-static MoverRegistrator< protein_interface_design::movers::AddChainBreakCreator > reg_AddChainBreakCreator;
-static MoverRegistrator< protein_interface_design::movers::AddSidechainConstraintsToHotspotsCreator > reg_AddSidechainConstraintsToHotspotsCreator;
-static MoverRegistrator< protein_interface_design::movers::BackrubDDMoverCreator > reg_BackrubDDMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::BestHotspotCstMoverCreator > reg_BestHotspotCstMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::BuildAlaPoseCreator > reg_BuildAlaPoseCreator;
-static MoverRegistrator< protein_interface_design::movers::DesignMinimizeHbondsCreator > reg_DesignMinimizeHbondsCreator;
-static MoverRegistrator< protein_interface_design::movers::DisulfideMoverCreator > reg_DisulfideMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::DockAndRetrieveSidechainsCreator > reg_DockAndRetrieveSidechainsCreator;
-static MoverRegistrator< protein_interface_design::movers::DumpPdbCreator > reg_DumpPdbCreator;
-static MoverRegistrator< protein_interface_design::movers::FavorNativeResiduePreCycleCreator > reg_FavorNativeResiduePreCycleCreator;
-static MoverRegistrator< protein_interface_design::movers::FavorNonNativeResiduePreCycleCreator > reg_FavorNonNativeResiduePreCycleCreator;
-static MoverRegistrator< protein_interface_design::movers::HotspotDisjointedFoldTreeMoverCreator > reg_HotsotDisjointedFoldTreeMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::HotspotHasherMoverCreator > reg_HotspotHasherMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::InterfaceRecapitulationMoverCreator > reg_InterfaceRecapitulationMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::LoopFinderCreator > reg_LoopFinderCreator;
-static MoverRegistrator< protein_interface_design::movers::LoopLengthChangeCreator > reg_LoopLengthChangeCreator;
-static MoverRegistrator< protein_interface_design::movers::LoopMoverFromCommandLineCreator > reg_LoopMoverFromCommandLine;
-static MoverRegistrator< protein_interface_design::movers::LoopOverCreator > reg_LoopOverCreator;
-static MoverRegistrator< protein_interface_design::movers::LoopRemodelCreator > reg_LoopRemodelCreator;
-static MoverRegistrator< protein_interface_design::movers::MapHotspotCreator > reg_MapHotspotCreator;
-static MoverRegistrator< protein_interface_design::movers::PeptideStapleDesignMoverCreator > reg_PeptideStapleDesignMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::PlacementAuctionMoverCreator > reg_PlacementAuctionMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::PlacementMinimizationMoverCreator > reg_PlacementMinimizationMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::PlaceOnLoopCreator > reg_PlaceOnLoopCreator;
-static MoverRegistrator< protein_interface_design::movers::PlaceSimultaneouslyMoverCreator > reg_PlaceSimultaneouslyMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::PlaceStubMoverCreator > reg_PlaceStubMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::PrepackMoverCreator > reg_PrepackMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::ProteinInterfaceMultiStateDesignMoverCreator > reg_ProteinInterfaceMultiStateDesignMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::RandomMutationCreator > reg_RandomMutationCreator;
-static MoverRegistrator< protein_interface_design::movers::RepackMinimizeCreator > reg_RepackMinimizeCreator;
-static MoverRegistrator< protein_interface_design::movers::SaveAndRetrieveSidechainsCreator > reg_SaveAndRetrieveSidechainsCreator;
-static MoverRegistrator< protein_interface_design::movers::SetAtomTreeCreator > reg_SetAtomTreeCreator;
-static MoverRegistrator< protein_interface_design::movers::SetTemperatureFactorCreator > reg_SetTemperatureFactorCreator;
-static MoverRegistrator< protein_interface_design::movers::SetupHotspotConstraintsMoverCreator > reg_SetupHotspotConstraintsMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::SpinMoverCreator > reg_SpinMoverCreator;
-static MoverRegistrator< protein_interface_design::movers::TaskAwareCstsCreator > reg_TaskAwareCstsCreator;
-static MoverRegistrator< protein_interface_design::movers::SubroutineMoverCreator > reg_SubroutineCreator;
-static MoverRegistrator< protein_interface_design::movers::TryRotamersCreator > reg_TryRotamersCreator;
-static MoverRegistrator< protein_interface_design::movers::VLBCreator > reg_VLBCreator;
-
-static MoverRegistrator< qsar::RenderGridsToKinemageCreator> reg_RenderGridsToKinemageCreator;
-
-static MoverRegistrator< relax::FastRelaxCreator> reg_FastRelaxCreator;
-
-static MoverRegistrator< rigid::RigidBodyPerturbNoCenterMoverCreator > reg_RigidBodyPerturbNoCenterMoverCreator;
-static MoverRegistrator< rigid::RollMoverCreator > reg_RollMoverCreator;
-
-static MoverRegistrator< rosetta_scripts::ParsedProtocolCreator > reg_ParsedProtocolCreator;
-static MoverRegistrator< rosetta_scripts::SavePoseMoverCreator > SavePoseMoverCreator;
-
-static MoverRegistrator< rotamer_recovery::RotamerRecoveryMoverCreator > reg_RotamerRecoveryMoverCreator;
-
-static MoverRegistrator< seeded_abinitio::CAcstGeneratorCreator > CAcstGeneratorCreator;
-static MoverRegistrator< seeded_abinitio::CloseFoldCreator > CloseFoldCreator;
-static MoverRegistrator< seeded_abinitio::CoordinateCstCreator > CoordinateCstCreator;
-static MoverRegistrator< seeded_abinitio::DefineMovableLoopsCreator > DefineMovableLoopsCreator;
-static MoverRegistrator< seeded_abinitio::GrowPeptidesCreator > GrowPeptidesCreator;
-static MoverRegistrator< seeded_abinitio::SeedFoldTreeCreator > SeedFoldTreeCreator;
-static MoverRegistrator< seeded_abinitio::SeedSetupMoverCreator > SeedSetupMoverCreator;
-static MoverRegistrator< seeded_abinitio::SwapSegmentCreator > SwapSegmentCreator;
-
-static MoverRegistrator< simple_moves::GreedyOptMutationMoverCreator > reg_GreedyOptMutationMoverCreator;
-static MoverRegistrator< simple_moves::AddConstraintsToCurrentConformationMoverCreator > reg_AddConstraintsToCurrentConformationMoverCreator;
-static MoverRegistrator< simple_moves::ClearConstraintsMoverCreator > reg_ClearConstraintsMoverCreator;
-static MoverRegistrator< simple_moves::ConsensusDesignMoverCreator > reg_ConsensusDesignMoverCreator;
-static MoverRegistrator< simple_moves::ConstraintSetMoverCreator > reg_ConstraintSetMoverCreator;
-static MoverRegistrator< simple_moves::ddGCreator> reg_ddGCreator;
-static MoverRegistrator< simple_moves::ExtendedPoseMoverCreator > reg_ExtendedPoseMoverCreator;
-static MoverRegistrator< simple_moves::FavorSequenceProfileCreator > reg_FavorSequenceProfileCreator;
-static MoverRegistrator< simple_moves::LoadUnboundRotMoverCreator > reg_LoadUnboundRotMoverCreator;
-static MoverRegistrator< simple_moves::MakePolyXMoverCreator > reg_MakePolyXMoverCreator;
-static MoverRegistrator< simple_moves::MembraneTopologyCreator > reg_MembraneTopologyCreator;
-static MoverRegistrator< simple_moves::MinMoverCreator > reg_MinMoverCreator;
-static MoverRegistrator< simple_moves::MinPackMoverCreator > reg_MinPackMoverCreator;
-static MoverRegistrator< simple_moves::MutateResidueCreator > reg_MutateResidueCreator;
-static MoverRegistrator< simple_moves::PackRotamersMoverCreator > reg_PackRotamersMoverCreator;
-static MoverRegistrator< simple_moves::RotamerTrialsMinMoverCreator > reg_RotamerTrialsMinMoverCreator;
-static MoverRegistrator< simple_moves::RotamerTrialsMoverCreator > reg_RotamerTrialsMoverCreator;
-static MoverRegistrator< simple_moves::SaneMinMoverCreator > reg_SaneMinMoverCreator;
-static MoverRegistrator< simple_moves::ScoreMoverCreator > reg_ScoreMoverCreator;
-static MoverRegistrator< simple_moves::SequenceProfileMoverCreator > reg_SequenceProfileMoverCreator;
-static MoverRegistrator< simple_moves::SetTorsionCreator > reg_SetTorsionCreator;
-static MoverRegistrator< simple_moves::ShearMoverCreator > reg_ShearMoverCreator;
-static MoverRegistrator< simple_moves::SmallMoverCreator > reg_SmallMoverCreator;
-static MoverRegistrator< simple_moves::SwitchResidueTypeSetMoverCreator > reg_SwitchResidueTypeSetMoverCreator;
-static MoverRegistrator< simple_moves::TaskAwareMinMoverCreator > reg_TaskAwareMinMoverCreator;
-
-static MoverRegistrator< simple_moves::sidechain_moves::SidechainMCMoverCreator > reg_SidechainMCMoverCreator;
-static MoverRegistrator< simple_moves::sidechain_moves::SidechainMoverCreator > reg_SidechainMoverCreator;
-static MoverRegistrator< simple_moves::sidechain_moves::JumpRotamerSidechainMoverCreator > reg_JumpRotamerSidechainMoverCreator;
-static MoverRegistrator< simple_moves::sidechain_moves::PerturbRotamerSidechainMoverCreator > reg_PerturbRotamerSidechainMoverCreator;
-static MoverRegistrator< simple_moves::sidechain_moves::PerturbChiSidechainMoverCreator > reg_PerturbChiSidechainMoverCreator;
-
-static MoverRegistrator< simple_moves::symmetry::ExtractAsymmetricUnitMoverCreator > reg_ExtractAsymmetricUnitMoverCreator;
-static MoverRegistrator< simple_moves::symmetry::ExtractAsymmetricPoseMoverCreator > reg_ExtractAsymmetricPoseMoverCreator;
-static MoverRegistrator< simple_moves::symmetry::SetupForSymmetryMoverCreator > reg_SetupForSymmetryMoverCreator;
-static MoverRegistrator< simple_moves::symmetry::SetupNCSMoverCreator > reg_SetupNCSMoverCreator;
-static MoverRegistrator< simple_moves::symmetry::SymMinMoverCreator > reg_SymMinMoverCreator;
-static MoverRegistrator< simple_moves::symmetry::SymPackRotamersMoverCreator > reg_SymPackRotamersMoverCreator;
-static MoverRegistrator< simple_moves::symmetry::SymRotamerTrialsMoverCreator > reg_SymRotamerTrialsMoverCreator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.RotamerRecoveryRegistrators.ihh patched/rosetta_source/src/protocols/init/init.RotamerRecoveryRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.RotamerRecoveryRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.RotamerRecoveryRegistrators.ihh	2012-06-06 01:12:54.232039820 +0200
@@ -17,13 +17,5 @@
 namespace protocols {
 
 using namespace protocols::rotamer_recovery;
-static RotamerRecoveryRegistrator< RRProtocolRTMinCreator > RRProtocolRTMinCreator_registrator;
-static RotamerRecoveryRegistrator< RRProtocolMinPackCreator > RRProtocolMinPackCreator_registrator;
-static RotamerRecoveryRegistrator< RRProtocolMoverCreator > RRProtocolMoverCreator_registrator;
-static RotamerRecoveryRegistrator< RRComparerRotBinsCreator > RRComparerRotBinsCreator_registrator;
-static RotamerRecoveryRegistrator< RRComparerAutomorphicRMSDCreator > RRComparerAutomorphicRMSDCreator_registrator;
-static RotamerRecoveryRegistrator< RRReporterSimpleCreator > RRReporterSimpleCreator_registrator;
-static RotamerRecoveryRegistrator< RRReporterHumanCreator > RRReporterHumanCreator_registrator;
-static RotamerRecoveryRegistrator< RRReporterSQLiteCreator > RRReporterSQLiteCreator_registrator;
 
 } //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/init/init.TaskOperationRegistrators.ihh patched/rosetta_source/src/protocols/init/init.TaskOperationRegistrators.ihh
--- vanilla/rosetta_source/src/protocols/init/init.TaskOperationRegistrators.ihh	2012-03-21 09:18:46.000000000 +0100
+++ patched/rosetta_source/src/protocols/init/init.TaskOperationRegistrators.ihh	2012-06-06 01:13:10.129039768 +0200
@@ -17,19 +17,6 @@
 namespace protocols {
 using core::pack::task::operation::TaskOperationRegistrator;
 
-static TaskOperationRegistrator< protocols::dna::RestrictDesignToProteinDNAInterfaceCreator > RestrictDesignToProteinDNAInterfaceCreator_registrator;
-static TaskOperationRegistrator< protocols::dna::WatsonCrickRotamerCouplingsCreator > WatsonCrickRotamerCouplingsCreator_registrator;
-
-static TaskOperationRegistrator< protocols::enzdes::AddLigandMotifRotamersOperationCreator > AddLigandMotifRotamersOperationCreator_registrator;
-static TaskOperationRegistrator< protocols::enzdes::AddRigidBodyLigandConfsCreator > AddRigidBodyLigandConfsCreator_registrator;
-static TaskOperationRegistrator< protocols::enzdes::DetectProteinLigandInterfaceOperationCreator > DetectProteinLigandInterfaceOperationCreator_registrator;
-static TaskOperationRegistrator< protocols::enzdes::ProteinLigandInterfaceUpweighterOperationCreator > ProteinLigandInterfaceUpweighterOperationCreator_registrator;
-static TaskOperationRegistrator< protocols::enzdes::SetCatalyticResPackBehaviorCreator > SetCatalyticResPackBehaviorCreator_registrator;
-
-static TaskOperationRegistrator< protocols::flxbb::LayerDesignOperationCreator > LayerDesignOperationCreator_registrator;
-
-static TaskOperationRegistrator< protocols::forge::remodel::RemodelRotamerLinksCreator > RemodelRotamerLinksCreator_registrator;
-
 static TaskOperationRegistrator< protocols::toolbox::task_operations::DesignAroundOperationCreator > DesignAroundOperationCreator_registrator;
 static TaskOperationRegistrator< protocols::toolbox::task_operations::JointSequenceOperationCreator > JointSequenceOperationCreator_registrator;
 static TaskOperationRegistrator< protocols::toolbox::task_operations::LimitAromaChi2OperationCreator > LimitAromaChi2OperationCreator_registrator;
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/ArchiveBase.cc patched/rosetta_source/src/protocols/jd2/archive/ArchiveBase.cc
--- vanilla/rosetta_source/src/protocols/jd2/archive/ArchiveBase.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/ArchiveBase.cc	2012-06-10 16:12:40.334040425 +0200
@@ -53,6 +53,7 @@ static basic::Tracer tr("protocols.jd2.A
 using basic::mem_tr;
 // Utility headers
 #include <basic/options/option_macros.hh>
+#include <basic/prof.hh>
 
 #include <utility/vector1.hh>
 #include <boost/algorithm/string/erase.hpp>
@@ -240,6 +241,7 @@ void ArchiveBase::save_to_file( std::str
 	rename( tmp_filename.c_str(), filename.c_str() );
 
 	utility::io::ozstream status( dirname+"/STATUS" );
+	basic::show_time( tr,  "save "+name()+" status");
 	save_status( status );
 }
 
@@ -292,9 +294,9 @@ void ArchiveBase::restore_status( std::i
 
 void ArchiveBase::save_status( std::ostream& os ) const {
 	using namespace ObjexxFCL::fmt;
-	os << "total_accepts accepts_since_last_batch total_proposed proposed_since_last_batch\n"
-		 << RJ( 14, total_accepts_ ) << RJ( 25, accepts_since_last_batch_ )
-		 << RJ( 15, total_proposed_ ) << RJ( 30, proposed_since_last_batch_) << std::endl;
+	os << "total_accepts accepts_during_stage total_proposed proposed_during_stage\n"
+		 << RJ( 14, total_accepts_+accepts_since_last_batch_ ) << RJ( 25, accepts_since_last_batch_ )
+		 << RJ( 15, total_proposed_+proposed_since_last_batch_ ) << RJ( 30, proposed_since_last_batch_) << std::endl;
 	os << "acceptance_history: " << floating_acceptance_ratio_ << "\nAH: ";
 	Size const cols( 50 );
 	Size ct( cols );
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/ArchiveBase.hh patched/rosetta_source/src/protocols/jd2/archive/ArchiveBase.hh
--- vanilla/rosetta_source/src/protocols/jd2/archive/ArchiveBase.hh	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/ArchiveBase.hh	2012-06-10 16:12:40.337040999 +0200
@@ -66,6 +66,7 @@ public:
 
 	//this is probably obsoleted
 	//	virtual bool ready_for_batch() const = 0;
+	virtual void initialize() = 0;
 
 	///@brief old-batches might be outdated and should not be computed anymore
 	/// return true for this query if this is the case for old_batch
@@ -134,7 +135,7 @@ public:
 
 	//obsolet ?
 	//	virtual bool ready_for_batch() const { return false; };
-
+	virtual void initialize() {};
 
 	virtual void generate_batch() = 0;
 
@@ -189,13 +190,13 @@ public:
 	core::Size total_accepts() { return total_accepts_ + accepts_since_last_batch(); };
 	bool statistics_valid() { return  acceptance_history_.size() > min_structures_for_acceptance_statistics_; };
 
-
+	SilentStructs const& decoys() const { return decoys_; };
+	SilentStructs& decoys() { return decoys_; };
 protected:
 	virtual void count_structure( Batch const& batch, bool accepted  );
 	void count_removed_structures( core::Size n_removed );
 
-	SilentStructs& decoys() { return decoys_; };
-	SilentStructs const& decoys() const { return decoys_; };
+
 
 	///@brief call to insert structure at position given by iterator
 	void add_structure_at_position( SilentStructs::iterator iss, core::io::silent::SilentStructOP new_decoy );
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/ArchiveManager.cc patched/rosetta_source/src/protocols/jd2/archive/ArchiveManager.cc
--- vanilla/rosetta_source/src/protocols/jd2/archive/ArchiveManager.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/ArchiveManager.cc	2012-06-10 16:12:40.340051411 +0200
@@ -260,7 +260,7 @@ ArchiveManager::ArchiveManager( core::Si
   archive_rank_( archive_rank ),
 	jd_master_rank_( jd_master_rank ),
 	file_buf_rank_( file_buf_rank ),
-	save_archive_time_interval_( 5 )
+	save_archive_time_interval_( 60 )
 {
 	runtime_assert( options_registered_ );
 }
@@ -279,6 +279,7 @@ ArchiveManager::go( ArchiveBaseOP archiv
 	tr.Debug << "starting ArchiveManager ..." << archive_rank_ << " " << jd_master_rank_ << " " << file_buf_rank_ << std::endl;
 	theArchive_ = archive;
 	theArchive_->set_manager( this );
+	theArchive_->initialize();
 	mem_tr << "initialized IterativeAbrelax" << std::endl;
 	try {
 		if ( !restore_archive() ) {
@@ -305,12 +306,14 @@ ArchiveManager::go( ArchiveBaseOP archiv
 	bool stop( false );
 	bool print_status( true );
 	while ( !stop || unfinished_batches() ) {
-		if ( print_status ) {
+
+		if ( print_status && tr.Debug.visible() ) {
 			tr.Debug << "probing for message in ArchiveManager" << std::endl;
 			tr.Debug << "\nSTATUS: " << (stop ? "STOP send: " : "" ) << "  ------ unfinished_batches: " << unfinished_batches() << std::endl;
 			tr.Debug << "POOL_STATUS: " << std::endl;
 			theArchive_->save_status( tr.Debug );
 			tr.Debug << "END_STATUS\n\n"<< std::endl;
+			basic::show_time( tr,  "manager main msg-loop: probe for message..." );
 			print_status = false;
 		}
 		//is there a message ?
@@ -332,6 +335,7 @@ ArchiveManager::go( ArchiveBaseOP archiv
 		// 			//check if there is something this time...
 		// 			MPI_Iprobe( jd_master_rank_, MPI_ARCHIVE_TAG, MPI_COMM_WORLD, &flag, &status );
 		// 		}
+
 		try {
 			//if there is a message -- go get it.
 			int buf[ 6 ]={0,0,0,0,0,0};
@@ -340,7 +344,9 @@ ArchiveManager::go( ArchiveBaseOP archiv
 				int merrno = MPI_Recv( &buf, 6, MPI_INT, jd_master_rank_, MPI_ARCHIVE_TAG, MPI_COMM_WORLD, &status );
 				if ( merrno != MPI_SUCCESS ) tr.Error << "ERROR: MPI_Recv error " << std::endl;
 #endif
+				//				basic::show_time( tr,  "manager main msg-loop: received message..." );
 			}	else { //nothing received
+				//				basic::show_time( tr,  "manager main msg-loop: no message: idle..." );
 				idle();
 				continue;
 			}
@@ -356,9 +362,10 @@ ArchiveManager::go( ArchiveBaseOP archiv
 				Size const bad( buf[ 3 ] );
 				Size const good( buf[ 4 ] );
 				Size const total( buf[ 5 ] ); //total nr of jobs
+				basic::show_time( tr,  "ArchiveManager receveid job-completion..." );
 				tr.Debug << "ArchiveManager received JOB_COMPLETION " << batch_id << " " << bad << " " << good << " " << total << std::endl;
 				jobs_completed_[ batch_id ] = CompletionMessage( batch_id, final, bad, good, total );
-				break;
+				break; //switch
 			}
 			case QUEUE_EMPTY:	{
 				Size const batch_id( buf[ 1 ] );
@@ -373,22 +380,22 @@ ArchiveManager::go( ArchiveBaseOP archiv
 						--max_working_batch_id;
 					if ( batch_id <= max_working_batch_id ) {
 						tr.Info << "ArchiveManager ignored outdated QUEUE_EMPTY with batch_id " << batch_id << " -- already submitted " << batches_.size() << std::endl;
-						break;
+						break; //switch
 					}
 				}
 				//any job-completions we should work thru before generating a new batch?
 				PROF_START( basic::ARCHIVE_CRITICAL_JOBSCOMPLETE );
 				while ( jobs_completed_.size() ) {
 					jobs_completed(); //get thru these before making job decisions
-					theArchive_->idle();
 				}
 				PROF_STOP( basic::ARCHIVE_CRITICAL_JOBSCOMPLETE );
+				//		theArchive_->idle(); why was this in the job-completed loop ?
 
 				PROF_START( basic::ARCHIVE_GEN_BATCH );
 				//this is a valid QUEUE_EMPTY request: do something about it
 				tr.Info << "ArchiveManager received QUEUE_EMPTY" << std::endl;
 				tr.Debug << "JD batch_id: " << batch_id << " max_working_batch_id: " << max_working_batch_id << std::endl;
-
+				basic::show_time( tr,  "manager main msg-loop: queue empty..." );
 				if ( !theArchive_->finished() ) {
 					//if !finished Archive should always generate a batch...
 					//but let's make sure by monitoring, since it would be bad if we hang in the communication...
@@ -405,12 +412,13 @@ ArchiveManager::go( ArchiveBaseOP archiv
 				}
 				PROF_STOP( basic::ARCHIVE_GEN_BATCH );
 				basic::prof_show();
-				break;
+				break; //switch
 			}
 			default:
 				utility_exit_with_message( "unknown msg in ArchiveManager " + ObjexxFCL::string_of( msg_tag ) );
-			}
+			} //switch
 		} catch ( utility::excn::EXCN_Base &excn ) {
+			basic::show_time( tr,  "Exception in main msg-loop !" );
 			tr.Error << "[ERROR] " << excn.msg() << std::endl;
 			tr.Error << "spinning down" << std::endl;
 			save_archive();
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/#EvaluatedArchive.cc# patched/rosetta_source/src/protocols/jd2/archive/#EvaluatedArchive.cc#
--- vanilla/rosetta_source/src/protocols/jd2/archive/#EvaluatedArchive.cc#	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/#EvaluatedArchive.cc#	2012-06-10 16:12:40.343041151 +0200
@@ -0,0 +1,533 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file   protocols/jd2/MPIFileBufJobDistributor.cc
+/// @brief  implementation of MPIFileBufJobDistributor
+/// @author Oliver Lange olange@u.washington.edu
+
+// Unit headers
+#include <protocols/jd2/archive/EvaluatedArchive.hh>
+#include <protocols/jd2/archive/ArchiveManager.hh>
+#include <protocols/abinitio/VarianceStatisticsArchive.hh>
+
+#include <core/io/silent/SilentFileData.hh>
+
+#include <core/scoring/ScoreFunction.hh>
+//#include <core/scoring/constraints/ConstraintIO.hh>
+//#include <core/scoring/constraints/util.hh>
+#include <core/scoring/Energies.hh>
+
+#include <core/pose/Pose.hh>
+#include <basic/datacache/BasicDataCache.hh>
+
+#include <protocols/evaluation/EvaluatorFactory.hh>
+#include <protocols/evaluation/PoseEvaluator.hh>
+
+#include <utility/exit.hh>
+#include <utility/excn/Exceptions.hh>
+#include <numeric/util.hh>
+
+#include <basic/Tracer.hh>
+#include <basic/prof.hh>
+
+//for DebugArchive
+// AUTO-REMOVED #include <utility/io/ozstream.hh>
+
+#include <basic/options/option.hh>
+#include <basic/options/option_macros.hh>
+
+//for setup_default_evaluators
+#include <basic/options/keys/constraints.OptionKeys.gen.hh>
+// AUTO-REMOVED #include <basic/options/keys/jumps.OptionKeys.gen.hh>
+#include <basic/options/keys/in.OptionKeys.gen.hh>
+
+//#include <core/scoring/ResidualDipolarCoupling.hh>
+//#include <core/scoring/constraints/ConstraintSet.hh>
+#include <utility/vector1.hh>
+
+
+static basic::Tracer tr("protocols.jd2.Archive");
+
+//OPT_1GRP_KEY( Real, iterative, chainbreak_evaluator_exponent )
+//OPT_1GRP_KEY( Boolean, iterative, simulate_bg4_cbtreatment )
+OPT_1GRP_KEY( Boolean, iterative, evaluate_only_on_slaves )
+OPT_1GRP_KEY( Real, iterative, penalize_initial_decoys )
+OPT_1GRP_KEY( Boolean, iterative, normalize_scores )
+OPT_1GRP_KEY( Boolean, iterative, use_variance_archive  )
+std::string const SPECIAL_INITIAL_DECOY_PENALTY( "special_initial_decoy_penalty" );
+
+bool protocols::jd2::archive::EvaluatedArchive::options_registered_( false );
+
+//Mike: when you want to remove these Macros... leave them at least here as comment - since they provide documentation
+void protocols::jd2::archive::EvaluatedArchive::register_options() {
+	Parent::register_options();
+	if ( !options_registered_ ) {
+		//		NEW_OPT( iterative::chainbreak_evaluator_exponent, "exponent for nrjump_weighted_chainbreaks", 1.5 );
+		//	NEW_OPT( iterative::simulate_bg4_cbtreatment, "this gives special cb weights", false );
+		NEW_OPT( iterative::evaluate_only_on_slaves,"do not re-evaluate decoys when they are read into archvie (e.g. on BlueGene)", false );
+		NEW_OPT( iterative::penalize_initial_decoys, "decoys read from input_pool have X extra score", 1000.0 );
+		NEW_OPT( iterative::normalize_scores, "score-variations are determined to normalize scores", false );
+		NEW_OPT( iterative::use_variance_archive, "determine score variations from extra archive", false );
+		options_registered_ = true;
+	}
+}
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+// using namespace basic::options;
+// using namespace basic::options::OptionKeys;
+using namespace core;
+using namespace core::io::silent;
+
+EvaluatedArchive::~EvaluatedArchive() {}
+
+
+EvaluatedArchive::EvaluatedArchive()
+	: scorefxn_( NULL ),
+		b_evaluate_incoming_decoys_( !basic::options::option[ basic::options::OptionKeys::iterative::evaluate_only_on_slaves ]() ) ///yields bottleneck on BG
+{
+	runtime_assert( options_registered_ );
+	setup_default_evaluators();
+	score_variations_are_clean_ = false;
+}
+
+EvaluatedArchive::EvaluatedArchive( ArchiveManagerAP ptr )
+	: ArchiveBase( ptr ),
+		scorefxn_( NULL ),
+		b_evaluate_incoming_decoys_( !basic::options::option[ basic::options::OptionKeys::iterative::evaluate_only_on_slaves ]() ) ///yields bottleneck on BG
+{
+	runtime_assert( options_registered_ );
+	setup_default_evaluators();
+	score_variations_are_clean_ = false;
+}
+
+void EvaluatedArchive::start_evaluation_timer() const {
+	start_eval_time_ = time(NULL);
+	tr.Trace << "start evaluation" << std::endl;
+}
+
+bool EvaluatedArchive::add_structure( core::io::silent::SilentStructOP from_batch ) {
+	using namespace basic::options;
+	bool const bUseVarianceArchive( option[ OptionKeys::iterative::use_variance_archive ]() );
+
+	core::io::silent::SilentStructOP evaluated_decoy = evaluate_silent_struct( from_batch );
+	if ( !variance_archive_ && bUseVarianceArchive ) {
+		variance_archive_ = new VarianceStatisticsArchive( "variance_collector_"+name() );
+		variance_archive_->set_nstruct( 1000 );
+	}
+
+	if ( variance_archive_ && total_proposed() < 1000 ) {
+		variance_archive_->add_evaluated_structure( evaluated_decoy );
+	}
+	bool added( add_evaluated_structure( evaluated_decoy ) );
+	score_variations_are_clean_ = 	score_variations_are_clean_ && !added;
+	return added;
+}
+
+///@detail before we can apply score-fxn we have to add extra data: RDC, NOES, (not supported yet: PCS, ... )
+void EvaluatedArchive::score( pose::Pose & pose ) const {
+	scorefxn()( pose );
+}
+
+bool EvaluatedArchive::add_evaluated_structure( core::io::silent::SilentStructOP evaluated_decoy ) {
+	//get score
+	Real new_decoy_score ( select_score( evaluated_decoy ) );
+	if ( numeric::isnan( new_decoy_score ) ) return false;
+
+	//find position in sorted list to insert
+	SilentStructs::iterator iss = decoys().begin();
+	while ( iss != decoys().end() && new_decoy_score >= select_score( *iss ) ) ++iss;
+
+	//if we are at the end this decoy has a worse score than all others
+	if ( iss != decoys().end() || decoys().size() < nstruct() ) {
+		int now = time(NULL);
+		int eval_time = now-start_eval_time_;
+		evaluated_decoy->add_energy( "eval_time", 1.0*eval_time, 1.0 );
+		tr.Trace << "add evaluated structure " << evaluated_decoy->decoy_tag() << "  after " << eval_time << " seconds of evaluation."<< std::endl;
+		add_structure_at_position( iss, evaluated_decoy );
+		return true;
+	}
+	// here if score was not good enough to be added
+	return false;
+}
+
+//overloaded to add some tracer output
+void EvaluatedArchive::read_structures( core::io::silent::SilentFileData& sfd, Batch const& batch ) {
+	tr.Info << "structures are scored with the following weights: " << std::endl;
+	for ( WeightMap::const_iterator it=select_weights_.begin(); it != select_weights_.end(); ++it ) {
+		std::string const& name( it->first );
+		core::Real const& weight( it->second );
+		tr.Info << name << " " << weight << " " << weight/score_variations_[ name ] << std::endl;
+	}
+	if ( evaluate_local() ) {
+		tr.Info << "The score will be computed according to " << std::endl;
+		scorefxn().show_pretty( tr.Info );
+		tr.Info << std::endl;
+	}
+	Parent::read_structures( sfd, batch );
+	tr.Info << "finished reading structures for batch: " << batch.batch() << std::endl;
+
+	if ( variance_archive_ ) {
+		variance_archive_->set_weights( weights() );
+		variance_archive_->determine_score_variations();
+		set_score_variations( variance_archive_->score_variations() );
+	}
+
+	basic::prof_show();
+}
+
+///@details evaluate decoy... if non-local evaluation just copy silent-struct
+core::io::silent::SilentStructOP
+EvaluatedArchive::evaluate_silent_struct( core::io::silent::SilentStructOP iss ) const {
+	start_evaluation_timer();
+
+	//non-local evalution ? just return input
+	if ( !evaluate_local() ) {
+		tr.Trace << "don't evaluate local: trust energies saved in " << iss->decoy_tag() << std::endl;
+		return iss;
+	}
+
+	tr.Trace << "evaluate local for " << iss->decoy_tag() << std::endl;
+	core::io::silent::SilentStructOP pss = iss->clone();
+
+	//	pss->clear_energies(); //need to get rid of e.g., _archive_select_score_
+		//note: clear_energies should not kill the comments (TAG_IN_FILE, SOURCE_FILE ) should still be present...
+	//need to keep prefa_centroid_score...
+	using namespace core::io::silent;
+	utility::vector1< SilentEnergy > old_energies( pss->energies() );
+	//	runtime_assert( pss->has_energy( "chem_shifts" ) );
+	//make pose for scoring and evaluation purposes
+	PROF_START( basic::ARCHIVE_FILL_POSE );
+	pose::Pose pose;
+	pss->fill_pose( pose ); //has to reread RDC file for each pose!
+	pose.data().clear();
+	pose.energies().clear();
+	PROF_STOP( basic::ARCHIVE_FILL_POSE );
+
+	//now evaluate the pose
+	pss = evaluate_pose( pss, pose );
+
+
+	for ( utility::vector1< SilentEnergy >::const_iterator it = old_energies.begin(); it != old_energies.end(); ++it ) {
+		if ( it->name() != "_archive_select_score_" && !pss->has_energy( it->name() )) {
+			pss->add_energy( it->name(), it->value(), it->weight() );
+		}
+	}
+	//runtime_assert( pss->has_energy( "chem_shifts" ) );
+	int total_time = 0;
+	if ( pss->has_energy( "total_eval_time" ) ) {
+		int total_time = pss->get_energy( "total_eval_time" );
+	}
+	total_time += time(NULL)-start_eval_time_;
+	pss->add_energy( "total_eval_time", total_time, 1.0 );
+	return pss;
+
+}
+
+///@detail evaluate a pose ... store info in iss (and return the same for convenience )
+core::io::silent::SilentStructOP
+EvaluatedArchive::evaluate_pose( core::io::silent::SilentStructOP iss, core::pose::Pose& pose ) const {
+	tr.Trace << "evaluate decoy " << iss->decoy_tag() << std::endl;
+
+	//apply scorefxn
+	PROF_START( basic::ARCHIVE_SCORE_POSE );
+	score( pose );
+	iss->energies_from_pose( pose );
+	PROF_STOP( basic::ARCHIVE_SCORE_POSE );
+
+	//apply evaluators
+	PROF_START( basic::ARCHIVE_EVALUATORS );
+ 	for ( EvaluatorMap::const_iterator it=evaluators_.begin(), eit=evaluators_.end();
+				it!=eit; ++it ) {
+		//		tr.Trace << "evaluate with " << it->first << std::endl;
+		//		basic::DynamicProfileThis here( "Evaluate "+it->first );
+		it->second->apply( pose, iss->decoy_tag(), *iss );
+	}
+	PROF_STOP( basic::ARCHIVE_EVALUATORS );
+
+	return iss;
+}
+
+///@detail compute the score of an evaluated decoy
+Real EvaluatedArchive::select_score( SilentStructOP evaluated_decoy ) {
+
+	///are cached scores clean ?
+	if ( !scores_are_clean_ && evaluate_local() ) rescore();
+
+	///is there a cached score for this decoy ?
+	if ( evaluated_decoy->has_energy( "_archive_select_score_" ) ) {
+		return evaluated_decoy->get_energy( "_archive_select_score_" );
+	}
+
+	///no cached score: compute score and cache it
+	Real sum( 0.0 );
+
+	///sum all enegy terms to get 'archive_select_score' ---- iterate over evaluators
+	for ( WeightMap::const_iterator it=select_weights_.begin(); it != select_weights_.end(); ++it ) {
+		std::string const& name( it->first );
+		Real const& weight( it->second );
+		if ( weight == 0.0 ) continue;
+
+		if ( name == SPECIAL_INITIAL_DECOY_PENALTY ) {		///special evaluator name--- compute score-contribution for this one
+			//crude hack to test things out ...
+			if ( evaluated_decoy->get_comment( "source_file" ).find( "batch_000000/" ) != std::string::npos ) {
+				sum += weight;
+			}
+		} else { //normal score-contribution --- column should be present
+			if ( !evaluated_decoy->has_energy( name ) ) {
+				throw EXCN_Archive( "energy name "+name+" not found in returned decoys -- run with rescoring in archive to avoid this or fix your batches" );
+			} // add weighted column-value to final score
+			if ( weight > 0.01 ) {
+				sum += weight * evaluated_decoy->get_energy( name ) / score_variations_[ name ];
+			}
+		}
+	}
+
+	//tracer output with full result
+	tr.Trace << "evaluated select_score for " << evaluated_decoy->decoy_tag()
+					 << " that was tagged as " << evaluated_decoy->get_comment( "tag_in_file")
+					 << " : " << sum << " with " << select_weights_.size() << " evaluators" << std::endl;
+
+	//add energy to cache
+	evaluated_decoy->add_energy( "_archive_select_score_", sum );
+	return sum;
+}
+
+
+///@detail restore archive and sort
+bool EvaluatedArchive::restore_from_file() {
+	bool b_have_restored = Parent::restore_from_file();
+	sort();
+	return b_have_restored;
+}
+
+// ---------------------- sort archive -------------------
+
+class SortPredicate {
+public:
+	SortPredicate( EvaluatedArchive& arc ) : arc_( arc ) {};
+	bool operator() (SilentStructOP const& pss1, SilentStructOP const& pss2 ) {
+		return arc_.select_score( pss1 ) < arc_.select_score( pss2 );
+	}
+	EvaluatedArchive& arc_;
+};
+
+void EvaluatedArchive::sort() {
+	decoys().sort( SortPredicate( *this ) );
+}
+
+// --------------------------- end sort ------------------------------
+
+///@detail determine variations of the non-zero weighted (select_weight_) scores by taking the difference Q3-Q1 (upper / lower quartil)
+bool EvaluatedArchive::determine_score_variations() const {
+	if ( !basic::options::option[ basic::options::OptionKeys::iterative::normalize_scores ]() ) return false;
+	if ( variance_archive_ ) {
+		variance_archive_->set_weights( weights() );
+		bool changed( variance_archive_->determine_score_variations() );
+		if ( changed ) score_variations_=variance_archive_->score_variations();
+		return changed;
+	}
+	if ( score_variations_are_clean_ ) return false; //not changed
+	score_variations_are_clean_ = true;
+	tr.Info << "determine score variations in EvaluatedArchive " << name() << "... " << std::endl;
+	score_variations_.clear();
+	core::Size ndecoys( decoys().size() );
+	core::Size half( ndecoys / 2 );
+	core::Size lowQ( half / 2 );
+	core::Size highQ( half + lowQ );
+	utility::vector1<core::Real> values( ndecoys );
+	for ( WeightMap::const_iterator it = select_weights_.begin(); it != select_weights_.end(); ++it ) {
+		if ( it->first == "special_initial_decoy_penalty" ) continue;
+		if ( it->second > 0.01 ) {
+			std::string const& name( it->first );
+			Size ct( 1 );
+			for ( SilentStructs::const_iterator iss = decoys().begin(); iss != decoys().end(); ++iss, ++ct ) {
+				if ( !(*iss)->has_energy( name ) ) {
+					throw EXCN_Archive( "energy name "+name+" not found in returned decoys -- run with rescoring in archive to avoid this or fix your batches" );
+				} // add weighted column-value to final score
+				values[ct]=(*iss)->get_energy( name );
+			}
+			if ( ndecoys > 5 ) {
+				runtime_assert( lowQ > 0 && highQ < ndecoys );
+				std::sort(values.begin(), values.end());
+				score_variations_[ it->first ] = std::abs( values[highQ]-values[lowQ] );
+				tr.Info << "score variation of " << score_variations_[ it->first ] << " for " << name
+								<< " between " << values[lowQ]  << " at " << lowQ
+								<< " and "     << values[highQ] << " at " << highQ << std::endl;
+			} else { //not enough decoys
+				score_variations_[ it->first ] = 1.0;
+			}
+			if ( score_variations_[ it->first ]< 1e-20 ) {
+				score_variations_[ it->first ]= 1e-20;
+			}
+		} // if weight > 0.01
+	} //for select_weights
+	return true; //changed
+} //determine_score_variations
+
+
+///@detail rescore and sort archive
+void EvaluatedArchive::rescore() {
+	tr.Debug << "rescore " << name() << " decoys " << std::endl;
+
+	//rescore all decoys
+	for ( SilentStructs::iterator iss = decoys().begin(); iss != decoys().end(); ++iss ) {
+		*iss = evaluate_silent_struct( *iss ); //_archive_select_score_ will be removed here
+	}
+	scores_are_clean_ = true; //do this first, since SortPredicate asks for the select_score
+	score_variations_are_clean_ = false;
+	if ( variance_archive_ ) {
+		variance_archive_->set_evaluators( evaluators(), weights() );
+		variance_archive_->rescore();
+	}
+
+	sort(); //here the summing is done via select_score() and a new _archive_select_score_ is computed
+
+	tr.Debug << "...done rescoring and sorting " << std::endl;
+// 	if ( tr.Trace.visible() ) {
+// 		for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+// 			tr.Trace << select_score( *it ) << " " << (*it)->decoy_tag() << std::endl;
+// 		}
+// 	}
+}
+
+
+/* =================== maintenance of evaluators and weights ====================== */
+
+void EvaluatedArchive::add_evaluation( evaluation::PoseEvaluatorCOP eval, Real weight ) {
+	tr.Info << "added evaluator " << eval->name( 1 ) << " with weight " << weight << " to EvaluatedArchive " << name() << std::endl;
+	for ( Size i=1; i<= eval->size(); i++ ) {
+		std::string const& column( eval->name( i ) );
+		set_weight( column, weight );
+		evaluators_[ column ] = eval;
+	}
+	scores_are_clean_ = false;
+}
+
+void EvaluatedArchive::remove_evaluation( std::string const& name ) {
+	std::string const& column( name );
+
+	EvaluatorMap::iterator iter = evaluators_.find( column );
+	if ( iter != evaluators_.end() ) 	evaluators_.erase( iter );
+
+	WeightMap::iterator iter2 = select_weights_.find( column );
+	if ( iter2 != select_weights_.end() ) select_weights_.erase( iter2 );
+
+	scores_are_clean_ = false;
+}
+
+void EvaluatedArchive::set_weight( std::string const& column, core::Real weight ) {
+	//	runtime_assert( has_evaluator( column ) ); or part of score!
+	if ( has_weigth( column ) && select_weights_[ column ] ) 
+	select_weights_[ column ] = weight;
+	if ( weight > 0.01 ) {
+		score_variations_[ column ] = 1.0; // to make sure we have a value ( e.g., in case we do no local evaluation )
+		score_variations_are_clean_ = false;
+		scores_are_clean_ = false; //need to re-determine the score-variations
+	}
+}
+
+
+void EvaluatedArchive::set_weights( WeightMap const& setting ) {
+	select_weights_.clear();
+	for ( WeightMap::const_iterator it = setting.begin(); it != setting.end(); ++it ) {
+		set_weight( it->first, it->second );
+	}
+}
+
+EvaluatedArchive::WeightMap const& EvaluatedArchive::score_variations() const {
+	determine_score_variations();
+	if ( variance_archive_ ) {
+		return variance_archive_->score_variations();
+	}
+	return score_variations_;
+}
+
+void EvaluatedArchive::set_score_variations( WeightMap const& setting ) {
+	score_variations_=setting;
+}
+
+void EvaluatedArchive::set_evaluators( EvaluatorMap const& evaluators, WeightMap const& weights ) {
+	evaluators_.clear();
+	for ( EvaluatorMap::const_iterator it = evaluators.begin(); it != evaluators.end(); ++it ) {
+		WeightMap::const_iterator itfind=weights.find( it->first );
+		add_evaluation( it->second, itfind->second );
+	}
+}
+
+core::Real EvaluatedArchive::get_weight( std::string const& column ) const {
+	//	runtime_assert( has_evaluator( column ) ); or part of score!
+	WeightMap::const_iterator iter = select_weights_.find( column );
+	if ( iter != select_weights_.end() ) return iter->second;
+	else return 0.0;
+}
+
+core::Real EvaluatedArchive::score_variation( std::string const& column ) const {
+	determine_score_variations();
+	if ( variance_archive_ ) {
+		variance_archive_->score_variation( column );
+	}
+	WeightMap::const_iterator iter = score_variations_.find( column );
+	if ( iter != score_variations_.end() ) return iter->second;
+	else return 1.0;
+}
+
+bool EvaluatedArchive::has_evaluator( std::string const& column ) {
+	EvaluatorMap::const_iterator iter = evaluators_.find( column );
+	return iter != evaluators_.end();
+}
+
+void EvaluatedArchive::set_scorefxn( core::scoring::ScoreFunctionOP scorefxn ) {
+	scorefxn_ = scorefxn;
+	scores_are_clean_ = false;
+}
+
+core::scoring::ScoreFunction const &
+EvaluatedArchive::scorefxn() const {
+	runtime_assert( scorefxn_ );
+	return *scorefxn_;
+}
+
+core::scoring::ScoreFunctionOP
+EvaluatedArchive::scorefxn_non_const() {
+	runtime_assert( scorefxn_ );
+	return scorefxn_;
+}
+
+void EvaluatedArchive::setup_default_evaluators() {
+	using namespace basic::options;
+	using namespace basic::options::OptionKeys;
+	//using namespace scoring::constraints;
+// 	if ( evaluate_local() && option[ constraints::cst_file ].user() ) {
+// 		std::string filename( option[ constraints::cst_file ]()[ 1 ] );
+// 		evaluation::PoseEvaluatorOP ev_cst ( new evaluation::ConstraintEvaluator( "cmdline", filename ) );
+// 		add_evaluation( ev_cst, option[ constraints::cst_weight ] );
+// 		//The ConstraintEvaluator creates two columns: cmdline_cst and cmdline_viol...
+// 		set_weight( "cmdline_viol", 0.0 );
+// 	}
+	set_weight( "score", 1.0 );
+	if ( option[ OptionKeys::iterative::penalize_initial_decoys ]() > 0.0 ) {
+		set_weight( SPECIAL_INITIAL_DECOY_PENALTY , option[ OptionKeys::iterative::penalize_initial_decoys ]() );
+	}
+
+	//	evaluation::MetaPoseEvaluator cmdline_evals;
+	//	evaluation::EvaluatorFactory::get_instance()->add_all_evaluators(cmdline_evals);
+	//	for ( evaluation::MetaPoseEvaluator::EvaluatorList::const_iterator it = cmdline_evals.evaluators().begin();
+	//				it != cmdline_evals.evaluators().end(); ++it ) {
+	// 		add_evaluation( *it );
+	//	}
+}
+
+/* =================== end maintenance of evaluators and weights ====================== */
+
+
+}//archive
+}//jd2
+}//protocols
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.cc patched/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.cc
--- vanilla/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.cc	2012-06-10 16:12:40.346041217 +0200
@@ -13,6 +13,7 @@
 // Unit headers
 #include <protocols/jd2/archive/EvaluatedArchive.hh>
 #include <protocols/jd2/archive/ArchiveManager.hh>
+#include <protocols/jd2/archive/VarianceStatisticsArchive.hh>
 
 #include <core/io/silent/SilentFileData.hh>
 
@@ -56,7 +57,6 @@ static basic::Tracer tr("protocols.jd2.A
 //OPT_1GRP_KEY( Boolean, iterative, simulate_bg4_cbtreatment )
 OPT_1GRP_KEY( Boolean, iterative, evaluate_only_on_slaves )
 OPT_1GRP_KEY( Real, iterative, penalize_initial_decoys )
-
 std::string const SPECIAL_INITIAL_DECOY_PENALTY( "special_initial_decoy_penalty" );
 
 bool protocols::jd2::archive::EvaluatedArchive::options_registered_( false );
@@ -73,6 +73,10 @@ void protocols::jd2::archive::EvaluatedA
 	}
 }
 
+#define OBSOLETE(key)														\
+	if ( basic::options::option[ key ].user() ) {													\
+		tr.Warning << "WARNING: Option "<< #key<< " is deprecated!" << std::endl; \
+	}
 
 namespace protocols {
 namespace jd2 {
@@ -91,6 +95,7 @@ EvaluatedArchive::EvaluatedArchive()
 {
 	runtime_assert( options_registered_ );
 	setup_default_evaluators();
+	OBSOLETE(basic::options::OptionKeys::iterative::evaluate_only_on_slaves)
 }
 
 EvaluatedArchive::EvaluatedArchive( ArchiveManagerAP ptr )
@@ -102,10 +107,22 @@ EvaluatedArchive::EvaluatedArchive( Arch
 	setup_default_evaluators();
 }
 
+void EvaluatedArchive::start_evaluation_timer() const {
+	start_eval_time_ = time(NULL);
+	tr.Trace << "start evaluation" << std::endl;
+}
 
 bool EvaluatedArchive::add_structure( core::io::silent::SilentStructOP from_batch ) {
+	using namespace basic::options;
+	tr.Info << "add structure" << std::endl;
 	core::io::silent::SilentStructOP evaluated_decoy = evaluate_silent_struct( from_batch );
-	return add_evaluated_structure( evaluated_decoy );
+	bool added( add_evaluated_structure( evaluated_decoy ) );
+	return added;
+}
+
+///@detail before we can apply score-fxn we have to add extra data: RDC, NOES, (not supported yet: PCS, ... )
+void EvaluatedArchive::score( pose::Pose & pose ) const {
+	scorefxn()( pose );
 }
 
 bool EvaluatedArchive::add_evaluated_structure( core::io::silent::SilentStructOP evaluated_decoy ) {
@@ -119,6 +136,10 @@ bool EvaluatedArchive::add_evaluated_str
 
 	//if we are at the end this decoy has a worse score than all others
 	if ( iss != decoys().end() || decoys().size() < nstruct() ) {
+		int now = time(NULL);
+		int eval_time = now-start_eval_time_;
+		evaluated_decoy->add_energy( "eval_time", 1.0*eval_time, 1.0 );
+		tr.Trace << "add evaluated structure " << evaluated_decoy->decoy_tag() << "  after " << eval_time << " seconds of evaluation."<< std::endl;
 		add_structure_at_position( iss, evaluated_decoy );
 		return true;
 	}
@@ -129,17 +150,30 @@ bool EvaluatedArchive::add_evaluated_str
 //overloaded to add some tracer output
 void EvaluatedArchive::read_structures( core::io::silent::SilentFileData& sfd, Batch const& batch ) {
 	tr.Info << "structures are scored with the following weights: " << std::endl;
+	WeightMap const& variations( score_variations() );
 	for ( WeightMap::const_iterator it=select_weights_.begin(); it != select_weights_.end(); ++it ) {
 		std::string const& name( it->first );
 		core::Real const& weight( it->second );
-		tr.Info << name << " " << weight << std::endl;
+		tr.Info << name << " " << weight << " " << weight / variations.find( name )->second << std::endl;
+	}
+	if ( evaluate_local() ) {
+		tr.Info << "The score will be computed according to " << std::endl;
+		scorefxn().show_pretty( tr.Info );
+		tr.Info << std::endl;
 	}
 	Parent::read_structures( sfd, batch );
+	tr.Info << "finished reading structures for batch: " << batch.batch() << std::endl;
+
+	basic::prof_show();
 }
 
+
+
+
 ///@details evaluate decoy... if non-local evaluation just copy silent-struct
 core::io::silent::SilentStructOP
 EvaluatedArchive::evaluate_silent_struct( core::io::silent::SilentStructOP iss ) const {
+	start_evaluation_timer();
 
 	//non-local evalution ? just return input
 	if ( !evaluate_local() ) {
@@ -155,7 +189,7 @@ EvaluatedArchive::evaluate_silent_struct
 	//need to keep prefa_centroid_score...
 	using namespace core::io::silent;
 	utility::vector1< SilentEnergy > old_energies( pss->energies() );
-
+	//	runtime_assert( pss->has_energy( "chem_shifts" ) );
 	//make pose for scoring and evaluation purposes
 	PROF_START( basic::ARCHIVE_FILL_POSE );
 	pose::Pose pose;
@@ -167,12 +201,19 @@ EvaluatedArchive::evaluate_silent_struct
 	//now evaluate the pose
 	pss = evaluate_pose( pss, pose );
 
-	//add all old energy terms that have not been re-computed, e.g., prefa_centroid_score
+
 	for ( utility::vector1< SilentEnergy >::const_iterator it = old_energies.begin(); it != old_energies.end(); ++it ) {
 		if ( it->name() != "_archive_select_score_" && !pss->has_energy( it->name() )) {
 			pss->add_energy( it->name(), it->value(), it->weight() );
 		}
 	}
+	//runtime_assert( pss->has_energy( "chem_shifts" ) );
+	int total_time = 0;
+	if ( pss->has_energy( "total_eval_time" ) ) {
+		int total_time = pss->get_energy( "total_eval_time" );
+	}
+	total_time += time(NULL)-start_eval_time_;
+	pss->add_energy( "total_eval_time", total_time, 1.0 );
 	return pss;
 
 }
@@ -192,6 +233,8 @@ EvaluatedArchive::evaluate_pose( core::i
 	PROF_START( basic::ARCHIVE_EVALUATORS );
  	for ( EvaluatorMap::const_iterator it=evaluators_.begin(), eit=evaluators_.end();
 				it!=eit; ++it ) {
+		//		tr.Trace << "evaluate with " << it->first << std::endl;
+		//		basic::DynamicProfileThis here( "Evaluate "+it->first );
 		it->second->apply( pose, iss->decoy_tag(), *iss );
 	}
 	PROF_STOP( basic::ARCHIVE_EVALUATORS );
@@ -212,8 +255,8 @@ Real EvaluatedArchive::select_score( Sil
 
 	///no cached score: compute score and cache it
 	Real sum( 0.0 );
-
-	///iterate over evaluators
+	WeightMap const& variations( score_variations() );
+	///sum all enegy terms to get 'archive_select_score' ---- iterate over evaluators
 	for ( WeightMap::const_iterator it=select_weights_.begin(); it != select_weights_.end(); ++it ) {
 		std::string const& name( it->first );
 		Real const& weight( it->second );
@@ -228,7 +271,9 @@ Real EvaluatedArchive::select_score( Sil
 			if ( !evaluated_decoy->has_energy( name ) ) {
 				throw EXCN_Archive( "energy name "+name+" not found in returned decoys -- run with rescoring in archive to avoid this or fix your batches" );
 			} // add weighted column-value to final score
-			sum += weight * evaluated_decoy->get_energy( name );
+			if ( weight > 0.01 ) {
+				sum += weight * evaluated_decoy->get_energy( name ) / variations.find( name )->second;
+			}
 		}
 	}
 
@@ -242,6 +287,9 @@ Real EvaluatedArchive::select_score( Sil
 	return sum;
 }
 
+void EvaluatedArchive::save_to_file( std::string suffix ) {
+	Parent::save_to_file( suffix );
+}
 
 ///@detail restore archive and sort
 bool EvaluatedArchive::restore_from_file() {
@@ -274,11 +322,11 @@ void EvaluatedArchive::rescore() {
 
 	//rescore all decoys
 	for ( SilentStructs::iterator iss = decoys().begin(); iss != decoys().end(); ++iss ) {
-		*iss = evaluate_silent_struct( *iss );
+		*iss = evaluate_silent_struct( *iss ); //_archive_select_score_ will be removed here
 	}
 	scores_are_clean_ = true; //do this first, since SortPredicate asks for the select_score
+	sort(); //here the summing is done via select_score() and a new _archive_select_score_ is computed
 
-	sort();
 	tr.Debug << "...done rescoring and sorting " << std::endl;
 // 	if ( tr.Trace.visible() ) {
 // 		for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
@@ -290,38 +338,73 @@ void EvaluatedArchive::rescore() {
 
 /* =================== maintenance of evaluators and weights ====================== */
 
-void EvaluatedArchive::add_evaluation( evaluation::PoseEvaluatorOP eval, Real weight ) {
+void EvaluatedArchive::add_evaluation( evaluation::PoseEvaluatorCOP eval, Real weight ) {
+	tr.Info << "added evaluator " << eval->name( 1 ) << " with weight " << weight << " to EvaluatedArchive " << name() << std::endl;
 	for ( Size i=1; i<= eval->size(); i++ ) {
 		std::string const& column( eval->name( i ) );
-		select_weights_[ column ] = weight;
+		set_weight( column, weight );
 		evaluators_[ column ] = eval;
 	}
 	scores_are_clean_ = false;
 }
 
 void EvaluatedArchive::remove_evaluation( std::string const& name ) {
+	tr.Info << "remve evaluator " << name << std::endl;
 	std::string const& column( name );
 
 	EvaluatorMap::iterator iter = evaluators_.find( column );
 	if ( iter != evaluators_.end() ) 	evaluators_.erase( iter );
 
 	WeightMap::iterator iter2 = select_weights_.find( column );
-	if ( iter2 != select_weights_.end() ) select_weights_.erase( iter2 );
-
-	scores_are_clean_ = false;
+	if ( iter2 != select_weights_.end() ) {
+		select_weights_.erase( iter2 );
+		if ( iter2->second > 0.001 ) scores_are_clean_ = false;
+	}
 }
 
 void EvaluatedArchive::set_weight( std::string const& column, core::Real weight ) {
+	tr.Info << "set_weight " << column << " to " << weight << " in " << name() << std::endl;
 	//	runtime_assert( has_evaluator( column ) ); or part of score!
+	WeightMap::const_iterator iter = select_weights_.find( column );
+	if ( iter != select_weights_.end() && std::abs( iter->second - weight ) < 0.001 ) return;
+	tr.Info << "set_weight " << column << " to " << weight << " in " << name() << std::endl;
 	select_weights_[ column ] = weight;
+	if ( weight > 0.01 ) {
+		dummy_score_variations_[ column ] = 1.0; // to make sure we have a value ( e.g., in case we do no local evaluation )
+		scores_are_clean_ = false; //need to re-determine the score-variations
+		invalidate_score_variations();
+	}
+}
+
+
+void EvaluatedArchive::set_weights( WeightMap const& setting ) {
+	select_weights_.clear();
+	for ( WeightMap::const_iterator it = setting.begin(); it != setting.end(); ++it ) {
+		set_weight( it->first, it->second );
+	}
 }
 
-core::Real EvaluatedArchive::get_weight( std::string const& column ) {
+EvaluatedArchive::WeightMap const& EvaluatedArchive::score_variations() const {
+	return dummy_score_variations_;
+}
+
+void EvaluatedArchive::set_evaluators( EvaluatorMap const& evaluators, WeightMap const& weights ) {
+	evaluators_.clear();
+	for ( EvaluatorMap::const_iterator it = evaluators.begin(); it != evaluators.end(); ++it ) {
+		WeightMap::const_iterator itfind=weights.find( it->first );
+		add_evaluation( it->second, itfind->second );
+	}
+}
+
+core::Real EvaluatedArchive::get_weight( std::string const& column ) const {
 	//	runtime_assert( has_evaluator( column ) ); or part of score!
-	if ( has_evaluator( column ) ) {
-		return select_weights_[ column ];
-	};
-	return 0.0;
+	WeightMap::const_iterator iter = select_weights_.find( column );
+	if ( iter != select_weights_.end() ) return iter->second;
+	else return 0.0;
+}
+
+core::Real EvaluatedArchive::score_variation( std::string const& column ) const {
+	return 1.0;
 }
 
 bool EvaluatedArchive::has_evaluator( std::string const& column ) {
@@ -362,12 +445,12 @@ void EvaluatedArchive::setup_default_eva
 		set_weight( SPECIAL_INITIAL_DECOY_PENALTY , option[ OptionKeys::iterative::penalize_initial_decoys ]() );
 	}
 
-	evaluation::MetaPoseEvaluator cmdline_evals;
-	evaluation::EvaluatorFactory::get_instance()->add_all_evaluators(cmdline_evals);
-	for ( evaluation::MetaPoseEvaluator::EvaluatorList::const_iterator it = cmdline_evals.evaluators().begin();
-				it != cmdline_evals.evaluators().end(); ++it ) {
- 		add_evaluation( *it );
-	}
+	//	evaluation::MetaPoseEvaluator cmdline_evals;
+	//	evaluation::EvaluatorFactory::get_instance()->add_all_evaluators(cmdline_evals);
+	//	for ( evaluation::MetaPoseEvaluator::EvaluatorList::const_iterator it = cmdline_evals.evaluators().begin();
+	//				it != cmdline_evals.evaluators().end(); ++it ) {
+	// 		add_evaluation( *it );
+	//	}
 }
 
 /* =================== end maintenance of evaluators and weights ====================== */
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.cc.backup patched/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.cc.backup
--- vanilla/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.cc.backup	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.cc.backup	2012-06-10 16:12:40.349072809 +0200
@@ -0,0 +1,548 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file   protocols/jd2/MPIFileBufJobDistributor.cc
+/// @brief  implementation of MPIFileBufJobDistributor
+/// @author Oliver Lange olange@u.washington.edu
+
+// Unit headers
+#include <protocols/jd2/archive/EvaluatedArchive.hh>
+#include <protocols/jd2/archive/ArchiveManager.hh>
+#include <protocols/abinitio/VarianceStatisticsArchive.hh>
+
+#include <core/io/silent/SilentFileData.hh>
+
+#include <core/scoring/ScoreFunction.hh>
+//#include <core/scoring/constraints/ConstraintIO.hh>
+//#include <core/scoring/constraints/util.hh>
+#include <core/scoring/Energies.hh>
+
+#include <core/pose/Pose.hh>
+#include <basic/datacache/BasicDataCache.hh>
+
+#include <protocols/evaluation/EvaluatorFactory.hh>
+#include <protocols/evaluation/PoseEvaluator.hh>
+
+#include <utility/exit.hh>
+#include <utility/excn/Exceptions.hh>
+#include <numeric/util.hh>
+
+#include <basic/Tracer.hh>
+#include <basic/prof.hh>
+
+//for DebugArchive
+// AUTO-REMOVED #include <utility/io/ozstream.hh>
+
+#include <basic/options/option.hh>
+#include <basic/options/option_macros.hh>
+
+//for setup_default_evaluators
+#include <basic/options/keys/constraints.OptionKeys.gen.hh>
+// AUTO-REMOVED #include <basic/options/keys/jumps.OptionKeys.gen.hh>
+#include <basic/options/keys/in.OptionKeys.gen.hh>
+
+//#include <core/scoring/ResidualDipolarCoupling.hh>
+//#include <core/scoring/constraints/ConstraintSet.hh>
+#include <utility/vector1.hh>
+
+
+static basic::Tracer tr("protocols.jd2.Archive");
+
+//OPT_1GRP_KEY( Real, iterative, chainbreak_evaluator_exponent )
+//OPT_1GRP_KEY( Boolean, iterative, simulate_bg4_cbtreatment )
+OPT_1GRP_KEY( Boolean, iterative, evaluate_only_on_slaves )
+OPT_1GRP_KEY( Real, iterative, penalize_initial_decoys )
+OPT_1GRP_KEY( Boolean, iterative, normalize_scores )
+OPT_1GRP_KEY( Boolean, iterative, use_variance_archive  )
+std::string const SPECIAL_INITIAL_DECOY_PENALTY( "special_initial_decoy_penalty" );
+
+bool protocols::jd2::archive::EvaluatedArchive::options_registered_( false );
+
+//Mike: when you want to remove these Macros... leave them at least here as comment - since they provide documentation
+void protocols::jd2::archive::EvaluatedArchive::register_options() {
+	Parent::register_options();
+	if ( !options_registered_ ) {
+		//		NEW_OPT( iterative::chainbreak_evaluator_exponent, "exponent for nrjump_weighted_chainbreaks", 1.5 );
+		//	NEW_OPT( iterative::simulate_bg4_cbtreatment, "this gives special cb weights", false );
+		NEW_OPT( iterative::evaluate_only_on_slaves,"do not re-evaluate decoys when they are read into archvie (e.g. on BlueGene)", false );
+		NEW_OPT( iterative::penalize_initial_decoys, "decoys read from input_pool have X extra score", 1000.0 );
+		NEW_OPT( iterative::normalize_scores, "score-variations are determined to normalize scores", false );
+		NEW_OPT( iterative::use_variance_archive, "determine score variations from extra archive", false );
+		options_registered_ = true;
+	}
+}
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+// using namespace basic::options;
+// using namespace basic::options::OptionKeys;
+using namespace core;
+using namespace core::io::silent;
+
+EvaluatedArchive::~EvaluatedArchive() {}
+
+
+EvaluatedArchive::EvaluatedArchive()
+	: scorefxn_( NULL ),
+		b_evaluate_incoming_decoys_( !basic::options::option[ basic::options::OptionKeys::iterative::evaluate_only_on_slaves ]() ) ///yields bottleneck on BG
+{
+	runtime_assert( options_registered_ );
+	setup_default_evaluators();
+	score_variations_are_clean_ = false;
+}
+
+EvaluatedArchive::EvaluatedArchive( ArchiveManagerAP ptr )
+	: ArchiveBase( ptr ),
+		scorefxn_( NULL ),
+		b_evaluate_incoming_decoys_( !basic::options::option[ basic::options::OptionKeys::iterative::evaluate_only_on_slaves ]() ) ///yields bottleneck on BG
+{
+	runtime_assert( options_registered_ );
+	setup_default_evaluators();
+	score_variations_are_clean_ = false;
+}
+
+void EvaluatedArchive::start_evaluation_timer() const {
+	start_eval_time_ = time(NULL);
+	tr.Trace << "start evaluation" << std::endl;
+}
+
+bool EvaluatedArchive::add_structure( core::io::silent::SilentStructOP from_batch ) {
+	using namespace basic::options;
+	bool const bUseVarianceArchive( option[ OptionKeys::iterative::use_variance_archive ]() );
+
+	core::io::silent::SilentStructOP evaluated_decoy = evaluate_silent_struct( from_batch );
+	if ( !variance_archive_ && bUseVarianceArchive ) {
+		variance_archive_ = new VarianceStatisticsArchive( "variance_collector_"+name() );
+		variance_archive_->set_nstruct( 1000 );
+	}
+
+	if ( variance_archive_ && total_proposed() < 1000 ) {
+		variance_archive_->add_evaluated_structure( evaluated_decoy );
+	}
+	bool added( add_evaluated_structure( evaluated_decoy ) );
+	score_variations_are_clean_ = 	score_variations_are_clean_ && !added;
+	return added;
+}
+
+///@detail before we can apply score-fxn we have to add extra data: RDC, NOES, (not supported yet: PCS, ... )
+void EvaluatedArchive::score( pose::Pose & pose ) const {
+	scorefxn()( pose );
+}
+
+bool EvaluatedArchive::add_evaluated_structure( core::io::silent::SilentStructOP evaluated_decoy ) {
+	//get score
+	Real new_decoy_score ( select_score( evaluated_decoy ) );
+	if ( numeric::isnan( new_decoy_score ) ) return false;
+
+	//find position in sorted list to insert
+	SilentStructs::iterator iss = decoys().begin();
+	while ( iss != decoys().end() && new_decoy_score >= select_score( *iss ) ) ++iss;
+
+	//if we are at the end this decoy has a worse score than all others
+	if ( iss != decoys().end() || decoys().size() < nstruct() ) {
+		int now = time(NULL);
+		int eval_time = now-start_eval_time_;
+		evaluated_decoy->add_energy( "eval_time", 1.0*eval_time, 1.0 );
+		tr.Trace << "add evaluated structure " << evaluated_decoy->decoy_tag() << "  after " << eval_time << " seconds of evaluation."<< std::endl;
+		add_structure_at_position( iss, evaluated_decoy );
+		return true;
+	}
+	// here if score was not good enough to be added
+	return false;
+}
+
+//overloaded to add some tracer output
+void EvaluatedArchive::read_structures( core::io::silent::SilentFileData& sfd, Batch const& batch ) {
+	tr.Info << "structures are scored with the following weights: " << std::endl;
+	for ( WeightMap::const_iterator it=select_weights_.begin(); it != select_weights_.end(); ++it ) {
+		std::string const& name( it->first );
+		core::Real const& weight( it->second );
+		tr.Info << name << " " << weight << " " << weight/score_variations_[ name ] << std::endl;
+	}
+	if ( evaluate_local() ) {
+		tr.Info << "The score will be computed according to " << std::endl;
+		scorefxn().show_pretty( tr.Info );
+		tr.Info << std::endl;
+	}
+	Parent::read_structures( sfd, batch );
+	tr.Info << "finished reading structures for batch: " << batch.batch() << std::endl;
+
+	if ( variance_archive_ ) {
+		variance_archive_->set_weights( weights() );
+		variance_archive_->determine_score_variations();
+		set_score_variations( variance_archive_->score_variations() );
+	}
+
+	basic::prof_show();
+}
+
+
+
+
+///@details evaluate decoy... if non-local evaluation just copy silent-struct
+core::io::silent::SilentStructOP
+EvaluatedArchive::evaluate_silent_struct( core::io::silent::SilentStructOP iss ) const {
+	start_evaluation_timer();
+
+	//non-local evalution ? just return input
+	if ( !evaluate_local() ) {
+		tr.Trace << "don't evaluate local: trust energies saved in " << iss->decoy_tag() << std::endl;
+		return iss;
+	}
+
+	tr.Trace << "evaluate local for " << iss->decoy_tag() << std::endl;
+	core::io::silent::SilentStructOP pss = iss->clone();
+
+	//	pss->clear_energies(); //need to get rid of e.g., _archive_select_score_
+		//note: clear_energies should not kill the comments (TAG_IN_FILE, SOURCE_FILE ) should still be present...
+	//need to keep prefa_centroid_score...
+	using namespace core::io::silent;
+	utility::vector1< SilentEnergy > old_energies( pss->energies() );
+	//	runtime_assert( pss->has_energy( "chem_shifts" ) );
+	//make pose for scoring and evaluation purposes
+	PROF_START( basic::ARCHIVE_FILL_POSE );
+	pose::Pose pose;
+	pss->fill_pose( pose ); //has to reread RDC file for each pose!
+	pose.data().clear();
+	pose.energies().clear();
+	PROF_STOP( basic::ARCHIVE_FILL_POSE );
+
+	//now evaluate the pose
+	pss = evaluate_pose( pss, pose );
+
+
+	for ( utility::vector1< SilentEnergy >::const_iterator it = old_energies.begin(); it != old_energies.end(); ++it ) {
+		if ( it->name() != "_archive_select_score_" && !pss->has_energy( it->name() )) {
+			pss->add_energy( it->name(), it->value(), it->weight() );
+		}
+	}
+	//runtime_assert( pss->has_energy( "chem_shifts" ) );
+	int total_time = 0;
+	if ( pss->has_energy( "total_eval_time" ) ) {
+		int total_time = pss->get_energy( "total_eval_time" );
+	}
+	total_time += time(NULL)-start_eval_time_;
+	pss->add_energy( "total_eval_time", total_time, 1.0 );
+	return pss;
+
+}
+
+///@detail evaluate a pose ... store info in iss (and return the same for convenience )
+core::io::silent::SilentStructOP
+EvaluatedArchive::evaluate_pose( core::io::silent::SilentStructOP iss, core::pose::Pose& pose ) const {
+	tr.Trace << "evaluate decoy " << iss->decoy_tag() << std::endl;
+
+	//apply scorefxn
+	PROF_START( basic::ARCHIVE_SCORE_POSE );
+	score( pose );
+	iss->energies_from_pose( pose );
+	PROF_STOP( basic::ARCHIVE_SCORE_POSE );
+
+	//apply evaluators
+	PROF_START( basic::ARCHIVE_EVALUATORS );
+ 	for ( EvaluatorMap::const_iterator it=evaluators_.begin(), eit=evaluators_.end();
+				it!=eit; ++it ) {
+		//		tr.Trace << "evaluate with " << it->first << std::endl;
+		//		basic::DynamicProfileThis here( "Evaluate "+it->first );
+		it->second->apply( pose, iss->decoy_tag(), *iss );
+	}
+	PROF_STOP( basic::ARCHIVE_EVALUATORS );
+
+	return iss;
+}
+
+///@detail compute the score of an evaluated decoy
+Real EvaluatedArchive::select_score( SilentStructOP evaluated_decoy ) {
+
+	///are cached scores clean ?
+	if ( !scores_are_clean_ && evaluate_local() ) rescore();
+
+	///is there a cached score for this decoy ?
+	if ( evaluated_decoy->has_energy( "_archive_select_score_" ) ) {
+		return evaluated_decoy->get_energy( "_archive_select_score_" );
+	}
+
+	///no cached score: compute score and cache it
+	Real sum( 0.0 );
+
+	///sum all enegy terms to get 'archive_select_score' ---- iterate over evaluators
+	for ( WeightMap::const_iterator it=select_weights_.begin(); it != select_weights_.end(); ++it ) {
+		std::string const& name( it->first );
+		Real const& weight( it->second );
+		if ( weight == 0.0 ) continue;
+
+		if ( name == SPECIAL_INITIAL_DECOY_PENALTY ) {		///special evaluator name--- compute score-contribution for this one
+			//crude hack to test things out ...
+			if ( evaluated_decoy->get_comment( "source_file" ).find( "batch_000000/" ) != std::string::npos ) {
+				sum += weight;
+			}
+		} else { //normal score-contribution --- column should be present
+			if ( !evaluated_decoy->has_energy( name ) ) {
+				throw EXCN_Archive( "energy name "+name+" not found in returned decoys -- run with rescoring in archive to avoid this or fix your batches" );
+			} // add weighted column-value to final score
+			if ( weight > 0.01 ) {
+				sum += weight * evaluated_decoy->get_energy( name ) / score_variations_[ name ];
+			}
+		}
+	}
+
+	//tracer output with full result
+	tr.Trace << "evaluated select_score for " << evaluated_decoy->decoy_tag()
+					 << " that was tagged as " << evaluated_decoy->get_comment( "tag_in_file")
+					 << " : " << sum << " with " << select_weights_.size() << " evaluators" << std::endl;
+
+	//add energy to cache
+	evaluated_decoy->add_energy( "_archive_select_score_", sum );
+	return sum;
+}
+
+void EvaluatedArchive::save_to_file( std::string suffix ) {
+	Parent::save_to_file( suffix );
+	if ( variance_archive_ ) variance_archive_->save_to_file( suffix );
+}
+
+///@detail restore archive and sort
+bool EvaluatedArchive::restore_from_file() {
+	bool b_have_restored = Parent::restore_from_file();
+	sort();
+	using namespace basic::options;
+	bool const bUseVarianceArchive( option[ OptionKeys::iterative::use_variance_archive ]() );
+	if ( bUseVarianceArchive ) {
+		variance_archive_ = new VarianceStatisticsArchive( "variance_collector_"+name() );
+		variance_archive_->set_nstruct( 1000 );
+		variance_archive_->restore_from_file();
+	}
+	return b_have_restored;
+}
+
+// ---------------------- sort archive -------------------
+
+class SortPredicate {
+public:
+	SortPredicate( EvaluatedArchive& arc ) : arc_( arc ) {};
+	bool operator() (SilentStructOP const& pss1, SilentStructOP const& pss2 ) {
+		return arc_.select_score( pss1 ) < arc_.select_score( pss2 );
+	}
+	EvaluatedArchive& arc_;
+};
+
+void EvaluatedArchive::sort() {
+	decoys().sort( SortPredicate( *this ) );
+}
+
+// --------------------------- end sort ------------------------------
+
+///@detail determine variations of the non-zero weighted (select_weight_) scores by taking the difference Q3-Q1 (upper / lower quartil)
+bool EvaluatedArchive::determine_score_variations() const {
+	if ( !basic::options::option[ basic::options::OptionKeys::iterative::normalize_scores ]() ) return false;
+	if ( variance_archive_ ) {
+		variance_archive_->set_weights( weights() );
+		bool changed( variance_archive_->determine_score_variations() );
+		if ( changed ) score_variations_=variance_archive_->score_variations();
+		return changed;
+	}
+	if ( score_variations_are_clean_ ) return false; //not changed
+	score_variations_are_clean_ = true;
+	tr.Info << "determine score variations in EvaluatedArchive " << name() << "... " << std::endl;
+	score_variations_.clear();
+	core::Size ndecoys( decoys().size() );
+	core::Size half( ndecoys / 2 );
+	core::Size lowQ( half / 2 );
+	core::Size highQ( half + lowQ );
+	utility::vector1<core::Real> values( ndecoys );
+	for ( WeightMap::const_iterator it = select_weights_.begin(); it != select_weights_.end(); ++it ) {
+		if ( it->first == "special_initial_decoy_penalty" ) continue;
+		if ( it->second > 0.01 ) {
+			std::string const& name( it->first );
+			Size ct( 1 );
+			for ( SilentStructs::const_iterator iss = decoys().begin(); iss != decoys().end(); ++iss, ++ct ) {
+				if ( !(*iss)->has_energy( name ) ) {
+					throw EXCN_Archive( "energy name "+name+" not found in returned decoys -- run with rescoring in archive to avoid this or fix your batches" );
+				} // add weighted column-value to final score
+				values[ct]=(*iss)->get_energy( name );
+			}
+			if ( ndecoys > 5 ) {
+				runtime_assert( lowQ > 0 && highQ < ndecoys );
+				std::sort(values.begin(), values.end());
+				score_variations_[ it->first ] = std::abs( values[highQ]-values[lowQ] );
+				tr.Info << "score variation of " << score_variations_[ it->first ] << " for " << name
+								<< " between " << values[lowQ]  << " at " << lowQ
+								<< " and "     << values[highQ] << " at " << highQ << std::endl;
+			} else { //not enough decoys
+				score_variations_[ it->first ] = 1.0;
+			}
+			if ( score_variations_[ it->first ]< 1e-20 ) {
+				score_variations_[ it->first ]= 1e-20;
+			}
+		} // if weight > 0.01
+	} //for select_weights
+	return true; //changed
+} //determine_score_variations
+
+
+///@detail rescore and sort archive
+void EvaluatedArchive::rescore() {
+	tr.Debug << "rescore " << name() << " decoys " << std::endl;
+
+	//rescore all decoys
+	for ( SilentStructs::iterator iss = decoys().begin(); iss != decoys().end(); ++iss ) {
+		*iss = evaluate_silent_struct( *iss ); //_archive_select_score_ will be removed here
+	}
+	scores_are_clean_ = true; //do this first, since SortPredicate asks for the select_score
+	score_variations_are_clean_ = false;
+	if ( variance_archive_ ) {
+		variance_archive_->set_evaluators( evaluators(), weights() );
+		variance_archive_->rescore();
+	}
+
+	sort(); //here the summing is done via select_score() and a new _archive_select_score_ is computed
+
+	tr.Debug << "...done rescoring and sorting " << std::endl;
+// 	if ( tr.Trace.visible() ) {
+// 		for ( SilentStructs::const_iterator it = decoys().begin(); it != decoys().end(); ++it ) {
+// 			tr.Trace << select_score( *it ) << " " << (*it)->decoy_tag() << std::endl;
+// 		}
+// 	}
+}
+
+
+/* =================== maintenance of evaluators and weights ====================== */
+
+void EvaluatedArchive::add_evaluation( evaluation::PoseEvaluatorCOP eval, Real weight ) {
+	tr.Info << "added evaluator " << eval->name( 1 ) << " with weight " << weight << " to EvaluatedArchive " << name() << std::endl;
+	for ( Size i=1; i<= eval->size(); i++ ) {
+		std::string const& column( eval->name( i ) );
+		set_weight( column, weight );
+		evaluators_[ column ] = eval;
+	}
+	scores_are_clean_ = false;
+}
+
+void EvaluatedArchive::remove_evaluation( std::string const& name ) {
+	std::string const& column( name );
+
+	EvaluatorMap::iterator iter = evaluators_.find( column );
+	if ( iter != evaluators_.end() ) 	evaluators_.erase( iter );
+
+	WeightMap::iterator iter2 = select_weights_.find( column );
+	if ( iter2 != select_weights_.end() ) select_weights_.erase( iter2 );
+
+	scores_are_clean_ = false;
+}
+
+void EvaluatedArchive::set_weight( std::string const& column, core::Real weight ) {
+	//	runtime_assert( has_evaluator( column ) ); or part of score!
+	WeightMap::const_iterator iter = select_weights_.find( column );
+	if ( iter != select_weights_.end() && iter->second == weight ) return;
+	select_weights_[ column ] = weight;
+	if ( weight > 0.01 ) {
+		score_variations_[ column ] = 1.0; // to make sure we have a value ( e.g., in case we do no local evaluation )
+		score_variations_are_clean_ = false;
+		scores_are_clean_ = false; //need to re-determine the score-variations
+	}
+}
+
+
+void EvaluatedArchive::set_weights( WeightMap const& setting ) {
+	select_weights_.clear();
+	for ( WeightMap::const_iterator it = setting.begin(); it != setting.end(); ++it ) {
+		set_weight( it->first, it->second );
+	}
+}
+
+EvaluatedArchive::WeightMap const& EvaluatedArchive::score_variations() const {
+	determine_score_variations();
+	if ( variance_archive_ ) {
+		return variance_archive_->score_variations();
+	}
+	return score_variations_;
+}
+
+void EvaluatedArchive::set_score_variations( WeightMap const& setting ) {
+	score_variations_=setting;
+}
+
+void EvaluatedArchive::set_evaluators( EvaluatorMap const& evaluators, WeightMap const& weights ) {
+	evaluators_.clear();
+	for ( EvaluatorMap::const_iterator it = evaluators.begin(); it != evaluators.end(); ++it ) {
+		WeightMap::const_iterator itfind=weights.find( it->first );
+		add_evaluation( it->second, itfind->second );
+	}
+}
+
+core::Real EvaluatedArchive::get_weight( std::string const& column ) const {
+	//	runtime_assert( has_evaluator( column ) ); or part of score!
+	WeightMap::const_iterator iter = select_weights_.find( column );
+	if ( iter != select_weights_.end() ) return iter->second;
+	else return 0.0;
+}
+
+core::Real EvaluatedArchive::score_variation( std::string const& column ) const {
+	determine_score_variations();
+	if ( variance_archive_ ) {
+		variance_archive_->score_variation( column );
+	}
+	WeightMap::const_iterator iter = score_variations_.find( column );
+	if ( iter != score_variations_.end() ) return iter->second;
+	else return 1.0;
+}
+
+bool EvaluatedArchive::has_evaluator( std::string const& column ) {
+	EvaluatorMap::const_iterator iter = evaluators_.find( column );
+	return iter != evaluators_.end();
+}
+
+void EvaluatedArchive::set_scorefxn( core::scoring::ScoreFunctionOP scorefxn ) {
+	scorefxn_ = scorefxn;
+	scores_are_clean_ = false;
+}
+
+core::scoring::ScoreFunction const &
+EvaluatedArchive::scorefxn() const {
+	runtime_assert( scorefxn_ );
+	return *scorefxn_;
+}
+
+core::scoring::ScoreFunctionOP
+EvaluatedArchive::scorefxn_non_const() {
+	runtime_assert( scorefxn_ );
+	return scorefxn_;
+}
+
+void EvaluatedArchive::setup_default_evaluators() {
+	using namespace basic::options;
+	using namespace basic::options::OptionKeys;
+	//using namespace scoring::constraints;
+// 	if ( evaluate_local() && option[ constraints::cst_file ].user() ) {
+// 		std::string filename( option[ constraints::cst_file ]()[ 1 ] );
+// 		evaluation::PoseEvaluatorOP ev_cst ( new evaluation::ConstraintEvaluator( "cmdline", filename ) );
+// 		add_evaluation( ev_cst, option[ constraints::cst_weight ] );
+// 		//The ConstraintEvaluator creates two columns: cmdline_cst and cmdline_viol...
+// 		set_weight( "cmdline_viol", 0.0 );
+// 	}
+	set_weight( "score", 1.0 );
+	if ( option[ OptionKeys::iterative::penalize_initial_decoys ]() > 0.0 ) {
+		set_weight( SPECIAL_INITIAL_DECOY_PENALTY , option[ OptionKeys::iterative::penalize_initial_decoys ]() );
+	}
+
+	//	evaluation::MetaPoseEvaluator cmdline_evals;
+	//	evaluation::EvaluatorFactory::get_instance()->add_all_evaluators(cmdline_evals);
+	//	for ( evaluation::MetaPoseEvaluator::EvaluatorList::const_iterator it = cmdline_evals.evaluators().begin();
+	//				it != cmdline_evals.evaluators().end(); ++it ) {
+	// 		add_evaluation( *it );
+	//	}
+}
+
+/* =================== end maintenance of evaluators and weights ====================== */
+
+
+}//archive
+}//jd2
+}//protocols
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.hh patched/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.hh
--- vanilla/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.hh	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.hh	2012-06-10 16:12:40.351040222 +0200
@@ -17,6 +17,7 @@
 // Unit headers
 #include <protocols/jd2/archive/ArchiveManager.fwd.hh>
 #include <protocols/jd2/archive/ArchiveBase.hh>
+#include <protocols/jd2/archive/VarianceStatisticsArchive.fwd.hh>
 //#include <protocols/jd2/archive/EvaluatedArchive.fwd.hh>
 // AUTO-REMOVED #include <core/scoring/constraints/ConstraintSet.hh>
 
@@ -92,8 +93,11 @@ public:
 	///@brief overloaded to make input decoys appear the same as decoys coming from batches
 	virtual void init_from_decoy_set( core::io::silent::SilentFileData const& sfd ) = 0;
 
-protected:
+	///@brief typedefs for Evaluators and Weights
+	typedef std::map< std::string, core::Real > WeightMap;
+	typedef std::map< std::string, evaluation::PoseEvaluatorCOP > EvaluatorMap;
 
+	void start_evaluation_timer() const;
 	///@brief yields an "evaluated" silent-struct which can be queried with select_score
 	///@detail will run scoring-process if evaluate_local() otherwise just returns the intpu-silent-struct
 	core::io::silent::SilentStructOP evaluate_silent_struct( core::io::silent::SilentStructOP from_batch ) const;
@@ -111,10 +115,10 @@ protected:
 	}
 
 	///@brief recompute all score-values of all decoys and re-order the archive by (new) select_score
-	void rescore();
+	virtual void rescore();
 
 	///@brief add new PoseEvaluation to set of evaluators, specify weight for contribution to select_score()
-	void add_evaluation( evaluation::PoseEvaluatorOP, core::Real weight = 0.0 );
+	void add_evaluation( evaluation::PoseEvaluatorCOP, core::Real weight = 0.0 );
 
 	///@brief remove Evaluator
 	void remove_evaluation( std::string const& column );
@@ -126,32 +130,49 @@ protected:
 	/// (i.e, score, chainbreak, external evaluation like score_final )
 	void set_weight( std::string const& column, core::Real weight );
 
-	core::Real get_weight( std::string const& column );
+	core::Real get_weight( std::string const& column ) const;
 
 	///@brief set scorefxn used for evaluation
 	void set_scorefxn( core::scoring::ScoreFunctionOP scorefxn_ );
 
 	core::scoring::ScoreFunction const & scorefxn() const;
 
+	virtual WeightMap const& score_variations() const;
+
+	virtual core::Real score_variation( std::string const& col ) const;
+
+	WeightMap const& weights() const {
+		return select_weights_;
+	}
+
+	EvaluatorMap const& evaluators() const {
+		return evaluators_;
+	}
+
+	void set_weights( WeightMap const& setting );
+	void set_evaluators( EvaluatorMap const&, WeightMap const& );
+
+	///overloaded to save / restore the variance_archive_
+	virtual void save_to_file( std::string suffix = "" );
+
 protected:
 	core::scoring::ScoreFunctionOP scorefxn_non_const();
 
-private:
+	///@brief score a pose
+	virtual void score( core::pose::Pose& pose ) const;
+
+	virtual void invalidate_score_variations() {}
 
+private:
 	///@brief call score( pose ) and collect energies into result
 	/// this is low-level function: it expects that result already contains the coordinates of the pose
 	/// for convenience the pointer result is also return value
 	virtual core::io::silent::SilentStructOP evaluate_pose( core::io::silent::SilentStructOP result, core::pose::Pose& input_pose ) const;
 
-	///@brief score a pose
-	virtual void score( core::pose::Pose& pose ) const = 0;
-
 	///@brief re-sort decoys based on select_score
 	void sort();
 
-	///@brief typedefs for Evaluators and Weights
-	typedef std::map< std::string, core::Real > WeightMap;
-	typedef std::map< std::string, evaluation::PoseEvaluatorOP > EvaluatorMap;
+
 
 	///@brief scorefxn_ for evaluate( SilentStruct, Pose const& )
 	core::scoring::ScoreFunctionOP scorefxn_;
@@ -160,8 +181,12 @@ private:
 	WeightMap select_weights_;
 	EvaluatorMap evaluators_;
 
+	WeightMap dummy_score_variations_;
+
 	///@brief keep track wether cached scores in _archive_select_score_ are up-to-date
-	bool scores_are_clean_; //false after add_evaluation or change of scorefxn_
+	mutable bool scores_are_clean_; //false after add_evaluation or change of scorefxn_
+
+	mutable bool score_variations_are_clean_;
 
 	///@brief local evaluation or is evaluation outsourced to slave nodes?
 	bool b_evaluate_incoming_decoys_;
@@ -170,6 +195,10 @@ private:
 	///@brief keep track whether our options have been registered at start up
 	static bool options_registered_;
 
+	mutable time_t start_eval_time_;
+
+	VarianceStatisticsArchiveOP variance_archive_;
+
 };
 
 
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.hh.backup patched/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.hh.backup
--- vanilla/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.hh.backup	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/EvaluatedArchive.hh.backup	2012-06-10 16:12:40.354040180 +0200
@@ -0,0 +1,219 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file   protocols/jd2/MPIWorkPoolJobDistributor.hh
+/// @brief  header for MPIWorkPoolJobDistributor - intended for continuous resamplig jobs  that spawn new jobs based on a pool/archive of
+///         structures
+/// @author Oliver Lange olange@u.washington.edu
+
+#ifndef INCLUDED_protocols_jd2_archive_EvaluatedArchive_hh
+#define INCLUDED_protocols_jd2_archive_EvaluatedArchive_hh
+
+// Unit headers
+#include <protocols/jd2/archive/ArchiveManager.fwd.hh>
+#include <protocols/jd2/archive/ArchiveBase.hh>
+#include <protocols/abinitio/VarianceStatisticsArchive.fwd.hh>
+//#include <protocols/jd2/archive/EvaluatedArchive.fwd.hh>
+// AUTO-REMOVED #include <core/scoring/constraints/ConstraintSet.hh>
+
+// Package headers
+#include <core/io/silent/silent.fwd.hh>
+#include <core/pose/Pose.fwd.hh>
+// AUTO-REMOVED #include <core/scoring/ScoreFunction.hh>
+
+// AUTO-REMOVED #include <protocols/evaluation/PoseEvaluator.hh>
+
+// Utility headers
+#include <core/types.hh>
+#include <utility/pointer/ReferenceCount.hh>
+#include <utility/exit.hh>
+
+// C++ headers
+#include <string>
+#include <list>
+
+#include <core/scoring/ResidualDipolarCoupling.fwd.hh>
+#include <core/scoring/constraints/ConstraintSet.fwd.hh>
+#include <protocols/evaluation/PoseEvaluator.fwd.hh>
+#include <utility/vector1.hh>
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+//class ArchiveManager;
+
+
+
+///@brief Tags used to tag messeges sent by MPI functions used to decide whether a slave is requesting a new job id or
+///flagging as job as being a bad input
+
+///@details This job distributor is meant for running jobs where the machine you are using has a large number of
+///processors, the number of jobs is much greater than the number of processors, or the runtimes of the individual jobs
+///could vary greatly. It dedicates the head node (whichever processor gets processor rank #0) to handling job requests
+///from the slave nodes (all nonzero ranks). Unlike the MPIWorkPartitionJobDistributor, this JD will not work at all
+///without MPI and the implementations of all but the interface functions have been put inside of ifdef directives.
+///Generally each function has a master and slave version, and the interface functions call one or the other depending
+///on processor rank.
+
+class EvaluatedArchive : public ArchiveBase {
+	typedef ArchiveBase Parent;
+public:
+
+	///@brief Constructor  and Destructor
+	EvaluatedArchive( ArchiveManagerAP ptr );
+	EvaluatedArchive();
+	~EvaluatedArchive();
+
+	///@brief Archive specific options
+	static void register_options();
+
+	///@brief add decoy to Archive
+	///@detail evaluate decoy and call add_evaluated_structure
+	virtual bool add_structure( core::io::silent::SilentStructOP from_batch );
+
+	///@brief  compute score according to select_weights --- this can contain any evaluator columns
+	core::Real select_score( core::io::silent::SilentStructOP evaluated_decoy );
+
+	///@brief set common evaluators: eg. ConstraintEvaluator if -cst_file is present
+	void setup_default_evaluators();
+
+
+	///@brief overloaded that we can sort the pool after reading
+	virtual bool restore_from_file();
+
+	///@brief only overloaded this to add some verbosity each time we read structures
+	virtual void read_structures( core::io::silent::SilentFileData&, Batch const& batch );
+
+	///@brief overloaded to make input decoys appear the same as decoys coming from batches
+	virtual void init_from_decoy_set( core::io::silent::SilentFileData const& sfd ) = 0;
+
+	///@brief typedefs for Evaluators and Weights
+	typedef std::map< std::string, core::Real > WeightMap;
+	typedef std::map< std::string, evaluation::PoseEvaluatorCOP > EvaluatorMap;
+
+	void start_evaluation_timer() const;
+	///@brief yields an "evaluated" silent-struct which can be queried with select_score
+	///@detail will run scoring-process if evaluate_local() otherwise just returns the intpu-silent-struct
+	core::io::silent::SilentStructOP evaluate_silent_struct( core::io::silent::SilentStructOP from_batch ) const;
+
+	///@brief add an evaluated decoy to Archive (i.e, evaluated_decoy = evaluate( some_decoy ) );
+	virtual bool add_evaluated_structure( core::io::silent::SilentStructOP evaluated_decoy );
+
+	///@brief specify if decoys are evaluated on the master or (non-local i.e., on the individual slave nodes)
+	bool evaluate_local() const {
+		return b_evaluate_incoming_decoys_;
+	}
+
+	void set_evaluate_local( bool setting ) {
+		b_evaluate_incoming_decoys_ = setting;
+	}
+
+	///@brief recompute all score-values of all decoys and re-order the archive by (new) select_score
+	virtual void rescore();
+
+	///@brief add new PoseEvaluation to set of evaluators, specify weight for contribution to select_score()
+	void add_evaluation( evaluation::PoseEvaluatorCOP, core::Real weight = 0.0 );
+
+	///@brief remove Evaluator
+	void remove_evaluation( std::string const& column );
+
+	///@brief is a certain elvaluator present ?
+	bool has_evaluator( std::string const& column );
+
+	///@brief set weight of an evaluator or a column otherwise present in silent-structs
+	/// (i.e, score, chainbreak, external evaluation like score_final )
+	void set_weight( std::string const& column, core::Real weight );
+
+	core::Real get_weight( std::string const& column ) const;
+
+	///@brief set scorefxn used for evaluation
+	void set_scorefxn( core::scoring::ScoreFunctionOP scorefxn_ );
+
+	core::scoring::ScoreFunction const & scorefxn() const;
+
+	WeightMap const& score_variations() const;
+
+	core::Real score_variation( std::string const& col ) const;
+
+	WeightMap const& weights() const {
+		return select_weights_;
+	}
+
+	EvaluatorMap const& evaluators() const {
+		return evaluators_;
+	}
+
+	void set_weights( WeightMap const& setting );
+	void set_evaluators( EvaluatorMap const&, WeightMap const& );
+
+	///@brief determine variation of scores (those that are non-zeros in select_weights_ )
+	bool determine_score_variations() const;
+
+	///overloaded to save / restore the variance_archive_
+	virtual void save_to_file( std::string suffix = "" );
+
+
+
+protected:
+	core::scoring::ScoreFunctionOP scorefxn_non_const();
+
+	///@brief score a pose
+	virtual void score( core::pose::Pose& pose ) const;
+
+	void invalidate_score_variations() {
+		score_variations_are_clean_ = false;
+	}
+
+private:
+	void set_score_variations( WeightMap const& setting );
+
+	///@brief call score( pose ) and collect energies into result
+	/// this is low-level function: it expects that result already contains the coordinates of the pose
+	/// for convenience the pointer result is also return value
+	virtual core::io::silent::SilentStructOP evaluate_pose( core::io::silent::SilentStructOP result, core::pose::Pose& input_pose ) const;
+
+	///@brief re-sort decoys based on select_score
+	void sort();
+
+
+
+	///@brief scorefxn_ for evaluate( SilentStruct, Pose const& )
+	core::scoring::ScoreFunctionOP scorefxn_;
+
+	///@brief Evaluators and weights for select_score and evaluate
+	WeightMap select_weights_;
+	EvaluatorMap evaluators_;
+
+	mutable WeightMap score_variations_;
+
+	///@brief keep track wether cached scores in _archive_select_score_ are up-to-date
+	mutable bool scores_are_clean_; //false after add_evaluation or change of scorefxn_
+
+	mutable bool score_variations_are_clean_;
+
+	///@brief local evaluation or is evaluation outsourced to slave nodes?
+	bool b_evaluate_incoming_decoys_;
+
+
+	///@brief keep track whether our options have been registered at start up
+	static bool options_registered_;
+
+	mutable time_t start_eval_time_;
+
+	VarianceStatisticsArchiveOP variance_archive_;
+
+};
+
+
+}//archive
+}//jd2
+}//protocols
+
+
+#endif //INCLUDED_protocols_jd2_Archive_HH
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/MPIArchiveJobDistributor.cc patched/rosetta_source/src/protocols/jd2/archive/MPIArchiveJobDistributor.cc
--- vanilla/rosetta_source/src/protocols/jd2/archive/MPIArchiveJobDistributor.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/MPIArchiveJobDistributor.cc	2012-06-10 16:12:40.357041056 +0200
@@ -247,11 +247,13 @@ MPIArchiveJobDistributor::batch_underflo
 		PROF_START( basic::MPI_JD2_WAITS_FOR_ARCHIVE );
 		tr.Debug << "no more batches... ask ArchiveManager if there is some more to do... wait..." << std::endl;
 		_notify_archive();
+		basic::show_time( tr,  "no more batches: send QUEUE_EMPTY to archive" );
 		master_to_archive( QUEUE_EMPTY );
 		tr.Info << "wait for answer on QUEUE-EMPTY msg... send with " << current_batch_id() << " batch_id " << std::endl;
 		eat_signal( ADD_BATCH, archive_rank() );
 		receive_batch( archive_rank() ); //how about some time-out
 		tr.Debug << "...received " << std::endl;
+		basic::show_time( tr,  "refilled queue: received new batches after QUEUE_EMPTY" );
 		PROF_STOP( basic::MPI_JD2_WAITS_FOR_ARCHIVE );
 	}
 }
@@ -269,6 +271,8 @@ MPIArchiveJobDistributor::process_messag
 ) {
 	runtime_assert( rank() == master_rank() );
 
+	//	basic::show_time( tr,  "jd2 main msg-loop: process message..." );
+
 	// send out any pending notifications to archive if present -- this is non-blocking
 	_notify_archive(); //we should get here often enough... (basically every finished job
 	//-- unless of course we haven't started any jobs yet)
@@ -387,9 +391,9 @@ MPIArchiveJobDistributor::notify_archive
 					 << " nr_processors " << number_of_processors() << std::endl;
  	//are we quickly running out of jobs? -- checking for equality to reduce number of messages -- is this safe? do we ever skip jobs?
 	if ( nr_batches() == batch_id && ( (int) current_job_id() == ( (int) get_jobs().size() - (int) number_of_processors() ) ) ) {
-		tr.Info << "jobs are low... send QUEUE_EMPTY with " << batch_id << " batch_id " << std::endl;
-		pending_notifications_.push_front( CompletionMessage( batch_id, QUEUE_EMPTY ) );
-		_notify_archive();
+		//tr.Info << "jobs are low... send QUEUE_EMPTY with " << batch_id << " batch_id " << std::endl;
+		//		pending_notifications_.push_front( CompletionMessage( batch_id, QUEUE_EMPTY ) );
+		//		_notify_archive();
 	}
 }
 
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/nohup.out patched/rosetta_source/src/protocols/jd2/archive/nohup.out
--- vanilla/rosetta_source/src/protocols/jd2/archive/nohup.out	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/nohup.out	2012-06-10 16:12:40.359074702 +0200
@@ -0,0 +1,5 @@
+bind: Address already in use
+channel_setup_fwd_listener: cannot listen to port: 45201
+Could not request local forwarding.
+Timeout, server not responding.
+Timeout, server not responding.
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/NormalizedEvaluatedArchive.cc patched/rosetta_source/src/protocols/jd2/archive/NormalizedEvaluatedArchive.cc
--- vanilla/rosetta_source/src/protocols/jd2/archive/NormalizedEvaluatedArchive.cc	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/NormalizedEvaluatedArchive.cc	2012-06-10 16:12:40.362040085 +0200
@@ -0,0 +1,257 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file   protocols/jd2/MPIFileBufJobDistributor.cc
+/// @brief  implementation of MPIFileBufJobDistributor
+/// @author Oliver Lange olange@u.washington.edu
+
+// Unit headers
+#include <protocols/jd2/archive/NormalizedEvaluatedArchive.hh>
+#include <protocols/jd2/archive/ArchiveManager.hh>
+#include <protocols/jd2/archive/VarianceStatisticsArchive.hh>
+
+//#include <core/io/silent/SilentFileData.hh>
+
+#include <core/scoring/ScoreFunction.hh>
+//#include <core/scoring/constraints/ConstraintIO.hh>
+//#include <core/scoring/constraints/util.hh>
+//#include <core/scoring/Energies.hh>
+
+//#include <core/pose/Pose.hh>
+//#include <basic/datacache/BasicDataCache.hh>
+
+//#include <protocols/evaluation/EvaluatorFactory.hh>
+#include <protocols/evaluation/PoseEvaluator.hh>
+
+#include <utility/exit.hh>
+#include <utility/excn/Exceptions.hh>
+
+#include <numeric/util.hh>
+
+#include <basic/Tracer.hh>
+#include <basic/prof.hh>
+
+//for DebugArchive
+// AUTO-REMOVED #include <utility/io/ozstream.hh>
+
+#include <basic/options/option.hh>
+#include <basic/options/option_macros.hh>
+
+//for setup_default_evaluators
+#include <basic/options/keys/run.OptionKeys.gen.hh>
+#include <utility/vector1.hh>
+
+
+static basic::Tracer tr("protocols.jd2.NormalizedEvaluatedArchive");
+
+//OPT_1GRP_KEY( Real, iterative, chainbreak_evaluator_exponent )
+//OPT_1GRP_KEY( Boolean, iterative, simulate_bg4_cbtreatment )
+OPT_2GRP_KEY( Boolean, iterative, normalize, activate )
+OPT_2GRP_KEY( Boolean, iterative, normalize, extra_archive  )
+OPT_2GRP_KEY( Real, iterative, normalize, keep_adding )
+OPT_2GRP_KEY( Integer, iterative, normalize, num_struct)
+OPT_2GRP_KEY( Integer, iterative, normalize, start )
+OPT_2GRP_KEY( StringVector, iterative, normalize, force_zero )
+OPT_2GRP_KEY( Boolean, iterative, normalize, lower_quartile )
+
+std::string const SPECIAL_INITIAL_DECOY_PENALTY( "special_initial_decoy_penalty" );
+
+bool protocols::jd2::archive::NormalizedEvaluatedArchive::options_registered_( false );
+
+//Mike: when you want to remove these Macros... leave them at least here as comment - since they provide documentation
+void protocols::jd2::archive::NormalizedEvaluatedArchive::register_options() {
+	Parent::register_options();
+	if ( !options_registered_ ) {
+		NEW_OPT( iterative::normalize::activate, "score-variations are determined to normalize scores", false );
+		NEW_OPT( iterative::normalize::extra_archive, "determine score variations from extra archive", false );
+		NEW_OPT( iterative::normalize::keep_adding, "keep adding X percent of the incoming structures, throw out old ones randomly", 0.0 );
+		NEW_OPT( iterative::normalize::num_struct, "number of structures in varaiance archive", 1000 );
+		NEW_OPT( iterative::normalize::start, "do not normalize until X structures have been accumulated, if 0 this will be set to normalize:nstruct structures", 0 );
+		NEW_OPT2( iterative::normalize::force_zero, "for scores whose name starts with XXX compute variance as 0...Q3 instead of Q1..Q3", "rdc", "filter_cst" );
+		NEW_OPT( iterative::normalize::lower_quartile, "use Lo..Q1 instead of Q1..Q3 to determine range", false );
+		options_registered_ = true;
+	}
+}
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+// using namespace basic::options;
+// using namespace basic::options::OptionKeys;
+using namespace core;
+using namespace core::io::silent;
+
+NormalizedEvaluatedArchive::~NormalizedEvaluatedArchive() {}
+
+
+NormalizedEvaluatedArchive::NormalizedEvaluatedArchive() {
+	runtime_assert( options_registered_ );
+	score_variations_are_clean_ = false;
+	init_from_options();
+}
+
+NormalizedEvaluatedArchive::NormalizedEvaluatedArchive( ArchiveManagerAP ptr )
+	: EvaluatedArchive( ptr )
+{
+	runtime_assert( options_registered_ );
+	score_variations_are_clean_ = false;
+	init_from_options();
+}
+
+void NormalizedEvaluatedArchive::init_from_options() {
+	using namespace basic::options;
+	insertion_prob_ = option[ OptionKeys::iterative::normalize::keep_adding ]();
+	keep_adding_to_statistics_ = insertion_prob_ > 0.0;
+	use_variance_archive_ = option[ OptionKeys::iterative::normalize::extra_archive ]();
+	nstruct_for_statistics_ = option[ OptionKeys::iterative::normalize::num_struct ]();
+	min_decoys_for_statistics_ = option[ OptionKeys::iterative::normalize::start ]();
+	if ( !min_decoys_for_statistics_ ) min_decoys_for_statistics_ = nstruct_for_statistics_;
+	activated_ = option[ OptionKeys::iterative::normalize::activate ]();
+	positive_scores_ = option[ OptionKeys::iterative::normalize::force_zero ]();
+	lower_quartile_ = option[ OptionKeys::iterative::normalize::lower_quartile ]();
+	if ( option[ OptionKeys::run::test_cycles ] || option[ OptionKeys::run::dry_run ] ) {
+		nstruct_for_statistics_ = 10;
+		min_decoys_for_statistics_ = 10;
+	}
+}
+
+void NormalizedEvaluatedArchive::initialize() {
+	if ( use_variance_archive_ ) {
+		variance_archive_ = new VarianceStatisticsArchive( name()+"_variance" );
+		variance_archive_->set_nstruct( nstruct_for_statistics_ );
+		variance_archive_->set_insertion_prob( insertion_prob_ );
+		variance_archive_->initialize();
+	}
+}
+
+//completely overwrites the EvaluatedArchive  version. Doesn't call Parent function.
+bool NormalizedEvaluatedArchive::add_evaluated_structure( core::io::silent::SilentStructOP evaluated_decoy ) {
+	bool added( Parent::add_evaluated_structure( evaluated_decoy ) );
+	bool added_variance( added );
+	if ( variance_archive_ ) {
+		added_variance = false;
+		if ( keep_adding_to_statistics_ || total_proposed() < nstruct_for_statistics_ ) {
+			added_variance = variance_archive_->add_evaluated_structure( evaluated_decoy );
+		}
+	}
+	tr.Info << "offered structure that was " << ( added ? "" : "not" ) << " relevant to the variances " << std::endl;
+	score_variations_are_clean_ = score_variations_are_clean_ && !added_variance;
+	return added;
+}
+
+void NormalizedEvaluatedArchive::save_to_file( std::string suffix ) {
+	Parent::save_to_file( suffix );
+	if ( variance_archive_ ) variance_archive_->save_to_file( suffix );
+}
+
+///@detail restore archive and sort
+bool NormalizedEvaluatedArchive::restore_from_file() {
+	bool b_have_restored = Parent::restore_from_file();
+	if ( use_variance_archive_ ) {
+		runtime_assert( variance_archive_ );
+		variance_archive_->restore_from_file();
+	}
+	score_variations_are_clean_ = false;
+	return b_have_restored;
+}
+// --------------------------- end sort ------------------------------
+
+///@detail determine variations of the non-zero weighted (select_weight_) scores by taking the difference Q3-Q1 (upper / lower quartil)
+bool NormalizedEvaluatedArchive::determine_score_variations() const {
+	if ( score_variations_are_clean_ ) return false; //not changed
+	score_variations_are_clean_ = true;
+	SilentStructs const& my_decoys( variance_archive_ ? variance_archive_->decoys() : decoys() );
+	core::Size ndecoys( my_decoys.size() );
+	tr.Info << "determine score variations in NormalizedEvaluatedArchive " << name() << "... " << std::endl;
+	tr.Info << "use " << ndecoys << " decoys from " << (variance_archive_ ? variance_archive_->name() : name() ) << std::endl;
+	utility::vector1<core::Real> values;
+	for ( WeightMap::const_iterator it = weights().begin(); it != weights().end(); ++it ) {
+		if ( it->first == "special_initial_decoy_penalty" ) continue;
+		if ( it->second > 0.01 ) {
+			if ( ndecoys >= min_decoys_for_statistics_ && activated_ ) {
+
+				std::string const& name( it->first );
+				Size ct( 1 );
+				core::Size half( ndecoys / 2 );
+				core::Size lowQ( half / 2 );
+				core::Size highQ( half + lowQ );
+				if ( lower_quartile_ ) {
+					highQ = lowQ;
+					lowQ = 1 ;
+				}
+				//score_variations_.clear(); not really needed. should be faster without
+				values.resize( ndecoys );
+				for ( SilentStructs::const_iterator iss = my_decoys.begin(); iss != my_decoys.end(); ++iss, ++ct ) {
+					if ( !(*iss)->has_energy( name ) ) {
+						throw EXCN_Archive( "energy name "+name+" not found in returned decoys -- run with rescoring in archive to avoid this or fix your batches" );
+					} // add weighted column-value to final score
+					values[ct]=(*iss)->get_energy( name );
+				}
+				runtime_assert( lowQ > 0 && highQ < ndecoys );
+				std::sort(values.begin(), values.end());
+				if ( is_start_zero_score( it->first ) ) {
+					score_variations_[ it->first ] = values[highQ];
+					tr.Info << "score variation of " << score_variations_[ it->first ] << " for " << name
+									<< " between 0 (forced)"
+									<< " and "     << values[highQ] << " at " << highQ << std::endl;
+				} else {
+					score_variations_[ it->first ] = std::abs( values[highQ]-values[lowQ] );
+					tr.Info << "score variation of " << score_variations_[ it->first ] << " for " << name
+									<< " between " << values[lowQ]  << " at " << lowQ
+									<< " and "     << values[highQ] << " at " << highQ << std::endl;
+				}
+			} else { //not enough decoys or not activated
+				score_variations_[ it->first ] = 1.0;
+			}
+			//cutoff to avoid division by 0
+			if ( score_variations_[ it->first ]< 1e-20 ) {
+				score_variations_[ it->first ]= 1e-20;
+			}
+		} // if weight > 0.01
+	} //for select_weights
+	return true; //changed
+} //determine_score_variations
+
+bool NormalizedEvaluatedArchive::is_start_zero_score( std::string const& str ) const {
+	for ( utility::vector1< std::string >::const_iterator it =positive_scores_.begin(); it != positive_scores_.end(); ++it ) {
+		if ( str.substr( 0, it->size() ) == *it ) return true;
+	}
+}
+
+///@detail rescore and sort archive
+void NormalizedEvaluatedArchive::rescore() {
+	Parent::rescore();
+	score_variations_are_clean_ = false;
+	if ( variance_archive_ ) {
+		variance_archive_->set_evaluators( evaluators(), weights() );
+		variance_archive_->set_scorefxn( scorefxn().clone() );
+		variance_archive_->rescore();
+	}
+}
+
+NormalizedEvaluatedArchive::WeightMap const& NormalizedEvaluatedArchive::score_variations() const {
+	tr.Info << "ask for score_variations. They are " << (score_variations_are_clean_? "clean" : "not clean") << std::endl;
+	if ( !score_variations_are_clean_ ) determine_score_variations();
+	return score_variations_;
+}
+
+core::Real NormalizedEvaluatedArchive::score_variation( std::string const& column ) const {
+	tr.Info << "ask for score_variations. They are " << (score_variations_are_clean_? "clean" : "not clean") << std::endl;
+	if ( !score_variations_are_clean_ ) determine_score_variations();
+	WeightMap::const_iterator iter = score_variations_.find( column );
+	if ( iter != score_variations_.end() ) return iter->second;
+	else return 1.0;
+}
+
+/* =================== end maintenance of evaluators and weights ====================== */
+
+
+}//archive
+}//jd2
+}//protocols
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/NormalizedEvaluatedArchive.hh patched/rosetta_source/src/protocols/jd2/archive/NormalizedEvaluatedArchive.hh
--- vanilla/rosetta_source/src/protocols/jd2/archive/NormalizedEvaluatedArchive.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/NormalizedEvaluatedArchive.hh	2012-06-10 16:12:40.365040738 +0200
@@ -0,0 +1,134 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file   protocols/jd2/MPIWorkPoolJobDistributor.hh
+/// @brief  header for MPIWorkPoolJobDistributor - intended for continuous resamplig jobs  that spawn new jobs based on a pool/archive of
+///         structures
+/// @author Oliver Lange olange@u.washington.edu
+
+#ifndef INCLUDED_protocols_jd2_archive_NormalizedEvaluatedArchive_hh
+#define INCLUDED_protocols_jd2_archive_NormalizedEvaluatedArchive_hh
+
+// Unit headers
+#include <protocols/jd2/archive/ArchiveManager.fwd.hh>
+#include <protocols/jd2/archive/EvaluatedArchive.hh>
+#include <protocols/jd2/archive/VarianceStatisticsArchive.fwd.hh>
+//#include <protocols/jd2/archive/NormalizedEvaluatedArchive.fwd.hh>
+// AUTO-REMOVED #include <core/scoring/constraints/ConstraintSet.hh>
+
+// Package headers
+#include <core/io/silent/silent.fwd.hh>
+#include <core/pose/Pose.fwd.hh>
+// AUTO-REMOVED #include <core/scoring/ScoreFunction.hh>
+
+// AUTO-REMOVED #include <protocols/evaluation/PoseEvaluator.hh>
+
+// Utility headers
+#include <core/types.hh>
+#include <utility/pointer/ReferenceCount.hh>
+#include <utility/exit.hh>
+
+// C++ headers
+#include <string>
+#include <list>
+
+#include <core/scoring/ResidualDipolarCoupling.fwd.hh>
+#include <core/scoring/constraints/ConstraintSet.fwd.hh>
+#include <protocols/evaluation/PoseEvaluator.fwd.hh>
+#include <utility/vector1.hh>
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+//class ArchiveManager;
+
+
+
+///@brief Tags used to tag messeges sent by MPI functions used to decide whether a slave is requesting a new job id or
+///flagging as job as being a bad input
+
+///@details This job distributor is meant for running jobs where the machine you are using has a large number of
+///processors, the number of jobs is much greater than the number of processors, or the runtimes of the individual jobs
+///could vary greatly. It dedicates the head node (whichever processor gets processor rank #0) to handling job requests
+///from the slave nodes (all nonzero ranks). Unlike the MPIWorkPartitionJobDistributor, this JD will not work at all
+///without MPI and the implementations of all but the interface functions have been put inside of ifdef directives.
+///Generally each function has a master and slave version, and the interface functions call one or the other depending
+///on processor rank.
+
+class NormalizedEvaluatedArchive : public EvaluatedArchive {
+	typedef EvaluatedArchive Parent;
+public:
+
+	///@brief Constructor  and Destructor
+	NormalizedEvaluatedArchive( ArchiveManagerAP ptr );
+	NormalizedEvaluatedArchive();
+	~NormalizedEvaluatedArchive();
+
+	///@brief Archive specific options
+	static void register_options();
+
+	void init_from_options();
+
+	virtual	void initialize();
+
+	///@brief add decoy to Archive
+	///@detail evaluate decoy and call add_evaluated_structure
+	virtual bool add_evaluated_structure( core::io::silent::SilentStructOP from_batch );
+
+	///@brief overloaded that we can sort the pool after reading
+	virtual bool restore_from_file();
+
+	///@brief determine variation of scores (those that are non-zeros in select_weights_ )
+	bool determine_score_variations() const;
+
+	///overloaded to save / restore the variance_archive_
+	virtual void save_to_file( std::string suffix = "" );
+
+	///@brief recompute all score-values of all decoys and re-order the archive by (new) select_score
+	void rescore();
+
+	virtual WeightMap const& score_variations() const;
+
+	virtual core::Real score_variation( std::string const& col ) const;
+
+
+protected:
+
+	virtual void invalidate_score_variations() {
+		score_variations_are_clean_ = false;
+	}
+
+private:
+	bool is_start_zero_score( std::string const& ) const;
+
+	mutable WeightMap score_variations_;
+	mutable bool score_variations_are_clean_;
+	VarianceStatisticsArchiveOP variance_archive_;
+
+	//option settings
+	core::Size min_decoys_for_statistics_;
+	core::Size nstruct_for_statistics_;
+	bool keep_adding_to_statistics_;
+	bool use_variance_archive_;
+	core::Real insertion_prob_;
+	bool activated_;
+	bool lower_quartile_;
+	//for these scores we compute the variance as 0...Q3 instead of Q1..Q3
+	utility::vector1< std::string > positive_scores_;
+	///@brief keep track whether our options have been registered at start up
+	static bool options_registered_;
+};
+
+
+}//archive
+}//jd2
+}//protocols
+
+
+#endif //INCLUDED_protocols_jd2_Archive_HH
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/#svn-commit.tmp# patched/rosetta_source/src/protocols/jd2/archive/#svn-commit.tmp#
--- vanilla/rosetta_source/src/protocols/jd2/archive/#svn-commit.tmp#	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/#svn-commit.tmp#	2012-06-10 16:12:40.367074646 +0200
@@ -0,0 +1,5 @@
+M       src/protocols/jd2/archive/ArchiveBase.hh
+M       src/protocols/jd2/archive/MPIArchiveJobDistributor.hh
+--This line, and those below, will be ignored--
+
+M    MPIArchiveJobDistributor.cc
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.cc patched/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.cc
--- vanilla/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.cc	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.cc	2012-06-10 16:12:40.370040777 +0200
@@ -0,0 +1,73 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+/// @file IterativeAbrelax
+/// @brief iterative protocol starting with abinitio and getting progressively more concerned with full-atom relaxed structures
+/// @detailed
+/// @author Oliver Lange
+
+// Unit Headers
+#include <protocols/jd2/archive/VarianceStatisticsArchive.hh>
+
+// Package Headers
+#include <core/io/silent/SilentStruct.hh>
+
+// Utility Headers
+#include <basic/Tracer.hh>
+#include <basic/MemTracer.hh>
+#include <numeric/random/random.hh>
+
+
+static basic::Tracer tr("protocols.iterative.VarianceStatistics");
+using basic::mem_tr;
+
+static numeric::random::RandomGenerator RG(410142); // <- Magic number, do not change
+
+using core::Real;
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+
+
+VarianceStatisticsArchive::VarianceStatisticsArchive( std::string name )
+	: insertion_prob_( 0.1 )
+{
+	set_name( name );
+}
+
+
+bool VarianceStatisticsArchive::add_evaluated_structure( core::io::silent::SilentStructOP evaluated_decoy ) {
+	if ( decoys().size() < nstruct() ) {
+		tr.Debug << "added " << evaluated_decoy->decoy_tag() << " to " << name() << std::endl;
+		decoys().insert( decoys().begin(), evaluated_decoy );
+		invalidate_score_variations();
+		return true;
+	}
+
+	if ( RG.uniform() < insertion_prob_ ) { //keep or not ?
+		//replace with random element
+		Size rg_pos( static_cast< int >( RG.uniform() * decoys().size() ) );
+		runtime_assert( rg_pos < decoys().size() && rg_pos >= 0 );
+		SilentStructs::iterator it=decoys().begin();
+		while ( rg_pos-- > 0 ) {
+			++it;
+		}
+		runtime_assert( it != decoys().end() );
+		*it=evaluated_decoy;
+		invalidate_score_variations();
+		return true;
+	}
+
+	return false;
+}
+
+}
+} //abinitio
+} //protocols
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/#VarianceStatisticsArchive.fwd.hh# patched/rosetta_source/src/protocols/jd2/archive/#VarianceStatisticsArchive.fwd.hh#
--- vanilla/rosetta_source/src/protocols/jd2/archive/#VarianceStatisticsArchive.fwd.hh#	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/#VarianceStatisticsArchive.fwd.hh#	2012-06-10 16:12:40.373040150 +0200
@@ -0,0 +1,30 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   protocols/abinito/VarianceStatisticsArchive.fwd.hh
+/// @author Oliver Lange
+
+#ifndef INCLUDED_protocols_jd2_archive_VarianceStatisticsArchive_fwd_hh
+#define INCLUDED_protocols_jd2_archive_VarianceStatisticsArchive_fwd_hh
+
+#include <utility/pointer/owning_ptr.fwd.hh>
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+
+class VarianceStatisticsArchive;
+typedef utility::pointer::owning_ptr<VarianceStatisticsArchive> VarianceStatisticsArchiveOP;
+typedef utility::pointer::owning_ptr<VarianceStatisticsArchive const> VarianceStatisticsArchiveCOP;
+
+}
+}
+}
+
+#endif  // INCLUDED_protocols_abinitio_VarianceStatisticsArchive_fwd_hh
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.fwd.hh patched/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.fwd.hh
--- vanilla/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.fwd.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.fwd.hh	2012-06-10 16:12:40.375076955 +0200
@@ -0,0 +1,30 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   protocols/abinito/VarianceStatisticsArchive.fwd.hh
+/// @author Oliver Lange
+
+#ifndef INCLUDED_protocols_jd2_archive_VarianceStatisticsArchive_fwd_hh
+#define INCLUDED_protocols_jd2_archive_VarianceStatisticsArchive_fwd_hh
+
+#include <utility/pointer/owning_ptr.fwd.hh>
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+
+class VarianceStatisticsArchive;
+typedef utility::pointer::owning_ptr<VarianceStatisticsArchive> VarianceStatisticsArchiveOP;
+typedef utility::pointer::owning_ptr<VarianceStatisticsArchive const> VarianceStatisticsArchiveCOP;
+
+}
+}
+}
+
+#endif  // INCLUDED_protocols_abinitio_VarianceStatisticsArchive_fwd_hh
diff -rupN vanilla/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.hh patched/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.hh
--- vanilla/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/archive/VarianceStatisticsArchive.hh	2012-06-10 16:12:40.378040573 +0200
@@ -0,0 +1,71 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// This file is part of the Rosetta software suite and is made available under license.
+// The Rosetta software is developed by the contributing members of the Rosetta Commons consortium.
+// (C) 199x-2009 Rosetta Commons participating institutions and developers.
+// For more information, see http://www.rosettacommons.org/.
+
+///
+/// @author Oliver Lange
+/// Archive class to collect structures such that variances of scores can be computed to determine normalized weights
+
+
+#ifndef INCLUDED_protocols_jd2_archive_VarianceStatisticsArchive_hh
+#define INCLUDED_protocols_jd2_archive_VarianceStatisticsArchive_hh
+
+// Unit Headers
+//#include <protocols/abinitio/IterativeAbrelax.fwd.hh>
+
+// Package Headers
+#include <protocols/jd2/archive/EvaluatedArchive.hh>
+#include <protocols/jd2/archive/ArchiveManager.fwd.hh>
+#include <protocols/jd2/archive/VarianceStatisticsArchive.fwd.hh>
+// Project Headers
+#include <core/types.hh>
+#include <core/pose/Pose.fwd.hh>
+
+// Utility headers
+#include <utility/vector1.hh>
+
+// Third-party Headers
+
+//// C++ headers
+
+#include <string>
+
+
+
+namespace protocols {
+namespace jd2 {
+namespace archive {
+
+class VarianceStatisticsArchive : public EvaluatedArchive {
+	typedef EvaluatedArchive Parent;
+	typedef utility::vector1< core::io::silent::SilentStructOP > SilentStructVector;
+
+public:
+	VarianceStatisticsArchive( std::string name );
+
+	virtual bool add_evaluated_structure( core::io::silent::SilentStructOP );
+
+  virtual void generate_batch() {};
+	///@brief overloaded to make input decoys appear the same as decoys coming from batches
+	virtual void init_from_decoy_set( core::io::silent::SilentFileData const& sfd ) {};
+
+	void set_insertion_prob( core::Real setting ) {
+		insertion_prob_ = setting;
+	}
+
+protected:
+
+private:
+	core::Real insertion_prob_;
+};
+
+
+}
+}
+}
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/jd2/AtomTreeDiffJobOutputter.cc patched/rosetta_source/src/protocols/jd2/AtomTreeDiffJobOutputter.cc
--- vanilla/rosetta_source/src/protocols/jd2/AtomTreeDiffJobOutputter.cc	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/AtomTreeDiffJobOutputter.cc	2012-06-10 16:12:40.381040940 +0200
@@ -185,8 +185,8 @@ AtomTreeDiffJobOutputter::other_pose(
   JobCOP /*job*/,
 	core::pose::Pose const & /*pose*/,
 	std::string const & /*tag*/,
-	int copy_count, /*default -1 */
-	bool score_only /*default false*/
+	int /*copy_count*/, /*default -1 */
+	bool /*score_only*/ /*default false*/
  ){
 	// do something with this function later
 	return;
diff -rupN vanilla/rosetta_source/src/protocols/jd2/DockDesignParser.cc patched/rosetta_source/src/protocols/jd2/DockDesignParser.cc
--- vanilla/rosetta_source/src/protocols/jd2/DockDesignParser.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/DockDesignParser.cc	2012-06-10 16:12:40.384041141 +0200
@@ -36,18 +36,12 @@
 #include <utility/tag/Tag.hh>
 #include <core/scoring/ScoreType.hh>
 #include <core/pose/metrics/CalculatorFactory.hh>
-//#include <protocols/forge/build/BuildInstruction.hh>
-//#include <protocols/flxbb/FlxbbDesign.hh>
-//#include <protocols/flxbb/DesignTask.hh>
 
 // movers
-//#include <protocols/simple_moves/ConstraintSetMover.hh>
 #include <protocols/moves/Mover.hh>
 #include <protocols/moves/MoverFactory.hh>
-// AUTO-REMOVED #include <protocols/moves/StructureRestrictor.hh>
 #include <protocols/rosetta_scripts/ParsedProtocol.hh>
 #include <protocols/moves/NullMover.hh>
-/// #include <protocols/protein_interface_design/movers/SetupHotspotConstraintsMover.hh>
 #include <boost/foreach.hpp>
 #define foreach BOOST_FOREACH
 
@@ -132,7 +126,7 @@ typedef utility::vector0< TagPtr > TagPt
 /// Notice that the order of the sections by which the protocol is written doesn't matter, BUT the order of the
 /// mover-filter pairs in PROTOCOLS section does matter.
 bool
-DockDesignParser::generate_mover_from_pose( JobCOP job, Pose & pose, MoverOP & in_mover, bool new_input, std::string const xml_fname ){
+DockDesignParser::generate_mover_from_pose( JobCOP, Pose & pose, MoverOP & in_mover, bool new_input, std::string const xml_fname ){
 
 	bool modified_pose( false );
 
@@ -223,7 +217,7 @@ DockDesignParser::generate_mover_from_po
 		if ( curr_tag->getName() == "APPLY_TO_POSE" ) { // section is not mandatory
 			/// apply to pose may affect all of the scorefxn definitions below, so it is called first.
 			TagPtrs const apply_tags( curr_tag->getTags() );
-			bool has_profile( false ); // This mutual-exclusion check has been disabled., has_fnr( false ); // to see that the user hasn't turned both on by mistake
+			//bool has_profile( false ); // This mutual-exclusion check has been disabled., has_fnr( false ); // to see that the user hasn't turned both on by mistake
 
 			foreach(TagPtr apply_tag_ptr, apply_tags){
 				std::string const mover_type( apply_tag_ptr->getName() );
diff -rupN vanilla/rosetta_source/src/protocols/jd2/JobDistributor.cc patched/rosetta_source/src/protocols/jd2/JobDistributor.cc
--- vanilla/rosetta_source/src/protocols/jd2/JobDistributor.cc	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/JobDistributor.cc	2012-06-10 16:12:40.387041097 +0200
@@ -67,39 +67,45 @@
 #include <iterator>
 #endif
 
-namespace protocols {
-namespace jd2 {
+namespace protocols
+{
+namespace jd2
+{
 static basic::Tracer tr("protocols.jd2.JobDistributor");
-}//jd2
-}//protocols
+} //jd2
+} //protocols
 
 //multithreaded case requires special pointers
 #ifdef MULTITHREADED
 
 #include <boost/thread/tss.hpp>
 
-
-namespace protocols {
-namespace jd2 {
-boost::thread_specific_pointer< JobDistributor > jd_ptr;
-
-JobDistributor *
-JobDistributor::get_instance()
+namespace protocols
 {
-  if ( jd_ptr.get() == 0 ) {
-    jd_ptr.reset( JobDistributorFactory::create_job_distributor() );
-  }
-  return jd_ptr.get();
-}
+	namespace jd2
+	{
+		boost::thread_specific_pointer< JobDistributor > jd_ptr;
+
+		JobDistributor *
+		JobDistributor::get_instance()
+		{
+			if ( jd_ptr.get() == 0 )
+			{
+				jd_ptr.reset( JobDistributorFactory::create_job_distributor() );
+			}
+			return jd_ptr.get();
+		}
 
-}//jd2
-}//protocols
+	} //jd2
+} //protocols
 
 //non-multithreaded case behaves like a singleton
 #else
 
-namespace protocols {
-namespace jd2 {
+namespace protocols
+{
+namespace jd2
+{
 
 JobDistributor * JobDistributor::instance_ = 0; //this pointer starts null
 //JobDistributorDestroyer JobDistributor::destroyer_;
@@ -107,70 +113,76 @@ JobDistributor * JobDistributor::instanc
 JobDistributor *
 JobDistributor::get_instance()
 {
-	if ( instance_ == 0 ) {
+	if (instance_ == 0)
+	{
 		instance_ = JobDistributorFactory::create_job_distributor();
 		//	destroyer_.set_job_distributor(instance_);
 	}
 	return instance_;
 }
 
-}//jd2
-}//protocols
+} //jd2
+} //protocols
 
 #endif
 
-namespace protocols {
-namespace jd2 {
+namespace protocols
+{
+namespace jd2
+{
 
-JobDistributor::JobDistributor()
-:
-	//	job_inputter_( JobDistributorFactory::create_job_inputter() ),
-	// non-NULL starting state for this pointer; this makes calls to the
-	// JobDistributor safe even when not inside go() (of course you will get a
-	// stupid object, but at least it won't segfault).  This object deliberately
-	// goes away once it's not used.
-	current_job_( JD2_BOGUS_JOB ),
-	current_job_id_( 0 ),
-	current_batch_id_( 0 )
+JobDistributor::JobDistributor() :
+		//	job_inputter_( JobDistributorFactory::create_job_inputter() ),
+		// non-NULL starting state for this pointer; this makes calls to the
+		// JobDistributor safe even when not inside go() (of course you will get a
+		// stupid object, but at least it won't segfault).  This object deliberately
+		// goes away once it's not used.
+		current_job_(JD2_BOGUS_JOB), current_job_id_(0), last_completed_job_(0), current_batch_id_(
+				0)
 {
 	init_jd();
 }
 
-JobDistributor::JobDistributor( bool empty )
-:
-	//	job_inputter_( JobDistributorFactory::create_job_inputter() ),
-	// non-NULL starting state for this pointer; this makes calls to the
-	// JobDistributor safe even when not inside go() (of course you will get a
-	// stupid object, but at least it won't segfault).  This object deliberately
-	// goes away once it's not used.
-	current_job_( JD2_BOGUS_JOB ),
-	current_job_id_( 0 ),
-	current_batch_id_( 0 )
+JobDistributor::JobDistributor(bool empty) :
+		//	job_inputter_( JobDistributorFactory::create_job_inputter() ),
+		// non-NULL starting state for this pointer; this makes calls to the
+		// JobDistributor safe even when not inside go() (of course you will get a
+		// stupid object, but at least it won't segfault).  This object deliberately
+		// goes away once it's not used.
+		current_job_(JD2_BOGUS_JOB), current_job_id_(0), last_completed_job_(0), current_batch_id_(
+				0)
 {
-	if ( !empty ) {
+	if (!empty)
+	{
 		init_jd();
-	} else {
+	}
+	else
+	{
 		job_inputter_ = NULL;
 		job_outputter_ = new NoOutputJobOutputter;
 		parser_ = JobDistributorFactory::create_parser();
 	}
 }
 
-void JobDistributor::init_jd() {
+void JobDistributor::init_jd()
+{
 	instance_ = this; //important so that calls to get_instance in JobInputters or JobOutputters don't lead to a infinite recursion
 
 	// are there batches?
 	populate_batch_list_from_cmd();
-	if ( batches_.size() > 0) {
+	if (batches_.size() > 0)
+	{
 		tr.Debug << "batches present... " << std::endl;
 		current_batch_id_ = 1;
-		job_inputter_ = new BatchJobInputter( batches_[ 1 ] );
-	} else { //no batches...
+		job_inputter_ = new BatchJobInputter(batches_[1]);
+	}
+	else
+	{ //no batches...
 		job_inputter_ = JobDistributorFactory::create_job_inputter();
 	}
 
 	// get jobs
-	job_inputter_->fill_jobs( jobs_ );
+	job_inputter_->fill_jobs(jobs_);
 
 	// have to initialize these AFTER BatchJobInputter->fill_jobs since a new batch might change options
 	job_outputter_ = JobDistributorFactory::create_job_outputter();
@@ -178,44 +190,47 @@ void JobDistributor::init_jd() {
 }
 
 /// @details read -run:batches and put it into batches_ vector.
-void JobDistributor::populate_batch_list_from_cmd() {
-	if ( basic::options::option[ basic::options::OptionKeys::run::batches ].user() ) {
+void JobDistributor::populate_batch_list_from_cmd()
+{
+	if (basic::options::option[basic::options::OptionKeys::run::batches].user())
+	{
 		//typedef utility::vector1< utility::file::FileName >::const_iterator iterator
-		utility::vector1< utility::file::FileName > const& fns( basic::options::option[ basic::options::OptionKeys::run::batches ] );
-		std::copy( fns.begin(), fns.end(), std::back_inserter( batches_ ) );
+		utility::vector1<utility::file::FileName> const& fns(
+				basic::options::option[basic::options::OptionKeys::run::batches]);
+		std::copy(fns.begin(), fns.end(), std::back_inserter(batches_));
 	}
 }
 
-
 /// @details restart job-distribution from beginning -- useful if you need a second pass over decoys...
-void JobDistributor::restart() {
+void JobDistributor::restart()
+{
 	jobs_.clear();
 	current_job_id_ = 0;
-	current_job_ =  JD2_BOGUS_JOB;
+	last_completed_job_ = 0;
+	current_job_ = JD2_BOGUS_JOB;
 	current_batch_id_ = 0;
 	init_jd();
 }
 
-
 ///WARNING WARNING!  SINGLETONS' DESTRUCTORS ARE NEVER CALLED IN MINI!  DO NOT TRY TO PUT THINGS IN THIS FUNCTION!
 ///here's a nice link explaining why: http://www.research.ibm.com/designpatterns/pubs/ph-jun96.txt
-JobDistributor::~JobDistributor() {}
-
-
-void
-JobDistributor::go( protocols::moves::MoverOP mover ) {
-	go_main( mover );
+JobDistributor::~JobDistributor()
+{
 }
 
+void JobDistributor::go(protocols::moves::MoverOP mover)
+{
+	go_main(mover);
+}
 
-void
-JobDistributor::go( protocols::moves::MoverOP mover, JobOutputterOP jo ) {
+void JobDistributor::go(protocols::moves::MoverOP mover, JobOutputterOP jo)
+{
 	job_outputter_ = jo;
-	go( mover );
+	go(mover);
 }
 
-void
-JobDistributor::go_main( protocols::moves::MoverOP mover ) {
+void JobDistributor::go_main(protocols::moves::MoverOP mover)
+{
 	using namespace basic::options;
 	time_t const allstarttime = time(NULL);
 	core::Size tried_jobs(0); //did we try any jobs?
@@ -227,49 +242,65 @@ JobDistributor::go_main( protocols::move
 	bool first_job(true);
 
 	bool using_parser(false);
-	if ( parser_ ) { //if not NULL, we have a parser
-			using_parser = true;
-			tr.Info << "Parser is present.  Input mover will be overwritten with whatever the parser creates." << std::endl;
-	}
-	PROF_START( basic::JD2 );
+	if (parser_)
+	{ //if not NULL, we have a parser
+		using_parser = true;
+		tr.Info
+				<< "Parser is present.  Input mover will be overwritten with whatever the parser creates."
+				<< std::endl;
+	}PROF_START( basic::JD2);
 	core::pose::Pose pose;
 #ifdef BOINC_GRAPHICS
-      // attach boinc graphics pose observer
-      protocols::boinc::Boinc::attach_graphics_current_pose_observer( pose );
+	// attach boinc graphics pose observer
+	protocols::boinc::Boinc::attach_graphics_current_pose_observer( pose );
 #endif
-	while ( obtain_new_job() ) {
+	while (obtain_new_job())
+	{
 		++tried_jobs; //yes, we tried at least one job
 
 		//timing information
 		time_t const jobstarttime = time(NULL);
 		core::Size const elapsedtime(jobstarttime - allstarttime);
 
-		if ( ( option[ OptionKeys::run::maxruntime ].user() ) &&
-		  ( option[ OptionKeys::run::maxruntime ]() > 0 ) &&
-			( option[ OptionKeys::run::maxruntime ]() < int(elapsedtime)) ){
-
-			basic::Error() << "Run terminating because runtime of " << elapsedtime << " s exceeded maxruntime of "
-													<< option[ OptionKeys::run::maxruntime ]() << " s " << std::endl;
-			break;	//let it clean up in case there's useful prof information or something
+		if ((option[OptionKeys::run::maxruntime].user())
+				&& (option[OptionKeys::run::maxruntime]() > 0)
+				&& (option[OptionKeys::run::maxruntime]() < int(elapsedtime)))
+		{
+
+			basic::Error() << "Run terminating because runtime of "
+					<< elapsedtime << " s exceeded maxruntime of "
+					<< option[OptionKeys::run::maxruntime]() << " s "
+					<< std::endl;
+			break; //let it clean up in case there's useful prof information or something
 		}
 
 		// setup profiling
-		evaluation::TimeEvaluatorOP run_time( NULL );
-		if ( !option[ OptionKeys::run::no_prof_info_in_silentout ] ) {
-			job_outputter_->add_evaluation( run_time = new evaluation::TimeEvaluator ); //just don't use this in integration tests!
+		evaluation::TimeEvaluatorOP run_time(NULL);
+		if (!option[OptionKeys::run::no_prof_info_in_silentout])
+		{
+			job_outputter_->add_evaluation(run_time =
+					new evaluation::TimeEvaluator); //just don't use this in integration tests!
 		}
 
-		tr.Debug << "Starting job " << job_outputter_->output_name( current_job_ ) << std::endl; //x seconds?
+		tr.Debug << "Starting job " << job_outputter_->output_name(current_job_)
+				<< std::endl; //x seconds?
 
 		//Get a copy of the starting pose - this must be done early because the pose is read in on first use, we need to
 		//guaruntee it's been read in before the Parser gets a stab at it
 		pose.data().clear();
-		try{
+		try
+		{
 			// Can we add the PyMOL mover here?
-			if ( option[ OptionKeys::run::show_simulation_in_pymol ].user() && option[ OptionKeys::run::show_simulation_in_pymol ].value() > 0.0 ){
-				moves::AddPyMolObserver( pose, true, option[ OptionKeys::run::show_simulation_in_pymol ].value() );
+			if (option[OptionKeys::run::show_simulation_in_pymol].user()
+					&& option[OptionKeys::run::show_simulation_in_pymol].value()
+							> 0.0)
+			{
+				moves::AddPyMolObserver(
+						pose,
+						option[OptionKeys::run::keep_pymol_simulation_history](),
+						option[OptionKeys::run::show_simulation_in_pymol].value());
 			}
-			job_inputter_->pose_from_job( pose, current_job_ );
+			job_inputter_->pose_from_job(pose, current_job_);
 
 #ifdef BOINC_GRAPHICS
 			// attach boinc graphics pose observer
@@ -277,12 +308,17 @@ JobDistributor::go_main( protocols::move
 			protocols::boinc::Boinc::attach_graphics_current_pose_observer( pose );
 #endif
 
-		} catch( utility::excn::EXCN_Base& excn ) {
-			basic::Error() << "ERROR: Exception caught by JobDistributor while trying to get pose from job "
-							<< job_outputter_->output_name( current_job_ ) << excn << std::endl;
-			basic::Error() << "Treating failure as bad input; canceling similar jobs" << std::endl;
+		} catch (utility::excn::EXCN_Base& excn)
+		{
+			basic::Error()
+					<< "ERROR: Exception caught by JobDistributor while trying to get pose from job "
+					<< job_outputter_->output_name(current_job_) << excn
+					<< std::endl;
+			basic::Error()
+					<< "Treating failure as bad input; canceling similar jobs"
+					<< std::endl;
 			remove_bad_inputs_from_job_list();
-			job_failed( pose, false );
+			job_failed(pose, false);
 			pose = core::pose::Pose();
 			continue;
 		}
@@ -290,89 +326,107 @@ JobDistributor::go_main( protocols::move
 		//These if statements determine whether a new creation of the mover is appropriate
 		bool reinitialize_new_input(false);
 		bool new_input(false);
-		if (current_job_->input_tag() != last_inner_job_tag){
+		if (current_job_->input_tag() != last_inner_job_tag)
+		{
 			//this means we have just changed inputs - the next pdb on -l, etc
-			tr.Debug << "new input detected, is: " << current_job_->input_tag() << ", last was: "
-							 << last_inner_job_tag << std::endl;
+			tr.Debug << "new input detected, is: " << current_job_->input_tag()
+					<< ", last was: " << last_inner_job_tag << std::endl;
 			last_inner_job_tag = current_job_->input_tag();
 			new_input = true;
 			retries_this_job = 0;
 
 			//do we need to reinitialize because of the new input? - yes if mover says, or cmdline says
-			if ( mover && (mover->reinitialize_for_new_input() ||
-					 option[ OptionKeys::run::reinitialize_mover_for_new_input ] ) ) {
+			if (mover
+					&& (mover->reinitialize_for_new_input()
+							|| option[OptionKeys::run::reinitialize_mover_for_new_input]))
+			{
 				reinitialize_new_input = true;
 			} //if we need to reinitialize
 
+		} //if the input pose is about to change
 
-			if(option[ OptionKeys::jd2::delete_old_poses ].user()){
-				//to improve jd2 memory performance, we will delete the last
-				//input's starting pose - if inputs are sensibly ordered there
-				//is no reason to keep it.  If inputs are not sensibly ordered,
-				//then re-requiring that input will seamlessly re-read the pose
-				//from disk.  If job order is completely random this will lead
-				//to slowdowns: do not randomly order your jobs, or if you do
-				//disable this next bit.  (Previous to this, jd2 never deleted
-				//input poses and would accumulate memory over large input sets
-				//- not a memory leak but certainly a nasty spot in the
-				//basement.) SML 8/7/09
-
-				//This was applied in r32237 but it had problems with special
-				//uses of the job distributor and it was reverted. This should
-				//probably be applied by default, once the issues with the
-				//special uses are worked out.
-
-				if(!first_job) jobs_[current_job_id_-1]->inner_job_nonconst()->set_pose(NULL);
+		if (option[OptionKeys::jd2::delete_old_poses].user())
+		{
+			//to improve jd2 memory performance, we will delete the last
+			//input's starting pose. (Previous to this, jd2 never deleted
+			//input poses and would accumulate memory over large input sets
+			//- not a memory leak but certainly a nasty spot in the
+			//basement.) SML 8/7/09
+
+			//This was applied in r32237 but it had problems with special
+			//uses of the job distributor and it was reverted. This should
+			//probably be applied by default, once the issues with the
+			//special uses are worked out.
+
+			if (!first_job && last_completed_job_ != 0)
+			{
+				tr.Debug << "deleting pose from job " << last_completed_job_ <<std::endl;
+				jobs_[last_completed_job_]->inner_job_nonconst()->set_pose(
+						NULL);
 			}
-			//delete pointer to pose of last input; if that was last pointer
-			//to pose (and it should have been) this will free the memory
+		}
+		//delete pointer to pose of last input; if that was last pointer
+		//to pose (and it should have been) this will free the memory
 
-		} //if the input pose is about to change
 
-		if ( current_batch_id() != last_batch_id ) {
-			tr.Debug << "new batch detected: get fresh instance from mover" << std::endl;
+		if (current_batch_id() != last_batch_id)
+		{
+			tr.Debug << "new batch detected: get fresh instance from mover"
+					<< std::endl;
 			new_input = true;
 			reinitialize_new_input = true;
 			last_batch_id = current_batch_id();
 		}
 
 		//for regular movers, reinitialize if desired
-		if ( !using_parser &&
-				 ( reinitialize_new_input ||
-					 mover->reinitialize_for_each_job() ||
-					 option[ OptionKeys::run::reinitialize_mover_for_each_job ]) ) {
+		if (!using_parser
+				&& (reinitialize_new_input || mover->reinitialize_for_each_job()
+						|| option[OptionKeys::run::reinitialize_mover_for_each_job]))
+		{
 			tr.Trace << "reinitializing the mover" << std::endl;
-			PROF_STOP( basic::JD2 );
-			PROF_START( basic::JD2_INIT_MOVER );
+			PROF_STOP( basic::JD2);
+			PROF_START( basic::JD2_INIT_MOVER);
 			mover_copy = mover->fresh_instance();
-			PROF_STOP( basic::JD2_INIT_MOVER );
-			PROF_START( basic::JD2 );
-		} else if (using_parser) { //call the parser
-			tr.Trace << "Allowing the Parser to create a new Mover if desired" << std::endl;
-            try{
-                parser_->generate_mover_from_job(current_job_, mover_copy, new_input);
-            } catch( utility::excn::EXCN_Base& excn ) {
-                basic::Error() << "ERROR: Exception caught by JobDistributor while trying to get pose from job "
-							<< job_outputter_->output_name( current_job_ ) << excn << std::endl;
-                basic::Error() << "Treating failure as bad input; canceling similar jobs" << std::endl;
-                remove_bad_inputs_from_job_list();
-                job_failed( pose, false );
-                continue;
-            }
+			PROF_STOP( basic::JD2_INIT_MOVER);
+			PROF_START( basic::JD2);
+		}
+		else if (using_parser)
+		{ //call the parser
+			tr.Trace << "Allowing the Parser to create a new Mover if desired"
+					<< std::endl;
+			try
+			{
+				parser_->generate_mover_from_job(current_job_, mover_copy,
+						new_input);
+			} catch (utility::excn::EXCN_Base& excn)
+			{
+				basic::Error()
+						<< "ERROR: Exception caught by JobDistributor while trying to get pose from job "
+						<< job_outputter_->output_name(current_job_) << excn
+						<< std::endl;
+				basic::Error()
+						<< "Treating failure as bad input; canceling similar jobs"
+						<< std::endl;
+				remove_bad_inputs_from_job_list();
+				job_failed(pose, false);
+				continue;
+			}
 			//the Parser might have modified the starting pose (with constraints) - so we'll refresh our copy
-			job_inputter_->pose_from_job( pose, current_job_ );
+			job_inputter_->pose_from_job(pose, current_job_);
 
 #ifdef BOINC_GRAPHICS
-      // attach boinc graphics pose observer
-      // do it here because pose_from_job may replace the pose conformation
-      protocols::boinc::Boinc::attach_graphics_current_pose_observer( pose );
+			// attach boinc graphics pose observer
+			// do it here because pose_from_job may replace the pose conformation
+			protocols::boinc::Boinc::attach_graphics_current_pose_observer( pose );
 #endif
 #ifdef GL_GRAPHICS
-		//nonboinc viewer
-		protocols::viewer::add_conformation_viewer( pose.conformation(), "start_pose" );
+			//nonboinc viewer
+			protocols::viewer::add_conformation_viewer( pose.conformation(), "start_pose" );
 #endif
 
-		} else {
+		}
+		else
+		{
 			tr.Trace << "not reinitializing mover" << std::endl;
 			//mover_copy = mover; //This breaks when reinitializing only on new input, because non-reinitializing cycles will
 			//revert to the wrong place.  If a mover_copy = something is desireable for all options, we need a second
@@ -383,282 +437,375 @@ JobDistributor::go_main( protocols::move
 		mover_copy->reset_status();
 		// clear old string info from previous apply calls
 		mover_copy->clear_info();
-		if ( run_time ) run_time->reset(); //reset clock of TimeEvaluator
+		if (run_time)
+			run_time->reset(); //reset clock of TimeEvaluator
 
 		// notify JobOutputter of starting pose, for comparison purposes and/or as interface for initializing evaluators. (Currently does nothing in the base class.)
-		job_outputter_->starting_pose( pose );
+		job_outputter_->starting_pose(pose);
 
 		protocols::moves::MoverStatus status;
-		PROF_STOP( basic::JD2 );
-		try {
-			if( basic::options::option[ basic::options::OptionKeys::out::std_IO_exit_error_code ]() > 0 ) std::cout.exceptions( std::ios_base::badbit);
+		PROF_STOP( basic::JD2);
+		try
+		{
+			if (basic::options::option[basic::options::OptionKeys::out::std_IO_exit_error_code]()
+					> 0)
+				std::cout.exceptions(std::ios_base::badbit);
 
 			tr.Debug << "run mover... " << std::endl;
-			mover_copy->set_current_tag( job_outputter_->output_name( current_job_ ) );
-			mover_copy->apply( pose );
+			mover_copy->set_current_tag(
+					job_outputter_->output_name(current_job_));
+			mover_copy->apply(pose);
 			status = mover_copy->get_last_move_status();
 			// Job collects (optional) string info from the mover.
 			// This info may be output later by a JobOutputter.
-			current_job_->add_strings( mover_copy->info() );
+			current_job_->add_strings(mover_copy->info());
 
-		} catch(std::ios_base::failure& ex) {
-				std::cerr << "std::IO error detected... exiting..." << std::endl; // We can not longer use Tracer's at this point
-				std::exit( basic::options::option[ basic::options::OptionKeys::out::std_IO_exit_error_code ]() ); // Using pure exit instead of utility_exit_with_status to avoid recursion
-
-		} catch ( utility::excn::EXCN_BadInput& excn ) {
-			tr.Error << "\n\n[ERROR] Exception caught by JobDistributor for job " << job_outputter_->output_name( current_job_ )
-							 << excn << std::endl;
+		} catch (std::ios_base::failure& ex)
+		{
+			std::cerr << "std::IO error detected... exiting..." << std::endl; // We can not longer use Tracer's at this point
+			std::exit(
+					basic::options::option[basic::options::OptionKeys::out::std_IO_exit_error_code]()); // Using pure exit instead of utility_exit_with_status to avoid recursion
+
+		} catch (utility::excn::EXCN_BadInput& excn)
+		{
+			tr.Error
+					<< "\n\n[ERROR] Exception caught by JobDistributor for job "
+					<< job_outputter_->output_name(current_job_) << excn
+					<< std::endl;
 			status = protocols::moves::FAIL_BAD_INPUT;
 
-		} catch ( utility::excn::EXCN_Base& excn ) {
-			tr.Error << "\n\n[ERROR] Exception caught by JobDistributor for job " << job_outputter_->output_name( current_job_ )
-							 << excn << std::endl;
+		} catch (utility::excn::EXCN_Base& excn)
+		{
+			tr.Error
+					<< "\n\n[ERROR] Exception caught by JobDistributor for job "
+					<< job_outputter_->output_name(current_job_) << excn
+					<< std::endl;
 			status = protocols::moves::FAIL_DO_NOT_RETRY;
 		}
-		std::cout.exceptions( std::ios_base::goodbit); // Disabling std::IO exceptions
-
+		std::cout.exceptions(std::ios_base::goodbit); // Disabling std::IO exceptions
 
-		PROF_START( basic::JD2 );
+		PROF_START( basic::JD2);
 		core::Size jobtime(time(NULL) - jobstarttime);
 
 		begin_critical_section();
-		PROF_START( basic::JD2_OUTPUT );
+		PROF_START( basic::JD2_OUTPUT);
 		// check cases: SUCCESS, FAIL_RETRY, FAIL_DO_NOT_RETRY, FAIL_BAD_INPUT
-		if ( status == protocols::moves::MS_SUCCESS ) {
-			if( using_parser ){
-				core::scoring::ScoreFunctionOP scorefxn = core::scoring::getScoreFunction();
+		if (status == protocols::moves::MS_SUCCESS)
+		{
+			if (using_parser)
+			{
+				core::scoring::ScoreFunctionOP scorefxn =
+						core::scoring::getScoreFunction();
 				//fpd if the pose is symmetric use a symmetric scorefunction
 				if (core::pose::symmetry::is_symmetric(pose))
-					scorefxn = core::scoring::ScoreFunctionOP( new core::scoring::symmetry::SymmetricScoreFunction( scorefxn ) );
- 				(*scorefxn)(pose);
+					scorefxn = core::scoring::ScoreFunctionOP(
+							new core::scoring::symmetry::SymmetricScoreFunction(
+									scorefxn));
+				(*scorefxn)(pose);
 			}
-			job_succeeded( pose, jobtime );
+			last_completed_job_ = current_job_id_;
+			job_succeeded(pose, jobtime);
 			//			tr.Info << job_outputter_->output_name( current_job_ ) << " reported success in " << jobtime << " seconds" << std::endl;
-		} else if ( status == protocols::moves::FAIL_RETRY ) {
+		}
+		else if (status == protocols::moves::FAIL_RETRY)
+		{
 			using namespace basic::options::OptionKeys::jd2;
 			++retries_this_job;
-			if (option[ ntrials ].user() && (retries_this_job >= (core::Size) option[ ntrials ].value())){
+			if (option[ntrials].user()
+					&& (retries_this_job >= (core::Size) option[ntrials].value()))
+			{
 				//this represents too many FAIL_RETRY - we will roll over into FAIL_DO_NOT_RETRY
-				tr.Warning << job_outputter_->output_name( current_job_ ) << " reported failure " << retries_this_job << " times and will no longer retry (permanent failure)" << std::endl;
-				job_failed( pose, false /* will not retry */ );
-			} else {
+				tr.Warning << job_outputter_->output_name(current_job_)
+						<< " reported failure " << retries_this_job
+						<< " times and will no longer retry (permanent failure)"
+						<< std::endl;
+				job_failed(pose, false /* will not retry */);
+			}
+			else
+			{
 				mark_current_job_id_for_repetition();
-				tr.Warning << job_outputter_->output_name( current_job_ ) << " reported failure and will retry" << std::endl;
-				job_failed( pose, true /* will retry */ );
+				tr.Warning << job_outputter_->output_name(current_job_)
+						<< " reported failure and will retry" << std::endl;
+				job_failed(pose, true /* will retry */);
 			}
-		} else if ( status == protocols::moves::FAIL_DO_NOT_RETRY ) {
-			tr.Warning << job_outputter_->output_name( current_job_ ) << " reported failure and will NOT retry" << std::endl;
-			job_failed( pose, false /* will not retry */ );
-		} else if ( status == protocols::moves::FAIL_BAD_INPUT ) {
-			tr.Warning << job_outputter_->output_name( current_job_ )
-				 << " reported that its input was bad and will not retry" << std::endl;
+		}
+		else if (status == protocols::moves::FAIL_DO_NOT_RETRY)
+		{
+			tr.Warning << job_outputter_->output_name(current_job_)
+					<< " reported failure and will NOT retry" << std::endl;
+			job_failed(pose, false /* will not retry */);
+		}
+		else if (status == protocols::moves::FAIL_BAD_INPUT)
+		{
+			tr.Warning << job_outputter_->output_name(current_job_)
+					<< " reported that its input was bad and will not retry"
+					<< std::endl;
 			remove_bad_inputs_from_job_list();
-			job_failed( pose, false /*will not retry */ );
+			job_failed(pose, false /*will not retry */);
 		}
 		end_critical_section();
 		current_job_finished();
-		PROF_STOP( basic::JD2_OUTPUT );
+		PROF_STOP( basic::JD2_OUTPUT);
 		basic::prof_show();
 		first_job = false; //we've finished one by now, and are no longer on the first job edge case
-	}
-	PROF_STOP( basic::JD2 );
+	}PROF_STOP( basic::JD2);
 	note_all_jobs_finished();
-	if ( batches_.size() ) {
+	if (batches_.size())
+	{
 		tr.Info << jobs_.size() << " jobs in last batch... in total ";
-	} else {
+	}
+	else
+	{
 		tr.Info << jobs_.size() << " jobs considered, ";
 	}
-	tr.Info << tried_jobs << " jobs attempted in " << (time(NULL) - allstarttime) << " seconds" << std::endl;
-	if (tried_jobs == 0) tr.Info << "no jobs were attempted, did you forget to pass -overwrite?" << std::endl;
+	tr.Info << tried_jobs << " jobs attempted in "
+			<< (time(NULL) - allstarttime) << " seconds" << std::endl;
+	if (tried_jobs == 0)
+		tr.Info << "no jobs were attempted, did you forget to pass -overwrite?"
+				<< std::endl;
 	job_outputter_->flush(); //This call forces out any unprinted data
 	basic::prof_show();
 }
 
-JobOP JobDistributor::current_job() const { return current_job_; }
+JobOP JobDistributor::current_job() const
+{
+	return current_job_;
+}
 
-std::string
-JobDistributor::current_output_name() const
+std::string JobDistributor::current_output_name() const
 {
 	return job_outputter()->output_name(current_job());
 }
 
-JobOutputterOP
-JobDistributor::job_outputter() const { return job_outputter_; }
+JobOutputterOP JobDistributor::job_outputter() const
+{
+	return job_outputter_;
+}
 
 /// @brief The input source for the current JobInputter.
-JobInputterInputSource::Enum
-JobDistributor::job_inputter_input_source() const {
+JobInputterInputSource::Enum JobDistributor::job_inputter_input_source() const
+{
 	return job_inputter_->input_source();
 }
 
-bool
-JobDistributor::obtain_new_job( bool reconsider_current_job ) {
-	if ( reconsider_current_job ) --current_job_id_;
+bool JobDistributor::obtain_new_job(bool reconsider_current_job)
+{
+	if (reconsider_current_job)
+		--current_job_id_;
 
-	if ( batches_.size() == 0 || get_current_batch() != BatchJobInputter::BOGUS_BATCH_ID ) { //batches can be cancelled during computation
+	if (batches_.size() == 0
+			|| get_current_batch() != BatchJobInputter::BOGUS_BATCH_ID)
+	{ //batches can be cancelled during computation
 		current_job_id_ = get_new_job_id(); //if no batches are present, or current batch still valid
-	} else {
+	}
+	else
+	{
 		current_job_id_ = 0; //batch got cancelled... jump to end of batch....
 	}
 
-	if ( current_job_id_ == 0 ) {
-		if ( next_batch() ) { //query if there is a new batch to run after this one has finished
+	if (current_job_id_ == 0)
+	{
+		if (next_batch())
+		{ //query if there is a new batch to run after this one has finished
 			current_job_id_ = 0;
 			return obtain_new_job(); //set to first job of new batch... --- if batch is already computed fully this migh call next_batch() !
 		}
 		return false;
-	} else if ( current_job_id_ <= jobs_.size() ) {
-		current_job_ = jobs_[ current_job_id_ ];
+	}
+	else if (current_job_id_ <= jobs_.size())
+	{
+		current_job_ = jobs_[current_job_id_];
 		return true;
-	} else {
-		utility_exit_with_message("JobDistributor: nonexistent job returned in obtain_new_job()");
+	}
+	else
+	{
+		utility_exit_with_message(
+				"JobDistributor: nonexistent job returned in obtain_new_job()");
 		return false;
 	}
 }
 
-void
-JobDistributor::job_succeeded( core::pose::Pose & pose, core::Real run_time ) {
-	job_outputter_->final_pose( current_job_, pose );
+void JobDistributor::job_succeeded(core::pose::Pose & pose, core::Real run_time)
+{
+	job_outputter_->final_pose(current_job_, pose);
 	//current_job_->set_completed();
-	mark_job_as_completed( current_job_id_, run_time );
+	mark_job_as_completed(current_job_id_, run_time);
 	return;
 }
 
 /// @details no-op implementation in the base class
-void
-JobDistributor::job_failed( core::pose::Pose & /*pose*/, bool /*will_retry*/ )
-{}
-
+void JobDistributor::job_failed(core::pose::Pose & /*pose*/,
+		bool /*will_retry*/)
+{
+}
 
-void JobDistributor::mark_job_as_completed( core::Size job_id, core::Real run_time ) {
-	jobs_[ job_id ]->set_completed();
-	tr.Info << job_outputter_->output_name( jobs_[ job_id ] ) << " reported success in " << run_time << " seconds" << std::endl;
+void JobDistributor::mark_job_as_completed(core::Size job_id,
+		core::Real run_time)
+{
+	jobs_[job_id]->set_completed();
+	tr.Info << job_outputter_->output_name(jobs_[job_id])
+			<< " reported success in " << run_time << " seconds" << std::endl;
 	//	tr.Info << "completed job: " << job_outputter_->output_name( jobs_[ job_id ] ) << std::endl;
 }
 
-void JobDistributor::mark_job_as_bad( core::Size job_id ) {
-	jobs_[ job_id ]->set_bad();
+void JobDistributor::mark_job_as_bad(core::Size job_id)
+{
+	jobs_[job_id]->set_bad();
 }
 
-void
-JobDistributor::remove_bad_inputs_from_job_list() {}
+void JobDistributor::remove_bad_inputs_from_job_list()
+{
+}
 
-void
-JobDistributor::current_job_finished() {}
+void JobDistributor::current_job_finished()
+{
+}
 
-void
-JobDistributor::note_all_jobs_finished() {}
+void JobDistributor::note_all_jobs_finished()
+{
+}
 
 //This next line prevents accumulation of state within the Job object - should it be within another function?
-void
-JobDistributor::clear_current_job_output(){
-	jobs_[ current_job_id_ ] = current_job_->copy_without_output();//is this unsafe?  should be its own function? MT: It is now!
+void JobDistributor::clear_current_job_output()
+{
+	jobs_[current_job_id_] = current_job_->copy_without_output(); //is this unsafe?  should be its own function? MT: It is now!
 }
 
-void JobDistributor::begin_critical_section() {}
+void JobDistributor::begin_critical_section()
+{
+}
 
-void JobDistributor::end_critical_section() {}
+void JobDistributor::end_critical_section()
+{
+}
 
 //////////////////////protected accessor functions////////////////////
-core::Size JobDistributor::current_job_id() const { return current_job_id_; }
-
+core::Size JobDistributor::current_job_id() const
+{
+	return current_job_id_;
+}
 
 Jobs const &
-JobDistributor::get_jobs() const { return jobs_; }
+JobDistributor::get_jobs() const
+{
+	return jobs_;
+}
 
 // Jobs &
 // JobDistributor::get_jobs()  { return jobs_; }
 
-JobInputterOP
-JobDistributor::job_inputter() const { return job_inputter_; }
-
-
+JobInputterOP JobDistributor::job_inputter() const
+{
+	return job_inputter_;
+}
 
-void JobDistributor::mpi_finalize(bool )
+void JobDistributor::mpi_finalize(bool)
 {
 	//dummy default implementation
 }
 
-
-ParserOP
-JobDistributor::parser() const { return parser_; }
+ParserOP JobDistributor::parser() const
+{
+	return parser_;
+}
 
 /////////////////////////batch stuff //////////////////////////
-std::string JobDistributor::get_current_batch() const {
-	if ( current_batch_id_ && batches_.size() > 0 && current_batch_id_ <= batches_.size() ) {
-		return batches_[ current_batch_id_ ];
-	} else {
+std::string JobDistributor::get_current_batch() const
+{
+	if (current_batch_id_ && batches_.size() > 0
+			&& current_batch_id_ <= batches_.size())
+	{
+		return batches_[current_batch_id_];
+	}
+	else
+	{
 		return BatchJobInputter::BOGUS_BATCH_ID;
 	}
 }
 
-void JobDistributor::set_batch_id( core::Size setting ) {
-	if ( current_batch_id_ == setting ) return;
+void JobDistributor::set_batch_id(core::Size setting)
+{
+	if (current_batch_id_ == setting)
+		return;
 	current_batch_id_ = setting;
-	if ( current_batch_id_ > batches_.size() ) batch_underflow();
-	if ( current_batch_id_ > batches_.size() ) {
-		tr.Error << "[ERROR] illegeal attempt to set batch_id to " << setting << " where we have only "
-						 << batches_.size() << " batches" << std::endl;
+	if (current_batch_id_ > batches_.size())
+		batch_underflow();
+	if (current_batch_id_ > batches_.size())
+	{
+		tr.Error << "[ERROR] illegeal attempt to set batch_id to " << setting
+				<< " where we have only " << batches_.size() << " batches"
+				<< std::endl;
 		utility_exit_with_message("wrong batch_id");
 	}
 	load_new_batch();
 }
 
-
-
-bool JobDistributor::next_batch() {
+bool JobDistributor::next_batch()
+{
 	++current_batch_id_;
 
-	if ( current_batch_id_ > batches_.size() ) batch_underflow();
-	if ( current_batch_id_ > batches_.size() ) { //still no new batches.
+	if (current_batch_id_ > batches_.size())
+		batch_underflow();
+	if (current_batch_id_ > batches_.size())
+	{ //still no new batches.
 		tr.Info << "no more batches to process... " << std::endl;
 		return false;
 	}
 
 	//skip BOGUS_BATCHES ..
-	while ( current_batch_id_ <= batches_.size() && get_current_batch() == BatchJobInputter::BOGUS_BATCH_ID ) ++current_batch_id_;
+	while (current_batch_id_ <= batches_.size()
+			&& get_current_batch() == BatchJobInputter::BOGUS_BATCH_ID)
+		++current_batch_id_;
 
 	//if ended on BOGUS_BATCH
-	if ( get_current_batch() == BatchJobInputter::BOGUS_BATCH_ID ) {
+	if (get_current_batch() == BatchJobInputter::BOGUS_BATCH_ID)
+	{
 		tr.Trace << "last batch is CANCELLED: run next_batch()" << std::endl;
 		return next_batch();
 	}
 
-	runtime_assert( current_batch_id_ <= batches_.size() );
+	runtime_assert( current_batch_id_ <= batches_.size());
 	load_new_batch();
 	return true;
 }
 
 /// @detail add new batch to end of batch list... this might be called asynchronous... ie. while we are still in the middle of
 /// a current batch, or while we are in non-batch mode
-void JobDistributor::add_batch( std::string const& batch, core::Size id ) {
-	while ( id > batches_.size() ) {
-		batches_.push_back( BatchJobInputter::BOGUS_BATCH_ID );
-	}
-	if ( id > 0 ) {
-		batches_[ id ] = batch;
-	} else {
-		batches_.push_back( batch );
+void JobDistributor::add_batch(std::string const& batch, core::Size id)
+{
+	while (id > batches_.size())
+	{
+		batches_.push_back(BatchJobInputter::BOGUS_BATCH_ID);
+	}
+	if (id > 0)
+	{
+		batches_[id] = batch;
+	}
+	else
+	{
+		batches_.push_back(batch);
 	}
 }
 
 /// @detail restart JobDistributor with a new batch the BatchJobInputter loads
 /// new flags and sets global options after this we reload Factory dependent
 /// Objects (e.g., JobInputter and JobOutputter )
-void JobDistributor::load_new_batch() {
-	runtime_assert( current_batch_id_ <= batches_.size() ); //paranoid
+void JobDistributor::load_new_batch()
+{
+	runtime_assert( current_batch_id_ <= batches_.size());
+	//paranoid
 
 	jobs_.clear();
 	current_job_id_ = 0;
-	current_job_ =  JD2_BOGUS_JOB;
+	current_job_ = JD2_BOGUS_JOB;
 
 	//remaking job_inputter has the advantage, that we will also get one, if
 	//this is the first batch!
 	job_inputter_ = NULL; //triggers destructor --> restores options
-	tr.Info << "start batch " << batches_[ current_batch_id_ ] << std::endl;
-	job_inputter_ = new BatchJobInputter( batches_[ current_batch_id_ ] );
+	tr.Info << "start batch " << batches_[current_batch_id_] << std::endl;
+	job_inputter_ = new BatchJobInputter(batches_[current_batch_id_]);
 
-	job_inputter_->fill_jobs( jobs_ );
+	job_inputter_->fill_jobs(jobs_);
 	// have to initialize these AFTER BatchJobInputter->fill_jobs an new batch
 	// might change options
 
@@ -671,7 +818,8 @@ void JobDistributor::load_new_batch() {
 }
 
 /// @brief Movers (or derived classes) may ask for the JobOutputter
-void JobDistributor::set_job_outputter( const JobOutputterOP &new_job_outputter ){
+void JobDistributor::set_job_outputter(const JobOutputterOP &new_job_outputter)
+{
 	job_outputter_ = new_job_outputter;
 }
 
@@ -691,50 +839,54 @@ void JobDistributor::set_job_outputter( 
 void JobDistributor::jd2_signal_handler(int signal_)
 {
 	std::cout << "Got some signal... It is:" << signal_ << std::endl;
-	if( signal_ == SIGINT ) std::cout << "Ctrl-c was pressed!" << std::endl;
-	if( signal_ == SIGABRT ) std::cout << "Process was aborted!" << std::endl;
-	if( signal_ == SIGTERM ) std::cout << "Process was terminated!" << std::endl;
+	if (signal_ == SIGINT)
+		std::cout << "Ctrl-c was pressed!" << std::endl;
+	if (signal_ == SIGABRT)
+		std::cout << "Process was aborted!" << std::endl;
+	if (signal_ == SIGTERM)
+		std::cout << "Process was terminated!" << std::endl;
 
 #ifndef WIN32
-	if( signal_ == SIGKILL ) std::cout << "Process was SIGKILL!" << std::endl;
-	if( signal_ == SIGQUIT ) std::cout << "Process was SIGQUIT!" << std::endl;
+	if (signal_ == SIGKILL)
+		std::cout << "Process was SIGKILL!" << std::endl;
+	if (signal_ == SIGQUIT)
+		std::cout << "Process was SIGQUIT!" << std::endl;
 #endif
 
-	if ( get_instance()->job_outputter_ ) get_instance()->job_outputter_->flush(); //This call forces out any unprinted but finished data
+	if (get_instance()->job_outputter_)
+		get_instance()->job_outputter_->flush(); //This call forces out any unprinted but finished data
 	get_instance()->handle_interrupt();
 
 	//utility_exit_with_status(1);
-	std::exit( 1 ); // Using pure exit instead of utility_exit_with_status to avoid recursion when compile with EXIT_THROWS_EXCEPTION
+	std::exit(1); // Using pure exit instead of utility_exit_with_status to avoid recursion when compile with EXIT_THROWS_EXCEPTION
 }
 
-
 /// @details Setting up callback function that will be call when our process is about to terminate.
 // /@details This will allow us to exit propely (clean up in_progress_files/tmp files if any).
-void JobDistributor::setup_system_signal_handler( void (*signal_fn)(int) )
+void JobDistributor::setup_system_signal_handler(void(*signal_fn)(int))
 {
 	// Soooo many way to kill... wait - there is no special signal for HS with SVD? - lame...
-	signal(SIGINT,  signal_fn);
+	signal(SIGINT, signal_fn);
 	signal(SIGABRT, signal_fn);
 	signal(SIGTERM, signal_fn);
 
-	#ifndef WIN32
-		signal(SIGKILL, signal_fn);
-		signal(SIGQUIT, signal_fn);
-	#endif
+#ifndef WIN32
+	signal(SIGKILL, signal_fn);
+	signal(SIGQUIT, signal_fn);
+#endif
 }
 
 /// @details Set signal handler back to default state.
 void JobDistributor::remove_system_signal_handler()
 {
-	signal(SIGINT,  SIG_DFL);
+	signal(SIGINT, SIG_DFL);
 	signal(SIGABRT, SIG_DFL);
 	signal(SIGTERM, SIG_DFL);
-	#ifndef WIN32
-		signal(SIGKILL, SIG_DFL);
-		signal(SIGQUIT, SIG_DFL);
-	#endif
+#ifndef WIN32
+	signal(SIGKILL, SIG_DFL);
+	signal(SIGQUIT, SIG_DFL);
+#endif
 }
 
-
-}//jd2
-}//protocols
+} //jd2
+} //protocols
diff -rupN vanilla/rosetta_source/src/protocols/jd2/JobDistributor.hh patched/rosetta_source/src/protocols/jd2/JobDistributor.hh
--- vanilla/rosetta_source/src/protocols/jd2/JobDistributor.hh	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/JobDistributor.hh	2012-06-10 16:12:40.390041097 +0200
@@ -233,6 +233,9 @@ private:
 	/// @brief access into jobs_ vector indicating current job.  Contains more information than current_job_ in that it can be incremented...
 	core::Size current_job_id_;
 
+	/// @brief access into jobs_ bector indicating the previous job.  Used with the -jd2:delete_old_poses option for deleting unnecessary poses
+	core::Size last_completed_job_;
+
 	//this is if NOT defined - keep this static pointer for singleton management only in non-multithreaded case
 #ifndef MULTITHREADED
 	static JobDistributor * instance_;
diff -rupN vanilla/rosetta_source/src/protocols/jd2/JobInputterFactory.cc patched/rosetta_source/src/protocols/jd2/JobInputterFactory.cc
--- vanilla/rosetta_source/src/protocols/jd2/JobInputterFactory.cc	2012-03-21 09:05:59.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/JobInputterFactory.cc	2012-06-10 16:12:40.392071608 +0200
@@ -78,7 +78,7 @@ JobInputterFactory::get_JobInputter_from
 			TR << mover_it->first<<", ";
 		}
 		TR << std::endl;
-		utility_exit_with_message( job_inputter_type + " is not known to the JobInputterFactory. Was it registered via a JobInputterRegistrator in one of the init.cc files (protocols/init/init.cc or protocols/init/init.cc)?" );
+		utility_exit_with_message( job_inputter_type + " is not known to the JobInputterFactory. Was it registered via a JobInputterRegistrator in one of the init.cc files (devel/init.cc or protocols/init.cc)?" );
 		return NULL;
 	}
 }
diff -rupN vanilla/rosetta_source/src/protocols/jd2/LazySilentFileJobInputter.hh patched/rosetta_source/src/protocols/jd2/LazySilentFileJobInputter.hh
--- vanilla/rosetta_source/src/protocols/jd2/LazySilentFileJobInputter.hh	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/LazySilentFileJobInputter.hh	2012-06-10 16:12:40.395040639 +0200
@@ -1,3 +1,11 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
 
 #ifndef INCLUDED_protocols_jd2_LazySilentFileJobInputter_HH
 #define INCLUDED_protocols_jd2_LazySilentFileJobInputter_HH
@@ -29,7 +37,7 @@ namespace jd2 {
     virtual void fill_jobs( Jobs & jobs );
 
     virtual JobInputterInputSource::Enum input_source() const;
-    
+
     core::io::silent::SilentFileData const& silent_file_data() const { return sfd_; };
 
 
diff -rupN vanilla/rosetta_source/src/protocols/jd2/MpiFileBuffer.cc patched/rosetta_source/src/protocols/jd2/MpiFileBuffer.cc
--- vanilla/rosetta_source/src/protocols/jd2/MpiFileBuffer.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/MpiFileBuffer.cc	2012-06-10 16:12:40.398039655 +0200
@@ -138,7 +138,7 @@ void MpiFileBuffer::run() {
 		} else if ( msg_type == MPI_STREAM_CLOSE ) {
 			close_channel( slave, channel_id );
 		} else if ( msg_type == MPI_STREAM_FLUSH ) {
-			tr.Info << "MPI_STREAM_FLUSH received" << std::endl;
+			tr.Debug << "MPI_STREAM_FLUSH received" << std::endl;
 			flush_channel( slave, channel_id );
 		} else if ( msg_type == MPI_WIND_DOWN ) {
 			bStop_ = true;
@@ -296,7 +296,7 @@ void MpiFileBuffer::clear_channel_from_g
 #ifdef USEMPI
 void MpiFileBuffer::open_channel( Size slave, std::string const& filename, bool append, Size& status ) {
 	//find filename in our file-map...
-	tr.Info << "open mpi-channel from slave-node " << slave << " for file: " << filename << std::endl;
+	tr.Debug << "open mpi-channel from slave-node " << slave << " for file: " << filename << std::endl;
 	Filenames::const_iterator iter = open_files_.find( filename );
 	Size channel;
 	if ( iter != open_files_.end() ) {
diff -rupN vanilla/rosetta_source/src/protocols/jd2/MPIFileBufJobDistributor.cc patched/rosetta_source/src/protocols/jd2/MPIFileBufJobDistributor.cc
--- vanilla/rosetta_source/src/protocols/jd2/MPIFileBufJobDistributor.cc	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/MPIFileBufJobDistributor.cc	2012-06-10 16:12:40.401041193 +0200
@@ -211,7 +211,6 @@ MPIFileBufJobDistributor::process_messag
 	case JOB_FAILED_NO_RETRY :
 		++jobs_returned_;
 		break;
-
 	default:
 		tr.Error << "[ERROR] from " << slave_rank << " tag: "  << msg_tag << " " << slave_job_id << std::endl;
 		utility_exit_with_message(" unknown tag "+ ObjexxFCL::string_of( msg_tag ) +" in master_loop of MPIFileBufJobDistributor ");
diff -rupN vanilla/rosetta_source/src/protocols/jd2/MPIMultiCommJobDistributor.cc patched/rosetta_source/src/protocols/jd2/MPIMultiCommJobDistributor.cc
--- vanilla/rosetta_source/src/protocols/jd2/MPIMultiCommJobDistributor.cc	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/MPIMultiCommJobDistributor.cc	2012-06-10 16:12:40.403074494 +0200
@@ -67,6 +67,8 @@ MPIMultiCommJobDistributor::MPIMultiComm
 
 void MPIMultiCommJobDistributor::setup_sub_communicators( Size sub_size ) {
 	n_comm_ = ( n_rank()-min_client_rank() ) / sub_size;
+	tr.Debug << " can allocate " << n_comm_ << " communication groups " << std::endl;
+	tr.Debug << " n_rank: " << n_rank() << " sub_size: " << sub_size << std::endl;
 	set_n_worker( n_comm_ );
 #ifdef USEMPI
 	if ( n_comm_ < 1 ) {
@@ -95,8 +97,8 @@ void MPIMultiCommJobDistributor::setup_s
 		MPI_Comm_create( MPI_COMM_WORLD, mpi_groups_[ i_comm ], &(mpi_communicators_[ i_comm ]) );
 	}
 
-	runtime_assert( rank() < min_client_rank() || communicator_handle_ && communicator_handle_ <= mpi_communicators_.size() );
-	if ( rank() >= min_client_rank() ) {
+	runtime_assert( rank() < min_client_rank() || communicator_handle_ == 0 || communicator_handle_ <= mpi_communicators_.size() );
+	if ( rank() >= min_client_rank() && communicator_handle_ ) {
 		MPI_Comm_rank( mpi_communicators_[ communicator_handle_ ], &sub_rank_ );
 	} else {
 		sub_rank_ = -1;
diff -rupN vanilla/rosetta_source/src/protocols/jd2/NoOutputJobOutputter.hh patched/rosetta_source/src/protocols/jd2/NoOutputJobOutputter.hh
--- vanilla/rosetta_source/src/protocols/jd2/NoOutputJobOutputter.hh	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/NoOutputJobOutputter.hh	2012-06-10 16:12:40.406039699 +0200
@@ -52,7 +52,7 @@ public:
 
 	///@brief this function is intended for saving mid-protocol poses; for example the final centroid structure in a combined centroid/fullatom protocol.
 	virtual
-	void other_pose( JobCOP, core::pose::Pose const & , std::string const &, int copy_count = -1, bool score_only = false  ) {};
+	void other_pose( JobCOP, core::pose::Pose const & , std::string const &, int /*copy_count = -1*/, bool /*score_only = false*/  ) {};
 
 	/////////////////////////////////state of output functions/////////////////////////////////
 
diff -rupN vanilla/rosetta_source/src/protocols/jd2/parser/BluePrint.cc patched/rosetta_source/src/protocols/jd2/parser/BluePrint.cc
--- vanilla/rosetta_source/src/protocols/jd2/parser/BluePrint.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/parser/BluePrint.cc	2012-06-10 16:12:40.409040183 +0200
@@ -41,28 +41,28 @@ namespace parser {
 /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 /// @brief default constructor
 BluePrint::BluePrint() :
-	total_residue_( 0 ),
-	sequence_( "" ),
-	secstruct_( "" ),
-	strand_pairings_( "" ),
-	helix_pairings_( "" ),
-	hss_triplets_( "" )
+			total_residue_( 0 ),
+			sequence_( "" ),
+			secstruct_( "" ),
+			strand_pairings_( "" ),
+			helix_pairings_( "" ),
+			hss_triplets_( "" )
 {}
 
 
 /// @brief value constructor
 BluePrint::BluePrint( std::string const & filename ):
-	total_residue_( 0 ),
-	sequence_( "" ),
-	secstruct_( "" ),
-	strand_pairings_( "" ),
-	helix_pairings_( "" ),
-	hss_triplets_( "" )
+			total_residue_( 0 ),
+			sequence_( "" ),
+			secstruct_( "" ),
+			strand_pairings_( "" ),
+			helix_pairings_( "" ),
+			hss_triplets_( "" )
 {
 	if ( ! read_blueprint( filename ) ) {
-    TR.Error << "Error in reading blueprint file " << filename << std::endl;
-    exit(0);
-  }
+		TR.Error << "Error in reading blueprint file " << filename << std::endl;
+		exit(0);
+	}
 }
 
 
@@ -73,19 +73,19 @@ BluePrint::~BluePrint()
 
 /// @brief copy constructor
 BluePrint::BluePrint( BluePrint const & src ):
-	ReferenceCount(),
-	total_residue_( src.total_residue_ ),
-	sequence_( src.sequence_ ),
-	secstruct_( src.secstruct_ ),
-	resnum_( src.resnum_ ),
-	resname_( src.resname_ ),
-	sstype_( src.sstype_ ),
-	abego_( src.abego_ ),
-	buildtype_( src.buildtype_ ),
-	resnum_map_( src.resnum_map_ ),
-	strand_pairings_( src.strand_pairings_ ),
-	helix_pairings_( src.helix_pairings_ ),
-	hss_triplets_( src.hss_triplets_ )
+			ReferenceCount(),
+			total_residue_( src.total_residue_ ),
+			sequence_( src.sequence_ ),
+			secstruct_( src.secstruct_ ),
+			resnum_( src.resnum_ ),
+			resname_( src.resname_ ),
+			sstype_( src.sstype_ ),
+			abego_( src.abego_ ),
+			buildtype_( src.buildtype_ ),
+			resnum_map_( src.resnum_map_ ),
+			strand_pairings_( src.strand_pairings_ ),
+			helix_pairings_( src.helix_pairings_ ),
+			hss_triplets_( src.hss_triplets_ )
 {}
 
 
@@ -232,26 +232,26 @@ BluePrint::read_blueprint( std::string c
 {
 	using utility::string_split;
 
-  utility::io::izstream data( filename );
-  if ( !data ) {
-    TR.Error << "can not open blueprint file " << filename << std::endl;
-    return false;
-  }
+	utility::io::izstream data( filename );
+	if ( !data ) {
+		TR.Error << "can not open blueprint file " << filename << std::endl;
+		return false;
+	}
 
 	// StranPairing info read from the line of SSPAIR
 	//StrandPairings spairs;
 	String spairs;
 
-  String line;
-  Size linecount( 0 ), count( 0 );
-  while( getline( data, line ) ) {
-    linecount++;
-    std::vector< String > tokens ( utility::split( line ) );
+	String line;
+	Size linecount( 0 ), count( 0 );
+	while( getline( data, line ) ) {
+		linecount++;
+		utility::vector1< String > tokens ( utility::split( line ) );
 
 		// skip reading line that is commented out
-    if( tokens[0][0] == '#' ) continue;
+		if( tokens[1][0] == '#' ) continue;
 
-		if( tokens[0] == "FOLDINFO" || tokens[0] == "SSPAIR" || tokens[0] == "HHPAIR" || tokens[0] == "HSSTRIPLET" ) {
+		if( tokens[1] == "FOLDINFO" || tokens[1] == "SSPAIR" || tokens[1] == "HHPAIR" || tokens[1] == "HSSTRIPLET" ) {
 			// read the line of SSPAIR( FOLDINFO ), HHPAIR
 
 			if( tokens.size() > 2 ) {
@@ -259,20 +259,20 @@ BluePrint::read_blueprint( std::string c
 				return false;
 			}
 
-			if( tokens[0] == "SSPAIR" || tokens[0] == "FOLDINFO" ) {
+			if( tokens[1] == "SSPAIR" || tokens[1] == "FOLDINFO" ) {
 				// set string of strand pairings
-				strand_pairings_ = tokens[1];
-			} else if( tokens[0] == "HHPAIR" ) {
+				strand_pairings_ = tokens[2];
+			} else if( tokens[1] == "HHPAIR" ) {
 				// set string of helix pairings
-				helix_pairings_ = tokens[1];
-			} else if( tokens[0] == "HSSTRIPLET" ) {
+				helix_pairings_ = tokens[2];
+			} else if( tokens[1] == "HSSTRIPLET" ) {
 				// set string of hss triplets
-				hss_triplets_ = tokens[1];
+				hss_triplets_ = tokens[2];
 			}
 
-		} else if( tokens[0] == "INSERT" ) {
+		} else if( tokens[1] == "INSERT" ) {
 			// read the line of INSERT for reading insertion pdb file
-			insertion_.push_back( tokens[1] );
+			insertion_.push_back( tokens[2] );
 
 		} else {
 
@@ -281,17 +281,17 @@ BluePrint::read_blueprint( std::string c
 			runtime_assert( tokens.size() == 3 || tokens.size() == 4 || tokens.size() == 5 );
 
 			count ++;
-			Size ii = boost::lexical_cast<Size>( tokens[0] );
-			char aa ( tokens[1][0] );
-			char sec( tokens[2][0] );
+			Size ii = boost::lexical_cast<Size>( tokens[1] );
+			char aa ( tokens[2][0] );
+			char sec( tokens[3][0] );
 			String abego("");
-			if( tokens[2].length() > 1 ) {
+			if( tokens[3].length() > 1 ) {
 				core::util::ABEGOManager am;
 				// check characters of abego is appropriate or not
-				for( Size k=2; k<=tokens[2].length(); k++ ) {
-					am.symbol2index( tokens[2][k-1] );
+				for( Size k=2; k<=tokens[3].length(); k++ ) {
+					am.symbol2index( tokens[3][k-1] );
 				}
-				abego = tokens[2].substr( 1, tokens[2].length() - 1 );
+				abego = tokens[3].substr( 1, tokens[3].length() - 1 );
 			} else {
 				abego = "X";
 			}
@@ -312,7 +312,7 @@ BluePrint::read_blueprint( std::string c
 
 			if( tokens.size() >= 4 ) {
 
-				char build( tokens[3][0] );
+				char build( tokens[4][0] );
 				if( build != '.' && build != 'R' && build != 'I' && build != 'X' &&
 						build != 'F' && build != 'P' && build != 'C' ) {
 					TR.Error << "unrecognized build char : " << build << " at lines "	<< linecount << " in " << filename << std::endl;
@@ -325,7 +325,7 @@ BluePrint::read_blueprint( std::string c
 				buildtype_.push_back( build );
 
 				if( tokens.size() >= 5 ) {
-					String extra( tokens[4] );
+					String extra( tokens[5] );
 					extra_.push_back( extra );
 				} else {
 					extra_.push_back( "" );
@@ -336,28 +336,28 @@ BluePrint::read_blueprint( std::string c
 			} // tokens.size() >=4
 
 		}// tokens.size() == 2 || tokens.size() == 3
-  } // while ( getline )
+	} // while ( getline )
+
+	assert( resname_.size() == sstype_.size() );
+	total_residue_ = sstype_.size();
+	assert( total_residue_ > 0 );
 
-  assert( resname_.size() == sstype_.size() );
-  total_residue_ = sstype_.size();
-  assert( total_residue_ > 0 );
-
-  for( utility::vector1< char >::const_iterator iter = sstype_.begin(); iter != sstype_.end() ; ++iter) {
-    secstruct_ += *iter;
-  }
-  for( utility::vector1< char >::const_iterator iter = resname_.begin(); iter != resname_.end() ; ++iter) {
-    sequence_ += *iter;
-  }
+	for( utility::vector1< char >::const_iterator iter = sstype_.begin(); iter != sstype_.end() ; ++iter) {
+		secstruct_ += *iter;
+	}
+	for( utility::vector1< char >::const_iterator iter = resname_.begin(); iter != resname_.end() ; ++iter) {
+		sequence_ += *iter;
+	}
 
-  TR << secstruct_ << std::endl;
-  TR << sequence_ << std::endl;
+	TR << secstruct_ << std::endl;
+	TR << sequence_ << std::endl;
 
 	//ss_info_->initialize( secstruct_ );
 	//if( spairs.size() > 0 ){
 	//strand_pairings_ = set_strand_pairings( ss_info_, spairs );
 	//}
 
-  return true;
+	return true;
 
 } // read_blueprint
 
@@ -366,7 +366,7 @@ BluePrint::read_blueprint( std::string c
 void
 BluePrint::set_movemap( MoveMapOP & movemap )
 {
-  for ( Size i=1; i<=total_residue_ ; ++i )	{
+	for ( Size i=1; i<=total_residue_ ; ++i )	{
 		if ( buildtype( i ) == '.' ) {
 			movemap->set_bb( i, true );
 			movemap->set_chi( i, true );
diff -rupN vanilla/rosetta_source/src/protocols/jd2/parser/DataLoaderFactory.cc patched/rosetta_source/src/protocols/jd2/parser/DataLoaderFactory.cc
--- vanilla/rosetta_source/src/protocols/jd2/parser/DataLoaderFactory.cc	2012-03-21 09:05:59.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/parser/DataLoaderFactory.cc	2012-06-10 16:12:40.412040979 +0200
@@ -73,7 +73,7 @@ DataLoaderFactory::newDataLoader( std::s
 		}
 		return iter->second->create_loader();
 	} else {
-		utility_exit_with_message( loader_type + " is not known to the DataLoaderFactory. Was it registered via a DataLoaderRegistrator in one of the init.cc files (protocols/init/init.cc or protocols/init/init.cc)?" );
+		utility_exit_with_message( loader_type + " is not known to the DataLoaderFactory. Was it registered via a DataLoaderRegistrator in one of the init.cc files (devel/init.cc or protocols/init.cc)?" );
 		return NULL;
 	}
 
diff -rupN vanilla/rosetta_source/src/protocols/jd2/parser/FragmentReader.cc patched/rosetta_source/src/protocols/jd2/parser/FragmentReader.cc
--- vanilla/rosetta_source/src/protocols/jd2/parser/FragmentReader.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/parser/FragmentReader.cc	2012-06-10 16:12:40.414074537 +0200
@@ -114,6 +114,11 @@ FragmentReader::parse_tag( TagPtr const 
 		if( blueprint != "" ){
 			blueprint_ = new protocols::jd2::parser::BluePrint( blueprint );
 			ss_ = blueprint_->secstruct();
+			// pick fragment using sequence information (default false)
+			bool use_sequence_bias( tag->getOption<bool>( "use_sequence_bias", 0 ) );
+			if( use_sequence_bias ) {
+				aa_ = blueprint_->sequence();
+			}
 		}
 
 		// using abego definition which is given by blueprint file
diff -rupN vanilla/rosetta_source/src/protocols/jd2/parser/LoopsDefinerLoader.cc patched/rosetta_source/src/protocols/jd2/parser/LoopsDefinerLoader.cc
--- vanilla/rosetta_source/src/protocols/jd2/parser/LoopsDefinerLoader.cc	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/parser/LoopsDefinerLoader.cc	2012-06-10 16:12:40.417039883 +0200
@@ -0,0 +1,91 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   protocols/jd2/parser/LoopsDefinerLoader.cc
+/// @brief  Implementation the LoopsDefinerLoader class which implements the DataLoader interface
+/// @author Matthew O'Meara (mattjomeara@gmail.com)
+
+// Unit Headers
+#include <protocols/jd2/parser/LoopsDefinerLoader.hh>
+#include <protocols/jd2/parser/StandardLoaderCreators.hh>
+
+// Project Headers
+#include <protocols/loops/loops_definers/LoopsDefiner.hh>
+#include <protocols/loops/loops_definers/LoopsDefinerFactory.hh>
+#include <basic/Tracer.hh>
+#include <core/pose/Pose.hh>
+#include <protocols/moves/DataMap.hh>
+
+
+// Utility headers
+#include <utility/tag/Tag.hh>
+
+// Boost Headers
+#include <boost/foreach.hpp>
+
+#include <utility/vector0.hh>
+#include <utility/vector1.hh>
+
+#define foreach BOOST_FOREACH
+
+using std::string;
+using std::endl;
+using core::pose::Pose;
+using utility::tag::TagPtr;
+using protocols::moves::DataMap;
+using utility::vector0;
+using protocols::loops::loops_definers::LoopsDefinerOP;
+using protocols::loops::loops_definers::LoopsDefinerFactory;
+
+namespace protocols {
+namespace jd2 {
+namespace parser {
+
+static basic::Tracer TR( "protocols.jd2.parser.LoopsDefinerLoader" );
+
+LoopsDefinerLoader::LoopsDefinerLoader() {}
+LoopsDefinerLoader::~LoopsDefinerLoader() {}
+
+void LoopsDefinerLoader::load_data(
+	Pose const & pose,
+	TagPtr const tag,
+	DataMap & data
+) const
+{
+	typedef vector0< TagPtr > TagPtrs;
+
+	foreach(TagPtr tag, tag->getTags()){
+		string const type( tag->getName() );
+		if ( ! tag->hasOption("name") ) {
+			utility_exit_with_message( "Can't create unnamed Loops definition (type: " + type + ")" );
+		}
+		string const name( tag->getOption<string>("name") );
+		if ( data.has( "loops_definers", name ) ) {
+			TR.Error << "Error LoopsDefiner of name \"" << name
+				<< "\" (with type " << type << ") already exists. \n" << tag << endl;
+			utility_exit_with_message("Duplicate definition of LoopsDefiner with name " + name);
+		}
+		LoopsDefinerOP loops_definer( LoopsDefinerFactory::get_instance()->create_loops_definer( type ) );
+		loops_definer->parse_my_tag(tag, data, pose);
+		data.add("loops_definers", name, loops_definer );
+		TR << "Created LoopsDefiner named \"" << name << "\" of type " << type << endl;
+	}
+	TR.flush();
+}
+
+DataLoaderOP
+LoopsDefinerLoaderCreator::create_loader() const { return new LoopsDefinerLoader; }
+
+string
+LoopsDefinerLoaderCreator::keyname() const { return "LOOP_DEFINITIONS"; }
+
+
+} //namespace parser
+} //namespace jd2
+} //namespace protocols
diff -rupN vanilla/rosetta_source/src/protocols/jd2/parser/LoopsDefinerLoader.hh patched/rosetta_source/src/protocols/jd2/parser/LoopsDefinerLoader.hh
--- vanilla/rosetta_source/src/protocols/jd2/parser/LoopsDefinerLoader.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/parser/LoopsDefinerLoader.hh	2012-06-10 16:12:40.420040167 +0200
@@ -0,0 +1,48 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   protocols/jd2/parser/LoopsDefinerLoader.hh
+/// @brief  Declartion of the XML parser's LoopsDefinerLoader class
+/// @author Matthew O'Meara (mattjomeara@gmail.com)
+
+#ifndef INCLUDED_protocols_jd2_parser_LoopsDefinerLoader_hh
+#define INCLUDED_protocols_jd2_parser_LoopsDefinerLoader_hh
+
+// Package Headers
+#include <protocols/jd2/parser/DataLoader.hh>
+
+#include <utility/vector1.hh>
+
+
+namespace protocols {
+namespace jd2 {
+namespace parser {
+
+/// @brief A class for loading Loops data into the XML parser's DataMap.
+class LoopsDefinerLoader : public DataLoader
+{
+public:
+	LoopsDefinerLoader();
+	virtual ~LoopsDefinerLoader();
+
+	/// @brief The LoopsDefinerLoader will load named task operations into the DataMap
+	virtual
+	void load_data(
+		core::pose::Pose const & pose,
+		utility::tag::TagPtr const tag,
+		moves::DataMap & data
+	) const;
+
+};
+
+} //namespace parser
+} //namespace jd2
+} //namespace protocols
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/jd2/parser/ScoreFunctionLoader.cc patched/rosetta_source/src/protocols/jd2/parser/ScoreFunctionLoader.cc
--- vanilla/rosetta_source/src/protocols/jd2/parser/ScoreFunctionLoader.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/parser/ScoreFunctionLoader.cc	2012-06-10 16:12:40.423041083 +0200
@@ -17,8 +17,9 @@
 
 // Project Headers
 #include <core/scoring/ScoreFunction.hh>
+#include <core/scoring/ScoringManager.fwd.hh>
 #include <core/scoring/ScoreFunctionFactory.hh>
-#include <core/scoring/symmetry/SymmetricScoreFunction.hh> 
+#include <core/scoring/symmetry/SymmetricScoreFunction.hh>
 #include <core/scoring/methods/EnergyMethodOptions.hh>
 #include <core/scoring/hbonds/HBondOptions.hh>
 #include <basic/Tracer.hh>
@@ -90,6 +91,25 @@ void ScoreFunctionLoader::load_data(
 				core::scoring::methods::EnergyMethodOptions emoptions( in_scorefxn->energy_method_options() );
 				core::scoring::hbonds::HBondOptionsOP hboptions( emoptions.hbond_options() );
 
+				if( mod_tag->hasOption( "softrep_etable" )) {
+					if ( mod_tag->getOption<bool>( "softrep_etable" )) {
+						emoptions.etable_type( core::scoring::FA_STANDARD_SOFT );
+
+					}
+				}
+
+				if( mod_tag->hasOption( "hack_elec_min_dis" )) {
+					emoptions.hackelec_min_dis( mod_tag->getOption<core::Real>( "hack_elec_min_dis" ) );
+				}
+				if( mod_tag->hasOption( "hack_elec_max_dis" )) {
+					emoptions.hackelec_max_dis( mod_tag->getOption<core::Real>( "hack_elec_max_dis" ) );
+				}
+				if( mod_tag->hasOption( "hack_elec_dielectric" )) {
+					emoptions.hackelec_die( mod_tag->getOption<core::Real>( "hack_elec_dielectric" ) );
+				}
+				if( mod_tag->hasOption( "hack_elec_no_dis_dep_die" )) {
+					emoptions.hackelec_no_dis_dep_die( mod_tag->getOption<bool>( "hack_elec_no_dis_dep_die" ) );
+				}
 				if( mod_tag->hasOption( "exclude_protein_protein_hack_elec" )) {
 					emoptions.exclude_protein_protein_hack_elec( mod_tag->getOption<bool>( "exclude_protein_protein_hack_elec" ) );
 				}
@@ -127,11 +147,11 @@ void ScoreFunctionLoader::load_data(
 		}
 
 		//fpd should we symmetrize scorefunction?
-		bool const scorefxn_symm( scorefxn_tag->getOption<bool>( "symmetric", 0 ) ); 
-		if (scorefxn_symm) { 
-			in_scorefxn = ScoreFunctionOP( new SymmetricScoreFunction( in_scorefxn ) ); 
+		bool const scorefxn_symm( scorefxn_tag->getOption<bool>( "symmetric", 0 ) );
+		if (scorefxn_symm) {
+			in_scorefxn = ScoreFunctionOP( new SymmetricScoreFunction( in_scorefxn ) );
 			TR<<"symmetrizing "<<scorefxn_name<<'\n';
-		} 
+		}
 
 		data.add( "scorefxns" , scorefxn_name, in_scorefxn );
 	}//end user-defined scorefxns
diff -rupN vanilla/rosetta_source/src/protocols/jd2/PDBJobOutputter.cc patched/rosetta_source/src/protocols/jd2/PDBJobOutputter.cc
--- vanilla/rosetta_source/src/protocols/jd2/PDBJobOutputter.cc	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/PDBJobOutputter.cc	2012-06-10 16:12:40.425040747 +0200
@@ -101,8 +101,8 @@ void protocols::jd2::PDBJobOutputter::ot
 	JobCOP job,
 	core::pose::Pose const & pose,
 	std::string const & tag,
-	int copy_count, /*default -1 */
-	bool score_only /*default false*/
+	int /*copy_count*/, /*default -1 */
+	bool /* score_only*/ /*default false*/
 ){
 	TR.Debug << "PDBJobOutputter::other_pose" << std::endl;
 	runtime_assert( !tag.empty() ); //else you'll overwrite your pdb when the job finishes
diff -rupN vanilla/rosetta_source/src/protocols/jd2/ScoreOnlyJobOutputter.cc patched/rosetta_source/src/protocols/jd2/ScoreOnlyJobOutputter.cc
--- vanilla/rosetta_source/src/protocols/jd2/ScoreOnlyJobOutputter.cc	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/ScoreOnlyJobOutputter.cc	2012-06-10 16:12:40.428040064 +0200
@@ -46,8 +46,8 @@ void ScoreOnlyJobOutputter::other_pose(
   JobCOP job,
 	core::pose::Pose const & pose,
 	std::string const & tag,
-	int copy_count, /*default -1 */
-	bool score_only /*default false*/
+	int /*copy_count*/, /*default -1 */
+	bool /*score_only*/ /*default false*/
 ) {
 	if( basic::options::option[ basic::options::OptionKeys::run::other_pose_to_scorefile ].value() )
 	{
diff -rupN vanilla/rosetta_source/src/protocols/jd2/SilentFileJobInputter.cc patched/rosetta_source/src/protocols/jd2/SilentFileJobInputter.cc
--- vanilla/rosetta_source/src/protocols/jd2/SilentFileJobInputter.cc	2012-03-20 19:43:07.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/SilentFileJobInputter.cc	2012-06-10 16:12:40.431040984 +0200
@@ -30,6 +30,9 @@
 ///C++ headers
 #include <string>
 
+// External headers
+#include <boost/algorithm/string/predicate.hpp>
+
 // option key includes
 #include <basic/options/keys/in.OptionKeys.gen.hh>
 #include <core/pose/symmetry/util.hh>
@@ -156,7 +159,19 @@ void protocols::jd2::SilentFileJobInputt
 	for ( SilentFileData::iterator iter = sfd_.begin(), end = sfd_.end();
 			iter != end; ++iter
 	) {
-		InnerJobOP ijob( new InnerJob( iter->decoy_tag(), nstruct ) );
+		const std::string tag = iter->decoy_tag();
+
+		// Optionally ignore failed simulations. Supporting protocols are not consistent
+		// in their support of this option. Abrelax, for example, writes models from
+		// failed simulations in centroid residue type set, despite the fact that
+		// fullatom was requested. This can lead to issues during clustering, rescoring,
+		// etc.
+		bool failed_simulation = boost::starts_with(tag, "W_");
+		if (failed_simulation && option[OptionKeys::in::file::skip_failed_simulations]()) {
+			continue;
+		}
+
+		InnerJobOP ijob( new InnerJob( tag, nstruct ) );
 		inner_jobs.push_back( ijob );
 	}
 
diff -rupN vanilla/rosetta_source/src/protocols/jd2/SingleFileBuffer.cc patched/rosetta_source/src/protocols/jd2/SingleFileBuffer.cc
--- vanilla/rosetta_source/src/protocols/jd2/SingleFileBuffer.cc	2012-03-20 19:43:06.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/SingleFileBuffer.cc	2012-06-10 16:12:40.433040152 +0200
@@ -63,9 +63,9 @@ Size SingleFileBuffer::nr_open_slaves() 
 
 void SingleFileBuffer::close( Size slave ) {
 	if ( unfinished_blocks_[ slave ].size() == 0 ) {
-		tr.Info << "EMPTY OPEN/CLOSE Operation from slave " << slave << std::endl;
+		tr.Trace << "EMPTY OPEN/CLOSE Operation from slave " << slave << std::endl;
 	}
-	tr.Info << "close " << filename_ << " from slave " << slave << std::endl;
+	tr.Debug << "close " << filename_ << " from slave " << slave << std::endl;
 	flush( slave );
 	//BufferMap::iterator iter = unfinished_blocks_.find( slave );
 	//	if ( iter!=unfinished_blocks_.end() ) {
@@ -123,19 +123,19 @@ WriteFileSFB::WriteFileSFB( std::string 
 		if ( append ) {
 			if ( !utility::file::file_exists( filename ) ) {
 				//			out_.open( filename.c_str() );
-				tr.Info << "open file " << filename << " ... " << std::endl;
+				tr.Debug << "open file " << filename << " ... " << std::endl;
 				out_.open( filename.c_str() );
 				if ( out_.good() ) status = MPI_SUCCESS_NEW;
 			} else {
 
-				tr.Info << "open file (append) " << filename << " ... " << std::endl;
+				tr.Debug << "open file (append) " << filename << " ... " << std::endl;
 				//			out_.open_append( filename.c_str() );
 				out_.open( filename.c_str(), std::ios::app );
 				if ( out_.good() ) status = MPI_SUCCESS_APPEND;
 			}
 		}	else {
 			//		out_.open( filename.c_str() );
-			tr.Info << "open file " << filename << " ... " << std::endl;
+			tr.Debug << "open file " << filename << " ... " << std::endl;
 			out_.open( filename.c_str() );
 			if ( out_.good() ) status = MPI_SUCCESS_NEW;
 		}
@@ -152,7 +152,7 @@ WriteFileSFB::WriteFileSFB( std::string 
 }
 
 WriteFileSFB::~WriteFileSFB() {
-	tr.Info << "close file " << filename() << std::endl;
+	tr.Debug << "close file " << filename() << std::endl;
 	out_.close();
 }
 
@@ -161,8 +161,8 @@ void WriteFileSFB::write_lines( LineBuff
 	static time_t ntime;
 	static time_t last_time;
 	ntime = clock();
-	if ( buf.size()==1 ) tr.Info << -1.0*(all_start_time-ntime)/CLOCKS_PER_SEC << " " << 1.0*( ntime-last_time )/CLOCKS_PER_SEC << " seconds: write block of " << buf.begin()->size() << " characters to file " << filename() << std::endl;
-	else tr.Info << -1.0*(all_start_time-ntime)/CLOCKS_PER_SEC << " " <<1.0*( ntime-last_time )/CLOCKS_PER_SEC << " seconds: write " << buf.size() << " blocks of data to file " << filename() << std::endl;
+	if ( buf.size()==1 ) tr.Debug << -1.0*(all_start_time-ntime)/CLOCKS_PER_SEC << " " << 1.0*( ntime-last_time )/CLOCKS_PER_SEC << " seconds: write block of " << buf.begin()->size() << " characters to file " << filename() << std::endl;
+	else tr.Debug << -1.0*(all_start_time-ntime)/CLOCKS_PER_SEC << " " <<1.0*( ntime-last_time )/CLOCKS_PER_SEC << " seconds: write " << buf.size() << " blocks of data to file " << filename() << std::endl;
 	last_time = ntime;
 
 	copy( buf.begin(), buf.end(), std::ostream_iterator< std::string>( out_ ) );
@@ -177,7 +177,7 @@ void WriteFileSFB::block( core::Size sla
 	tr.Debug << "block file " << filename() << std::endl;
 	//out_.flush();
 	Base::block(slave);
-	tr.Info << "open file (append): " << filename() << std::endl;
+	tr.Debug << "open file (append): " << filename() << std::endl;
 	out_.open( filename().c_str() , std::ios::app );
 }
 
diff -rupN vanilla/rosetta_source/src/protocols/jd2/#svn-commit.tmp# patched/rosetta_source/src/protocols/jd2/#svn-commit.tmp#
--- vanilla/rosetta_source/src/protocols/jd2/#svn-commit.tmp#	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/jd2/#svn-commit.tmp#	2012-06-10 16:12:40.436040197 +0200
@@ -0,0 +1,6 @@
+:q
+--This line, and those below, will be ignored--
+
+M    SingleFileBuffer.cc
+M    MpiFileBuffer.cc
+M    util.cc
diff -rupN vanilla/rosetta_source/src/protocols/jumping/JumpSetup.hh patched/rosetta_source/src/protocols/jumping/JumpSetup.hh
--- vanilla/rosetta_source/src/protocols/jumping/JumpSetup.hh	2012-03-20 19:43:13.000000000 +0100
+++ patched/rosetta_source/src/protocols/jumping/JumpSetup.hh	2012-06-10 16:12:40.542039815 +0200
@@ -96,6 +96,9 @@ public:
 	///@brief take from a given JumpSample only those Jumps, which could also have been created by create_jump_sample()
 	virtual
 	JumpSample clean_jumps( JumpSample const& ) const = 0;
+
+	virtual std::string type_name() const = 0;
+
 };
 
 
@@ -114,7 +117,9 @@ public:
 		Interval cut_reg_;
 	};
 
-
+	std::string type_name() const {
+		return "JumpSetup";
+	}
 public:
 
 	typedef utility::vector1< JumpDef >::const_iterator const_iterator;
@@ -244,6 +249,10 @@ public:
 		core::Real weight_;
 	};
 
+	std::string type_name() const {
+		return "JumpSelector";
+	}
+
 public:
 	typedef utility::vector1< JumpWeightDef > JumpList;
 	typedef JumpList::const_iterator const_iterator;
diff -rupN vanilla/rosetta_source/src/protocols/jumping/RandomSheetBuilder.hh patched/rosetta_source/src/protocols/jumping/RandomSheetBuilder.hh
--- vanilla/rosetta_source/src/protocols/jumping/RandomSheetBuilder.hh	2012-03-20 19:43:13.000000000 +0100
+++ patched/rosetta_source/src/protocols/jumping/RandomSheetBuilder.hh	2012-06-10 16:12:40.545040753 +0200
@@ -61,7 +61,9 @@ public:
 protected:
 	//default do nothing always use input_sheet_sizes_ as sheet_sizes_.
 	virtual SheetTopology create_new_random_topol() const;
-
+	std::string type_name() const {
+		return "RandomSheetBuilder";
+	}
 private:
   SheetTopology input_sheet_sizes_;
 
diff -rupN vanilla/rosetta_source/src/protocols/jumping/ResiduePairJumpSetup.hh patched/rosetta_source/src/protocols/jumping/ResiduePairJumpSetup.hh
--- vanilla/rosetta_source/src/protocols/jumping/ResiduePairJumpSetup.hh	2012-03-20 19:43:12.000000000 +0100
+++ patched/rosetta_source/src/protocols/jumping/ResiduePairJumpSetup.hh	2012-06-10 16:12:40.548040986 +0200
@@ -56,6 +56,9 @@ public:
 		Interval cut_reg_;
 	};
 
+	std::string type_name() const {
+		return "ResiduePairJumpSetup";
+	}
 
 public:
 
diff -rupN vanilla/rosetta_source/src/protocols/jumping/SheetBuilder.hh patched/rosetta_source/src/protocols/jumping/SheetBuilder.hh
--- vanilla/rosetta_source/src/protocols/jumping/SheetBuilder.hh	2012-03-20 19:43:13.000000000 +0100
+++ patched/rosetta_source/src/protocols/jumping/SheetBuilder.hh	2012-06-10 16:12:40.550040856 +0200
@@ -67,6 +67,10 @@ public:
 	//d'stor
 	virtual ~SheetBuilder();
 
+	std::string type_name() const {
+		return "SheetBuilder";
+	}
+
 	virtual
 	JumpSample
 	create_jump_sample() const;
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/Assignment.hh patched/rosetta_source/src/protocols/noesy_assign/Assignment.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/Assignment.hh	2012-03-20 19:43:19.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/Assignment.hh	2012-06-10 16:12:40.277041059 +0200
@@ -110,3 +110,5 @@ private:
 };
 
 extern PeakAssignment const BOGUS_ASSIGNMENT;
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeak.cc patched/rosetta_source/src/protocols/noesy_assign/CrossPeak.cc
--- vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeak.cc	2012-03-20 19:43:19.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/CrossPeak.cc	2012-06-10 16:12:40.280064541 +0200
@@ -155,7 +155,7 @@ void CrossPeak::assign_spin( Size iproto
   Real const my_freq( proton( iproton ).freq() );
   Real const my_tolerance( info_struct( iproton ).proton_tolerance() );
   for ( ResonanceList::const_iterator it = resonances().begin(); it != resonances().end(); ++it )  {
-    if ( std::abs( it->second.freq() - my_freq ) < std::max( my_tolerance, it->second.error() ) ) {
+    if ( std::abs( fold_resonance( it->second.freq(), iproton ) - my_freq ) < std::max( my_tolerance, it->second.error() ) ) {
       proton( iproton ).add_assignment( it->first );
     }
   }
@@ -185,7 +185,7 @@ CrossPeak::create_fa_and_cen_constraint(
 	FuncOP func( new BoundFunc(1.5,
 				distance_bound(),
 				weight,
-				"automatic NOE Peak "+ObjexxFCL::string_of( peak_id() )+" "+filename()
+			  "automatic NOE Peak "+ObjexxFCL::string_of( peak_id() )+" "+filename()+" Volume: "+ObjexxFCL::string_of( volume() )
 			)
 		);
 
@@ -443,7 +443,7 @@ void CrossPeak3D::assign_labelled_spin( 
 	/// if we have pseudo 4D spectrum we speed things up a bit by filtering out non-protons here
 	if ( my_tolerance > 99 ) {
 		for ( ResonanceList::const_iterator it = resonances().begin(); it != resonances().end(); ++it )  {
-			if ( std::abs( it->second.freq() - my_label_freq ) < std::max( my_label_tolerance, it->second.error() ) ) {
+			if ( std::abs( fold_resonance( it->second.freq(), iproton + 2 ) - my_label_freq ) < std::max( my_label_tolerance, it->second.error() ) ) {
 				//now find all proton-resonances that are bound to this label atom
 				core::Size resid( it->second.resid() );
 				std::string const& label_name( it->second.name() );
@@ -473,13 +473,13 @@ void CrossPeak3D::assign_labelled_spin( 
 			/// if we have pseudo 4D spectrum we speed things up a bit by filtering out non-protons here
 			//			if ( my_tolerance > 99 && ( it->second.freq() > 13.0 && info_struct( iproton ).main_atom() == "H" ) ) continue;
 
-			if ( std::abs( it->second.freq() - my_freq ) < std::max( my_tolerance, it->second.tolerance() ) ) {
+			if ( std::abs( fold_resonance( it->second.freq(), iproton ) - my_freq ) < std::max( my_tolerance, it->second.tolerance() ) ) {
 				Size resid( it->second.atom().rsd() );
 				//maybe also map resonance by resid?
 				try {
 					id::NamedAtomID atomID( info_struct( iproton ).label_atom_name( it->second.atom().atom(), resonances().aa_from_resid( resid ) ), resid );
 					Resonance const& label_reso ( resonances()[ atomID ] );
-					if ( std::abs( label_reso.freq() - my_label_freq ) < my_label_tolerance ) {
+					if ( std::abs( fold_resonance( label_reso.freq(), iproton+2 ) - my_label_freq ) < my_label_tolerance ) {
 						proton( iproton ).add_assignment( it->first );
 						label( iproton ).add_assignment( label_reso.label() );
 					}
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeak.hh patched/rosetta_source/src/protocols/noesy_assign/CrossPeak.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeak.hh	2012-03-20 19:43:19.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/CrossPeak.hh	2012-06-10 16:12:40.283039692 +0200
@@ -118,6 +118,23 @@ public:
   ///@brief expect res_ids in order: spin1, spin2, label1, label2
   virtual void add_full_assignment( core::Size res_ids[] );
 
+  core::Real fold_resonance( core::Real freq, core::Size i /*dim*/ ) {
+    // dim = 1, 2 are the protons
+    // dim = 3, 4 are the labels
+
+    /// for now only labels can be folded
+    if ( i==1 ) {
+      return info1_->fold_proton_resonance()( freq );
+    } else if ( i==2 ) {
+      return info2_->fold_proton_resonance()( freq );
+    } else if ( i==3 ) {
+      return info1_->fold_label_resonance()( freq );
+    } else if ( i==4 ) {
+      return info2_->fold_label_resonance()( freq );
+    };
+    runtime_assert( false ); //should never get here...
+    return 0.0; //to make compiler happy
+  }
 //  virtual void read_from_stream( std::istream& );
 //   virtual void add_assignment_from_stream( std::istream& );
 //   virtual void write_to_stream( std::ostream& ) const;
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeakInfo.cc patched/rosetta_source/src/protocols/noesy_assign/CrossPeakInfo.cc
--- vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeakInfo.cc	2012-03-20 19:43:19.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/CrossPeakInfo.cc	2012-06-10 16:12:40.285040726 +0200
@@ -65,6 +65,10 @@ void CrossPeakInfo::show( std::ostream& 
 		 << proton_atom_name_ << " " << label_atom_type_ << " "
 		 << "TOL: " << proton_tolerance_ << " " << label_tolerance_
 		 << " from file " << filename_;
+	os << "PROTON: ";
+	fold_proton_resonance_.show( os );
+	os << "LABEL: ";
+	fold_label_resonance_.show( os );
 }
 
 std::ostream& operator<< ( std::ostream& os, CrossPeakInfo const& cpi ) {
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeakInfo.hh patched/rosetta_source/src/protocols/noesy_assign/CrossPeakInfo.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeakInfo.hh	2012-03-20 19:43:19.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/CrossPeakInfo.hh	2012-06-10 16:12:40.288040295 +0200
@@ -1,3 +1,5 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
 // (c) This file is part of the Rosetta software suite and is made available under license.
 // (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
 // (c) For more information, see http://www.rosettacommons.org. Questions about this can be
@@ -14,7 +16,7 @@
 #include <protocols/noesy_assign/CrossPeakInfo.fwd.hh>
 
 // Package Headers
-// AUTO-REMOVED #include <protocols/noesy_assign/ResonanceList.fwd.hh>
+#include <protocols/noesy_assign/FoldResonance.hh>
 
 // Project Headers
 #include <core/types.hh>
@@ -89,12 +91,25 @@ public:
 
   void show( std::ostream& ) const;
 
+  FoldResonance const& fold_label_resonance() const { return fold_label_resonance_; }
+  FoldResonance const& fold_proton_resonance() const { return fold_proton_resonance_; }
+
+  void set_folding_window( core::Real start, core::Real end, bool label=true ) {
+    if ( label ) {
+      fold_label_resonance_.set_window( start, end );
+    } else {
+      fold_proton_resonance_.set_window( start, end );
+    }
+  }
+
 private:
   std::string proton_atom_name_;
   std::string label_atom_type_;
   core::Real proton_tolerance_;
   core::Real label_tolerance_;
   std::string filename_;
+  FoldResonance fold_label_resonance_;
+  FoldResonance fold_proton_resonance_; //this is probably nonsense but for completeness...
 };
 
 std::ostream& operator<< ( std::ostream&, CrossPeakInfo const& );
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeakList.hh patched/rosetta_source/src/protocols/noesy_assign/CrossPeakList.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/CrossPeakList.hh	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/CrossPeakList.hh	2012-06-10 16:12:40.290074367 +0200
@@ -18,8 +18,8 @@
 #include <protocols/noesy_assign/PeakFileFormat.fwd.hh>
 #include <protocols/noesy_assign/PeakAssignmentResidueMap.fwd.hh>
 #include <protocols/noesy_assign/PeakCalibrator.fwd.hh>
-//#include <protocols/noesy_assign/PeakAssignment.hh>
-//#include <protocols/noesy_assign/ResonanceList.fwd.hh>
+//#include <devel/noesy_assign/PeakAssignment.hh>
+//#include <devel/noesy_assign/ResonanceList.fwd.hh>
 
 // Project Headers
 #include <core/types.hh>
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/CyanaModule.hh patched/rosetta_source/src/protocols/noesy_assign/CyanaModule.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/CyanaModule.hh	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/CyanaModule.hh	2012-06-10 16:12:40.293039765 +0200
@@ -17,7 +17,7 @@
 #include <protocols/noesy_assign/CrossPeak.hh>
 #include <protocols/noesy_assign/PeakFileFormat.fwd.hh>
 #include <protocols/noesy_assign/PeakAssignmentList.hh>
-//#include <protocols/NoesyAssign/ResonanceList.fwd.hh>
+//#include <devel/NoesyAssign/ResonanceList.fwd.hh>
 
 // Project Headers
 #include <core/types.hh>
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/Exceptions.hh patched/rosetta_source/src/protocols/noesy_assign/Exceptions.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/Exceptions.hh	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/Exceptions.hh	2012-06-10 16:12:40.296039945 +0200
@@ -18,7 +18,7 @@
 
 
 // Unit Headers
-//#include <protocols/topology_broker/Exceptions.fwd.hh>
+//#include <devel/topology_broker/Exceptions.fwd.hh>
 
 // Utility Headers
 #include <core/id/NamedAtomID.hh>
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/FoldPeak.hh patched/rosetta_source/src/protocols/noesy_assign/FoldPeak.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/FoldPeak.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/FoldPeak.hh	2012-06-10 16:12:40.298074642 +0200
@@ -0,0 +1,61 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file CrossPeakList.hh
+/// @author Oliver Lange
+
+#ifndef INCLUDED_protocols_noesy_assign_UnfoldPeak_hh
+#define INCLUDED_protocols_noesy_assign_UnfoldPeak_hh
+
+
+// Unit Headers
+#include <protocols/noesy_assign/UnfoldPeak.fwd.hh>
+
+// Package Headers
+
+// Project Headers
+#include <core/types.hh>
+
+// Utility headers
+
+// C++ headers
+#include <string>
+
+namespace protocols {
+namespace noesy_assign {
+
+class FoldResonance {
+  UnfoldPeak( core::Real start, core::Real end ) : start_( start ), window_( end-start ) {}
+
+  bool is_folded_down( core::Real freq ) {
+    return window_ > 0.1 && freq < start();
+  }
+
+  bool is_folded_up( core::Real freq ) {
+    return window_ > 0.1 && freq > end();
+  }
+
+  bool is_folded( core::Real freq ) {
+    return is_folded_down(freq) || is_folded_up( freq );
+  }
+
+  core::Real start() { return start_; }
+  core::Real end() { return start_+window_; }
+
+  core::Real operator() ( core::Real freq ) {
+    while( is_folded_down( freq ) ) { freq+=window_; }
+    while( is_folded_up( freq ) ) { freq-=window_; }
+    assert( !is_folded( freq ) );
+    return freq;
+  }
+
+private:
+  core::Real start_;
+  core::Real window_;
+}
+
+}
+}
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/FoldResonance.hh patched/rosetta_source/src/protocols/noesy_assign/FoldResonance.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/FoldResonance.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/FoldResonance.hh	2012-06-10 16:12:40.301040699 +0200
@@ -0,0 +1,84 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file CrossPeakList.hh
+/// @author Oliver Lange
+
+#ifndef INCLUDED_protocols_noesy_assign_FoldResonance_hh
+#define INCLUDED_protocols_noesy_assign_FoldResonance_hh
+
+
+// Unit Headers
+//#include <protocols/noesy_assign/FoldResonance.fwd.hh>
+
+// Package Headers
+
+// Project Headers
+#include <core/types.hh>
+
+// Utility headers
+#include <assert.h>
+
+// C++ headers
+#include <string>
+#include <iostream>
+
+namespace protocols {
+namespace noesy_assign {
+
+class FoldResonance {
+public:
+  FoldResonance() : start_( 0 ), window_( 0 ) {}
+
+  void set_window( core::Real start, core::Real end ) {
+    start_ = start;
+    window_ = end-start;
+  }
+
+  bool is_folded_down( core::Real freq ) const {
+    return window_ > 0.1 && freq < start();
+  }
+
+  bool is_folded_up( core::Real freq ) const {
+    return window_ > 0.1 && freq > end();
+  }
+
+  bool is_folded( core::Real freq ) const {
+    return is_folded_down(freq) || is_folded_up( freq );
+  }
+
+  core::Real start() const { return start_; }
+  core::Real end() const { return start_+window_; }
+
+  core::Real operator() ( core::Real freq ) const {
+		if ( !is_folded( freq ) ) return freq;
+    while( is_folded_down( freq ) ) { freq+=window_; }
+    while( is_folded_up( freq ) ) { freq-=window_; }
+    assert( !is_folded( freq ) );
+    return freq;
+  }
+
+	bool is_folded() const {
+		return window_ > 0.1;
+	}
+
+	void show( std::ostream& os ) const {
+		if ( is_folded() ) {
+			os << "FOLDED with " << window_ << " " << start() << " " << end() << std::endl;
+		} else {
+			os << "UNFOLDED" << std::endl;
+		}
+	}
+
+private:
+  core::Real start_;
+  core::Real window_;
+};
+
+}
+}
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/NoesyModule.cc patched/rosetta_source/src/protocols/noesy_assign/NoesyModule.cc
--- vanilla/rosetta_source/src/protocols/noesy_assign/NoesyModule.cc	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/NoesyModule.cc	2012-06-10 16:12:40.304039706 +0200
@@ -27,7 +27,7 @@
 #include <protocols/noesy_assign/PeakAssignmentParameters.hh>
 #include <protocols/noesy_assign/PeakAssignmentResidueMap.hh>
 #include <protocols/noesy_assign/PeakFileFormat_Sparky.hh>
-//#include <protocols/noesy_assign/DistanceScoreMover.hh>
+//#include <devel/noesy_assign/DistanceScoreMover.hh>
 
 // Project Headers
 #include <core/scoring/constraints/ConstraintSet.hh>
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/NoesyModule.hh patched/rosetta_source/src/protocols/noesy_assign/NoesyModule.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/NoesyModule.hh	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/NoesyModule.hh	2012-06-10 16:12:40.306074727 +0200
@@ -23,7 +23,7 @@
 // AUTO-REMOVED #include <protocols/noesy_assign/PeakFileFormat.fwd.hh>
 // AUTO-REMOVED #include <protocols/noesy_assign/PeakAssignmentResidueMap.hh>
 // AUTO-REMOVED #include <protocols/noesy_assign/PeakAssignmentParameters.hh>
-//#include <protocols/noesy_assign/ResonanceList.fwd.hh>
+//#include <devel/noesy_assign/ResonanceList.fwd.hh>
 
 // Project Headers
 #include <core/types.hh>
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/PeakAssignment.cc patched/rosetta_source/src/protocols/noesy_assign/PeakAssignment.cc
--- vanilla/rosetta_source/src/protocols/noesy_assign/PeakAssignment.cc	2012-03-20 19:43:19.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/PeakAssignment.cc	2012-06-10 16:12:40.309040952 +0200
@@ -108,7 +108,7 @@ void PeakAssignment::update_chemshiftsco
 	for ( Size d=1; d<=crosspeak_->dimension(); d++ ) {
 		CrossPeak::Spin const& spin( crosspeak_->spin( d ) );
 		Resonance const& assigned_resonance( resonances()[ spin.assignment( spin_id( d>2 ? d-2 : d ) ) ] );
-		Real diff( spin.freq()-assigned_resonance.freq() );
+		Real diff( spin.freq()-crosspeak_->fold_resonance( assigned_resonance.freq(), d ) );
 		Real s( diff/weight/std::max( crosspeak_->tolerance( d ), assigned_resonance.tolerance() ) );
 		sum += s*s;
 	}
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/PeakAssignmentParameters.cc patched/rosetta_source/src/protocols/noesy_assign/PeakAssignmentParameters.cc
--- vanilla/rosetta_source/src/protocols/noesy_assign/PeakAssignmentParameters.cc	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/PeakAssignmentParameters.cc	2012-06-10 16:12:40.312039955 +0200
@@ -19,7 +19,7 @@
 #include <protocols/noesy_assign/PeakAssignmentParameters.hh>
 
 // Package Headers
-//#include <protocols/noesy_assign/Exceptions.hh>
+//#include <devel/noesy_assign/Exceptions.hh>
 
 // Project Headers
 
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/PeakCalibrator.cc patched/rosetta_source/src/protocols/noesy_assign/PeakCalibrator.cc
--- vanilla/rosetta_source/src/protocols/noesy_assign/PeakCalibrator.cc	2012-03-20 19:43:19.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/PeakCalibrator.cc	2012-06-10 16:12:40.315040815 +0200
@@ -171,7 +171,7 @@ void PeakCalibrator::do_calibration() {
   while ( !finished && max_cycles ) {
     --max_cycles;
 		reset_statistics();
-		set_new_upper_bounds();
+		set_new_upper_bounds(); //compute statistics about upper bounds
 		//		show_statistics( tr.Info );
 		tr.Info << accumulated_target_[ BACKBONE ]/accumulated_count_[ BACKBONE ] << " " << target_;
 		tr.Info << " " << calibration_constant_[ BACKBONE ] << " " << calibration_constant_[ SIDECHAIN ] << " " << calibration_constant_[ METHYL ] << std::endl;
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/PeakCalibrator.hh patched/rosetta_source/src/protocols/noesy_assign/PeakCalibrator.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/PeakCalibrator.hh	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/PeakCalibrator.hh	2012-06-10 16:12:40.317041786 +0200
@@ -11,12 +11,12 @@
 
 
 // Unit Header
-//#include <protocols/NoesyAssign/PeakCalibrator.fwd.hh>
+//#include <devel/NoesyAssign/PeakCalibrator.fwd.hh>
 
 // Package Headers
-// #include <protocols/NoesyAssign/PeakCalibratorInfo.hh>
-// #include <protocols/NoesyAssign/PeakAssignment.hh>
-// #include <protocols/NoesyAssign/ResonanceList.fwd.hh>
+// #include <devel/NoesyAssign/PeakCalibratorInfo.hh>
+// #include <devel/NoesyAssign/PeakAssignment.hh>
+// #include <devel/NoesyAssign/ResonanceList.fwd.hh>
 
 // Project Headers
 #include <core/types.hh>
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/PeakFileFormat.cc patched/rosetta_source/src/protocols/noesy_assign/PeakFileFormat.cc
--- vanilla/rosetta_source/src/protocols/noesy_assign/PeakFileFormat.cc	2012-03-20 19:43:19.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/PeakFileFormat.cc	2012-06-10 16:12:40.320039704 +0200
@@ -126,6 +126,7 @@ void PeakFileFormat::write_header( std::
 	//dimension 1
   atom_names.push_back( ObjexxFCL::lowercased( info1_->main_atom() ) );
   tolerances.push_back( info1_->proton_tolerance() );
+
   os << "# Number of dimensions " << dim << std::endl;
 	os << "#FILENAME " << filename() << std::endl;
 	std::string format_str = "xeasy" + utility::to_string( dim ) + "D";
@@ -135,6 +136,20 @@ void PeakFileFormat::write_header( std::
     os << "#INAME " << ct << " " << atom_names[ ct ] << std::endl;
     cyana_str += atom_names[ ct ];
   }
+	if ( info1_->fold_proton_resonance().is_folded() ) {
+		os << "#FOLD "<< dim << " " << info1_->fold_proton_resonance().start() << " " << info1_->fold_proton_resonance().end() << std::endl;
+	}
+	if ( info1_->fold_label_resonance().is_folded() ) {
+		os << "#FOLD "<< 1 << " " << info1_->fold_label_resonance().start() << " " << info1_->fold_label_resonance().end() << std::endl;
+	}
+
+	if ( info2_->fold_proton_resonance().is_folded() ) {
+		os << "#FOLD "<< dim-1 << " " << info2_->fold_proton_resonance().start() << " " << info2_->fold_proton_resonance().end() << std::endl;
+	}
+	if ( info2_->fold_label_resonance().is_folded() ) {
+		os << "#FOLD "<< 2 << " " << info2_->fold_label_resonance().start() << " " << info2_->fold_label_resonance().end() << std::endl;
+	}
+
   os << "#CYANAFORMAT " << cyana_str << std::endl;
   os << "#TOLERANCE ";
   for ( Size ct = 1; ct <= tolerances.size(); ct++ ) {
@@ -186,6 +201,9 @@ void PeakFileFormat::read_header( std::i
   Size dim( 0 );
   utility::vector1< std::string > atom_names;
   utility::vector1< core::Real > tolerances;
+	utility::vector1< core::Real > fold_starts( 4, 0);
+	utility::vector1< core::Real > fold_ends( 4, 0);
+
 	bool HN_column_labels( false ); //true if we find a HC or HN ( instead of h vs H )
   std::string line;
 	std::string cyana_string("none");
@@ -245,6 +263,13 @@ void PeakFileFormat::read_header( std::i
       atom_names[ index ] = name;
     } else if ( tag == "#CYANAFORMAT" ) {
 			line_stream >> cyana_string;
+		} else if ( tag == "#FOLD" ) {
+			Size fold_dim;
+			Size start;
+			Size end;
+			line_stream >> fold_dim >> start >> end;
+			fold_starts[ fold_dim ]=start;
+			fold_ends[ fold_dim ]=end;
     } else if ( tag == "#TOLERANCE" ) {
       for ( Size i = 1; i <= dim; i++ ) {
 				core::Real val;
@@ -327,6 +352,11 @@ void PeakFileFormat::read_header( std::i
       }
     }
   }
+	for ( Size i = 1; i<=dim; i++ ) {
+		CrossPeakInfoOP info = col2proton_[ i ]==1 ? info1_ : info2_;
+		info->set_folding_window( fold_starts[ i ], fold_ends[ i ], col2islabel_[ i ] );
+	}
+
 	if ( !info2_  || !info1_ ) {
 		throw utility::excn::EXCN_BadInput(" problem reading peak file, no or errorenous header ");
 	}
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/Resonance.hh patched/rosetta_source/src/protocols/noesy_assign/Resonance.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/Resonance.hh	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/Resonance.hh	2012-06-10 16:12:40.323039861 +0200
@@ -15,7 +15,7 @@
 
 
 // Unit Headers
-//#include <protocols/NoesyAssign/ResonanceList.fwd.hh>
+//#include <devel/NoesyAssign/ResonanceList.fwd.hh>
 #include <core/types.hh>
 
 // Package Headers
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/StructureIndependentPeakCalibrator.hh patched/rosetta_source/src/protocols/noesy_assign/StructureIndependentPeakCalibrator.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/StructureIndependentPeakCalibrator.hh	2012-03-21 09:06:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/StructureIndependentPeakCalibrator.hh	2012-06-10 16:12:40.326040975 +0200
@@ -11,13 +11,13 @@
 
 
 // Unit Header
-//#include <protocols/NoesyAssign/StructureIndependentPeakCalibrator.fwd.hh>
+//#include <devel/NoesyAssign/StructureIndependentPeakCalibrator.fwd.hh>
 #include <protocols/noesy_assign/PeakCalibrator.hh>
 
 // Package Headers
-// #include <protocols/NoesyAssign/StructureIndependentPeakCalibratorInfo.hh>
-// #include <protocols/NoesyAssign/PeakAssignment.hh>
-// #include <protocols/NoesyAssign/ResonanceList.fwd.hh>
+// #include <devel/NoesyAssign/StructureIndependentPeakCalibratorInfo.hh>
+// #include <devel/NoesyAssign/PeakAssignment.hh>
+// #include <devel/NoesyAssign/ResonanceList.fwd.hh>
 
 // Project Headers
 #include <core/types.hh>
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/svn_status_out patched/rosetta_source/src/protocols/noesy_assign/svn_status_out
--- vanilla/rosetta_source/src/protocols/noesy_assign/svn_status_out	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/svn_status_out	2012-06-10 16:12:40.328041507 +0200
@@ -0,0 +1,9 @@
+?       svn_status_out
+M       PeakAssignment.cc
+M       CrossPeakInfo.hh
+M       PeakCalibrator.cc
+A       FoldResonance.hh
+M       CrossPeak.hh
+M       CrossPeakInfo.cc
+M       PeakFileFormat.cc
+M       CrossPeak.cc
diff -rupN vanilla/rosetta_source/src/protocols/noesy_assign/UnfoldPeak.hh patched/rosetta_source/src/protocols/noesy_assign/UnfoldPeak.hh
--- vanilla/rosetta_source/src/protocols/noesy_assign/UnfoldPeak.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/noesy_assign/UnfoldPeak.hh	2012-06-10 16:12:40.331040430 +0200
@@ -0,0 +1,61 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file CrossPeakList.hh
+/// @author Oliver Lange
+
+#ifndef INCLUDED_protocols_noesy_assign_UnfoldPeak_hh
+#define INCLUDED_protocols_noesy_assign_UnfoldPeak_hh
+
+
+// Unit Headers
+#include <protocols/noesy_assign/UnfoldPeak.fwd.hh>
+
+// Package Headers
+
+// Project Headers
+#include <core/types.hh>
+
+// Utility headers
+
+// C++ headers
+#include <string>
+
+namespace protocols {
+namespace noesy_assign {
+
+class FoldResonance {
+  UnfoldPeak( core::Real start, core::Real end ) : start_( start ), window_( end-start ) {}
+
+  bool is_folded_down( core::Real freq ) {
+    return window_ > 0.1 && freq < start();
+  }
+
+  bool is_folded_up( core::Real freq ) {
+    return window_ > 0.1 && freq > end();
+  }
+
+  bool is_folded( core::Real freq ) {
+    return is_folded_down(freq) || is_folded_up( freq );
+  }
+
+  core::Real start() { return start_; }
+  core::Real end() { return start_+window_; }
+
+  core::Real operator() ( core::Real freq ) {
+    while( is_folded_down( freq ) ) { freq+=window_; }
+    while( is_folded_up( freq ) ) { freq-=window_; }
+    assert( !is_folded( freq ) );
+    return freq;
+  }
+
+private:
+  core::Real start_;
+  core::Real window_;
+}
+
+}
+}
diff -rupN vanilla/rosetta_source/src/protocols/relax/Ramady.cc patched/rosetta_source/src/protocols/relax/Ramady.cc
--- vanilla/rosetta_source/src/protocols/relax/Ramady.cc	2012-03-20 19:43:13.000000000 +0100
+++ patched/rosetta_source/src/protocols/relax/Ramady.cc	2012-06-10 16:12:40.553039947 +0200
@@ -126,7 +126,7 @@ void fix_worst_bad_ramas( core::pose::Po
 	//const core::Real limit_rama = 2.0;
 	//const core::Real limit_rama_min = 2.0;
 	const core::Real limit_rama_min = limit_rama;
-	
+
 
 	// Original RAFT set
 	//-140  153 180 0.135 B
@@ -281,15 +281,17 @@ void fix_worst_bad_ramas( core::pose::Po
 	// Final RamaCheck
 	rama_scorefxn(pose); //apply score
 	for ( Size i=1; i<= pose.total_residue(); ++i ) {
+		if ( !pose.residue_type(i).is_protein() ) continue;
 		EnergyMap & emap( energies.onebody_energies( i ) );
 		TR << "CHECK: " << i << "  "
-			<< pose.phi(i) << "  "
-			<< pose.psi(i) << "  "
-			<< emap[ rama ] << std::endl;
+			 << pose.phi(i) << "  "
+			 << pose.psi(i) << "  "
+			 << emap[ rama ] << std::endl;
 	}
 
 	// save the angles
 	for( core::Size ir = 1; ir < original_pose.total_residue(); ir ++ ){
+		if ( !pose.residue_type(ir).is_protein() ) continue;
 		original_pose.set_phi(   ir, pose.phi(   ir ) );
 		original_pose.set_psi(   ir, pose.psi(   ir ) );
 		original_pose.set_omega( ir, pose.omega( ir ) );
diff -rupN vanilla/rosetta_source/src/protocols/simple_filters/RDC_Evaluator.cc patched/rosetta_source/src/protocols/simple_filters/RDC_Evaluator.cc
--- vanilla/rosetta_source/src/protocols/simple_filters/RDC_Evaluator.cc	2012-03-20 19:43:37.000000000 +0100
+++ patched/rosetta_source/src/protocols/simple_filters/RDC_Evaluator.cc	2012-06-10 16:12:40.618040361 +0200
@@ -21,7 +21,8 @@
 
 // Package Headers
 #include <core/scoring/ResidualDipolarCoupling.hh>
-#include <core/scoring/ScoreFunction.hh>
+#include <core/scoring/methods/ResidualDipolarCouplingEnergy.hh>
+
 
 // Project Headers
 #include <core/io/silent/SilentStruct.hh>
@@ -48,7 +49,24 @@ namespace protocols {
 namespace simple_filters {
 using namespace core;
 
-
+RDC_Evaluator::RDC_Evaluator( std::string tag ) :
+	evaluation::SingleValuePoseEvaluator< Real >( tag )
+{}
+
+//RDC_Evaluator::RDC_Evaluator( utility::vector1< std::string > const& rdc_files, std::string tag) :
+//	evaluation::SingleValuePoseEvaluator< Real >( tag ),
+//	rdc_files_( rdc_files )
+//{
+//	init_rdcs();
+//}
+
+static core::scoring::methods::ResidualDipolarCouplingEnergy energy_evaluator;
+ ///@brief evaluate pose
+core::Real
+RDC_Evaluator::apply( core::pose::Pose& pose ) const {
+	return energy_evaluator.eval_dipolar( pose, rdc_data_ ); //const
+}
+  ///@brief evaluate pose
 SelectRDC_Evaluator::SelectRDC_Evaluator( std::list< Size > const& selection, std::string tag, std::string file )
   : evaluation::SingleValuePoseEvaluator< Real >( "rdc"+tag ),
 		selection_( selection ),
@@ -86,13 +104,7 @@ SelectRDC_Evaluator::SelectRDC_Evaluator
 
 Real
 SelectRDC_Evaluator::apply( core::pose::Pose& pose ) const {
-  core::Real rdc;
-	scoring::ScoreFunction scorefxn;
-  scorefxn.set_weight( scoring::rdc, 1 );
-	pose::Pose test_pose( pose );
-	scoring::store_RDC_in_pose( rdc_data_, test_pose );
-	rdc = scorefxn( test_pose );
-	return rdc;
+	return energy_evaluator.eval_dipolar( pose, *rdc_data_ ); //cons
 }
 
 void
diff -rupN vanilla/rosetta_source/src/protocols/simple_filters/RDC_Evaluator.hh patched/rosetta_source/src/protocols/simple_filters/RDC_Evaluator.hh
--- vanilla/rosetta_source/src/protocols/simple_filters/RDC_Evaluator.hh	2012-03-20 19:43:37.000000000 +0100
+++ patched/rosetta_source/src/protocols/simple_filters/RDC_Evaluator.hh	2012-06-10 16:12:40.621039791 +0200
@@ -41,7 +41,7 @@
 //// C++ headers
 #include <list>
 
-#include <core/scoring/ResidualDipolarCoupling.fwd.hh>
+#include <core/scoring/ResidualDipolarCoupling.hh>
 #include <core/scoring/rms_util.hh>
 #include <utility/vector1.hh>
 
@@ -49,6 +49,21 @@
 namespace protocols {
 namespace simple_filters {
 
+
+class RDC_Evaluator : public evaluation::SingleValuePoseEvaluator< core::Real > {
+public:
+  RDC_Evaluator( std::string tag = "rdc" );
+	//  RDC_Evaluator( utility::vector1< std::string > const& rdc_files, std::string tag = "rdc" );
+
+  ///@brief evaluate pose
+  virtual core::Real apply( core::pose::Pose& ) const;
+
+private:
+	std::string tag_;
+  mutable core::scoring::ResidualDipolarCoupling rdc_data_; //initialized automatically from -in:file:rdc
+};
+
+
 class SelectRDC_Evaluator : public evaluation::SingleValuePoseEvaluator< core::Real > {
 public:
   SelectRDC_Evaluator( core::scoring::ResidueSelection const& selection, std::string tag = "", std::string file ="" );
diff -rupN vanilla/rosetta_source/src/protocols/simple_moves/RepulsiveOnlyMover.cc patched/rosetta_source/src/protocols/simple_moves/RepulsiveOnlyMover.cc
--- vanilla/rosetta_source/src/protocols/simple_moves/RepulsiveOnlyMover.cc	2012-03-20 19:43:49.000000000 +0100
+++ patched/rosetta_source/src/protocols/simple_moves/RepulsiveOnlyMover.cc	2012-06-10 16:12:40.603040311 +0200
@@ -15,12 +15,13 @@
 // Unit Headers
 #include <protocols/simple_moves/RepulsiveOnlyMover.hh>
 
-// Package headers 
+// Package headers
 
-// Project headers 
+// Project headers
 // AUTO-REMOVED #include <core/chemical/ChemicalManager.hh>
 #include <core/chemical/ResidueTypeSet.hh>
 #include <core/chemical/AtomType.hh>
+#include <core/chemical/VariantType.hh>
 #include <core/conformation/Residue.hh>
 #include <core/pose/util.hh>
 #include <core/pose/Pose.hh>
@@ -49,7 +50,7 @@ static basic::Tracer TR( "protocol.mover
 
 
 /// RepulsiveOnlyMover; based on the protocols::moves::Mover basis class
-RepulsiveOnlyMover::RepulsiveOnlyMover() : protocols::moves::Mover() {}
+RepulsiveOnlyMover::RepulsiveOnlyMover() : protocols::moves::Mover(), mutate_to_glycine_( true ) {}
 RepulsiveOnlyMover::~RepulsiveOnlyMover() {}
 
 
@@ -57,15 +58,15 @@ RepulsiveOnlyMover::~RepulsiveOnlyMover(
 void
 RepulsiveOnlyMover::apply( core::pose::Pose & pose ) {
 	if (	basic::options::option[basic::options::OptionKeys::in::replonly_loops]() ){
-		for ( core::Size i=1; i<=pose.n_residue(); i++ ){   
+		for ( core::Size i=1; i<=pose.n_residue(); i++ ){
 			if ( pose.secstruct(i)=='L' ){
-				if ( ! pose.residue(i).has_variant_type( "REPLONLY" ) ){
+				if ( ! pose.residue(i).has_variant_type( core::chemical::REPLONLY ) ){
 					core::pose::remove_lower_terminus_type_from_pose_residue( pose, i );
 					core::pose::remove_upper_terminus_type_from_pose_residue( pose, i );
 					core::pose::add_variant_type_to_pose_residue( pose, "REPLONLY", i );
 				}
 			}else {
-				if ( pose.residue(i).has_variant_type( "REPLONLY" )){
+				if ( pose.residue(i).has_variant_type( core::chemical::REPLONLY )){
 					core::pose::remove_variant_type_from_pose_residue( pose, "REPLONLY", i );
 				}
 			}
@@ -74,18 +75,20 @@ RepulsiveOnlyMover::apply( core::pose::P
 	if ( basic::options::option[ basic::options::OptionKeys::in::replonly_residues ].user() ){
 		utility::vector1<Size> replonly_rsd = basic::options::option[ basic::options::OptionKeys::in::replonly_residues ]();
 		//TR << "RepulsiveOnly protocols::moves::Mover has been called" << std::endl;
-		for ( core::Size i=1; i<=replonly_rsd.size(); i++ ){   
-			core::chemical::ResidueType const & gly( pose.residue(i).residue_type_set().name_map("GLY") );
-			core::pose::replace_pose_residue_copying_existing_coordinates( pose, replonly_rsd[i], gly );
-		//TR << replonly_rsd[i] << " has been changed as GLY" << std::endl;
-			if ( ! pose.residue( replonly_rsd[i] ).has_variant_type( "REPLONLY" ) ){
+		for ( core::Size i=1; i<=replonly_rsd.size(); i++ ){
+			if ( mutate_to_glycine_ ) {
+				core::chemical::ResidueType const & gly( pose.residue(replonly_rsd[i]).residue_type_set().name_map("GLY") );
+				core::pose::replace_pose_residue_copying_existing_coordinates( pose, replonly_rsd[i], gly );
+				TR << replonly_rsd[i] << " has been changed as GLY" << std::endl;
+			}
+			if ( ! pose.residue( replonly_rsd[i] ).has_variant_type( core::chemical::REPLONLY ) ){
 				core::pose::remove_lower_terminus_type_from_pose_residue( pose, replonly_rsd[i] );
 				core::pose::remove_upper_terminus_type_from_pose_residue( pose, replonly_rsd[i] );
 				core::pose::add_variant_type_to_pose_residue( pose, "REPLONLY", replonly_rsd[i] );
-			} 
-		}   
-	}   
-}   
+			}
+		}
+	}
+}
 
 std::string
 RepulsiveOnlyMover::get_name() const {
diff -rupN vanilla/rosetta_source/src/protocols/simple_moves/RepulsiveOnlyMover.hh patched/rosetta_source/src/protocols/simple_moves/RepulsiveOnlyMover.hh
--- vanilla/rosetta_source/src/protocols/simple_moves/RepulsiveOnlyMover.hh	2012-03-20 19:43:49.000000000 +0100
+++ patched/rosetta_source/src/protocols/simple_moves/RepulsiveOnlyMover.hh	2012-06-10 16:12:40.606043020 +0200
@@ -50,8 +50,12 @@ public:
 
 	virtual void apply( core::pose::Pose & pose );
 	virtual std::string get_name() const;
+	void set_mutate_to_glycine( bool setting ) {
+		mutate_to_glycine_ = setting;
+	}
 
 private:
+	bool mutate_to_glycine_;
 };
 
 } // moves
diff -rupN vanilla/rosetta_source/src/protocols/toolbox/DecoySetEvaluation.impl.hh patched/rosetta_source/src/protocols/toolbox/DecoySetEvaluation.impl.hh
--- vanilla/rosetta_source/src/protocols/toolbox/DecoySetEvaluation.impl.hh	2012-03-20 19:43:24.000000000 +0100
+++ patched/rosetta_source/src/protocols/toolbox/DecoySetEvaluation.impl.hh	2012-06-10 16:12:40.439039645 +0200
@@ -35,7 +35,7 @@ template< typename SilentStructIterator 
 void DecoySetEvaluation::push_back_CA_xyz_from_silent_file( Size n_decoys_in, SilentStructIterator begin, SilentStructIterator end, bool store_energies ) {
   static basic::Tracer _impl_tr("protocols.toolbox.DecoySetEvaluation");
 
-  Size const n_new_decoys( n_decoys_in );
+  Size n_new_decoys( n_decoys_in );
 
   if ( begin == end ) return;
   core::pose::Pose pose;
@@ -58,7 +58,7 @@ void DecoySetEvaluation::push_back_CA_xy
     reserve( n_decoys() + n_new_decoys );
   }
 
-  for ( SilentStructIterator it=begin; it!=end; ++it )	{
+  for ( SilentStructIterator it=begin; it!=end && n_new_decoys>0; ++it, --n_new_decoys )	{
     push_back_CA_xyz( it->get_CA_xyz(), n_atoms() > 0 ? n_atoms() : it->nres() );
     if ( store_energies_ ) {
       all_energies_.push_back( it->get_energy( "score" ) );
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/AsymFoldandDockClaimer.cc patched/rosetta_source/src/protocols/topology_broker/AsymFoldandDockClaimer.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/AsymFoldandDockClaimer.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/AsymFoldandDockClaimer.cc	2012-06-10 16:12:40.207040417 +0200
@@ -110,7 +110,7 @@ bool AsymFoldandDockClaimer::read_tag( s
 		std::string file;
 		is >> file;
 		std::ifstream infile( file.c_str() );
-		
+
 		if (!infile.good()) {
 			utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + file + "'" );
 		}
@@ -134,6 +134,7 @@ void AsymFoldandDockClaimer::initialize_
 	DofClaims& /*failed_to_init*/ ) {
 
 	using namespace loops;
+	using namespace kinematics;
 
 	if ( moving_res_.size() == 0 ) throw utility::excn::EXCN_BadInput( " missing definition of moving residues, add a LOOP definition ");
 	if ( moving_res_.size() > 1 ) throw utility::excn::EXCN_BadInput( " Only one movable region possible at this stage ");
@@ -168,6 +169,14 @@ void AsymFoldandDockClaimer::initialize_
 	protocols::docking::DockingProtocol dock;
 	protocols::docking::DockingInitialPerturbation dock_init(slide);
 	std::string chainID("A_B");
+	// If we don't have a docking jump we have to create it before calling setup_foldtree (strangely enough)
+	if ( pose.fold_tree().num_jump() == 0 ) {
+		FoldTree f(pose.fold_tree());
+		f.clear();
+    f.simple_tree( pose.total_residue() );
+		f.new_jump( 1, pose.total_residue() , chain_break_res_ );
+		pose.fold_tree( f );
+	}
 	protocols::docking::setup_foldtree( pose, chainID, dock.movable_jumps() );
 	docking_jump_ = docking_jump( pose, chain_break_res_ );
 	dock_init.apply( pose );
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/ConstraintClaimer.cc patched/rosetta_source/src/protocols/topology_broker/ConstraintClaimer.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/ConstraintClaimer.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/ConstraintClaimer.cc	2012-06-10 16:12:40.210039804 +0200
@@ -72,7 +72,9 @@ ConstraintClaimer::ConstraintClaimer() :
 	bCmdFlag_( false ),
 	combine_ratio_( 1 ),
 	skip_redundant_( false ),
-	skip_redundant_width_( 1 )
+	skip_redundant_width_( 1 ),
+	filter_weight_( 0.0 ),
+	filter_name_( "" )
 {}
 
 ConstraintClaimer::ConstraintClaimer( std::string filename, std::string tag ) :
@@ -84,7 +86,9 @@ ConstraintClaimer::ConstraintClaimer( st
 	bCmdFlag_( false ),
 	combine_ratio_( 1 ),
 	skip_redundant_( false ),
-	skip_redundant_width_( 1 )
+	skip_redundant_width_( 1 ),
+	filter_weight_( 0.0 ),
+	filter_name_( "" )
 {}
 
 ConstraintClaimer::ConstraintClaimer( bool CmdFlag, bool centroid, bool fullatom )
@@ -96,7 +100,9 @@ ConstraintClaimer::ConstraintClaimer( bo
 		bCmdFlag_( CmdFlag ),
 		combine_ratio_( 1 ),
 		skip_redundant_( false ),
-		skip_redundant_width_( 1 )
+		skip_redundant_width_( 1 ),
+		filter_weight_( 0.0 ),
+		filter_name_( "" )
 {
 	runtime_assert( CmdFlag );
 }
@@ -135,7 +141,7 @@ void ConstraintClaimer::new_decoy() {
 
 
 
-void ConstraintClaimer::add_constraints( core::pose::Pose& pose ) {
+void ConstraintClaimer::add_constraints( core::pose::Pose& pose ) const {
 	using namespace basic::options;
 	bool fullatom( pose.is_fullatom() );
 	if ( fullatom && !bFullatom_ ) return;
@@ -150,11 +156,11 @@ void ConstraintClaimer::add_constraints(
 		std::string const file( option[ OptionKeys::constraints::combine_exclude_region ]() );
 		loops::LoopsFileIO loop_file_reader;
 		std::ifstream is( file.c_str() );
-		
+
 		if (!is.good()) {
 			utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + file + "'" );
 		}
-		
+
 		loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format(is, file, false, "RIGID");
 		loops::Loops rigid_core = loops::Loops( loops );
 		combine_exclude_res_.resize( pose.total_residue(), false );
@@ -215,13 +221,50 @@ bool ConstraintClaimer::read_tag( std::s
 	} else if ( tag == "CMD_FLAG" ) {
 		bCmdFlag_ = true;
 	} else if ( tag == "COMBINE_RATIO" ) {
-		Size ratio;
-		is >> ratio;
-		combine_ratio_ = ratio;
+		is >> combine_ratio_;
+	} else if ( tag == "FILTER_WEIGHT" ) {
+		is >> filter_weight_;
+	} else if ( tag == "FILTER_NAME" ) {
+		is >> filter_name_;
 	} else return Parent::read_tag( tag, is );
 	return true;
 }
 
+void ConstraintClaimer::set_cst_file( std::string const& file ) {
+	filename_ = file;
+	constraints_ = NULL;
+	fa_constraints_ = NULL;
+}
+
+void ConstraintClaimer::set_fullatom( bool setting ) {
+	bFullatom_ = setting;
+	constraints_ = NULL;
+	fa_constraints_ = NULL;
+}
+
+void ConstraintClaimer::set_centroid( bool setting ) {
+	bCentroid_ = setting;
+	constraints_ = NULL;
+	fa_constraints_ = NULL;
+}
+
+void ConstraintClaimer::set_skip_redundant( bool setting ) {
+	skip_redundant_ = setting;
+	constraints_ = NULL;
+	fa_constraints_ = NULL;
+}
+
+void ConstraintClaimer::set_combine_ratio( core::Size setting ) {
+	combine_ratio_ = setting;
+	constraints_ = NULL;
+	fa_constraints_ = NULL;
+}
+
+void ConstraintClaimer::set_filter_weight( core::Real setting ) {
+	filter_weight_ = setting;
+}
+
+
 
 } //topology_broker
 } //protocols
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/ConstraintClaimer.hh patched/rosetta_source/src/protocols/topology_broker/ConstraintClaimer.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/ConstraintClaimer.hh	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/ConstraintClaimer.hh	2012-06-10 16:12:40.213039975 +0200
@@ -79,9 +79,21 @@ public:
 
 	virtual bool read_tag( std::string tag, std::istream & );
 
-	virtual void add_constraints( core::pose::Pose& /*pose*/ );
-
+	virtual void add_constraints( core::pose::Pose& /*pose*/ ) const;
 
+	//	ConstraintSetCOP constraints() const { return constraints_; }
+	//	ConstraintSetCOP fa_constraints() const { return fa_constraints_; }
+	core::Real filter_weight() const { return filter_weight_; }
+	std::string const& filter_name() const { return filter_name_; }
+	core::Size combine_ratio() const { return combine_ratio_; }
+	std::string const& tag() const { return tag_; }
+
+	void set_cst_file( std::string const& );
+	void set_fullatom( bool setting );
+	void set_centroid( bool setting );
+	void set_skip_redundant( bool setting );
+	void set_combine_ratio( core::Size setting );
+	void set_filter_weight( core::Real weight );
 private:
 	std::string filename_, fa_filename_;
 	std::string cst_filename_;
@@ -91,7 +103,7 @@ private:
 
 	mutable core::pose::Pose constraint_ref_pose_;
 	mutable std::string sequence_;
-
+	mutable utility::vector1< bool > combine_exclude_res_;
 	///@brief true if constraints are active in centroid mode
 	bool bCentroid_;
 
@@ -105,13 +117,17 @@ private:
 
 	///@brief combine constraints randomly into Ambiguous Constraints
 	core::Size combine_ratio_;  //default 1: no constraint combination
-	utility::vector1< bool > combine_exclude_res_;
+
 
 	///@brief at most one constraint per residue pair ( does not look at bounds... )
 	bool skip_redundant_;
 
 	///@brief how many residues left and right do we exclude other "redundant" constraints...
 	core::Size skip_redundant_width_;
+
+	///@brief which weight should this constraint set have when used as a filter
+	core::Real filter_weight_;
+	std::string filter_name_;
 }; //class ConstraintClaimer
 
 }
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/ConstraintClaimerWrapper.hh patched/rosetta_source/src/protocols/topology_broker/ConstraintClaimerWrapper.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/ConstraintClaimerWrapper.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/ConstraintClaimerWrapper.hh	2012-06-10 16:12:40.215068945 +0200
@@ -0,0 +1,129 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file TopologyBroker
+/// @brief  top-class (Organizer) of the TopologyBroker mechanism
+/// @detailed responsibilities:
+/// @author Oliver Lange
+
+
+#ifndef INCLUDED_protocols_topology_broker_ConstraintClaimer_hh
+#define INCLUDED_protocols_topology_broker_ConstraintClaimer_hh
+
+
+// Unit Headers
+#include <protocols/topology_broker/ConstraintClaimer.fwd.hh>
+
+// Package Headers
+#include <protocols/topology_broker/TopologyClaimer.hh>
+#include <protocols/topology_broker/DofClaim.fwd.hh>
+#include <core/scoring/constraints/ConstraintSet.hh>
+
+// Project Headers
+#include <core/pose/Pose.hh>
+
+// ObjexxFCL Headers
+
+// Utility headers
+//#include <utility/io/izstream.hh>
+//#include <utility/io/ozstream.hh>
+//#include <utility/io/util.hh>
+//#include <basic/Tracer.hh>
+//#include <basic/options/option.hh>
+
+#include <utility/pointer/ReferenceCount.hh>
+
+#include <utility/vector1.hh>
+
+
+//#include <basic/options/option_macros.hh>
+
+//// C++ headers
+//#include <fstream>
+
+// option key includes
+
+
+namespace protocols {
+namespace topology_broker {
+
+class ConstraintClaimer : public TopologyClaimer {
+	typedef TopologyClaimer Parent;
+public:
+	ConstraintClaimer(); //for factory
+	ConstraintClaimer( std::string cst_file, std::string tag = "" );
+	ConstraintClaimer( bool CmdFlag, bool centroid = true, bool fullatom = false );
+
+	virtual TopologyClaimerOP clone() const {
+		return new ConstraintClaimer( *this );
+	}
+
+	virtual void generate_claims( DofClaims& );
+
+	///@brief type() is specifying the output name of the TopologyClaimer
+	virtual std::string type() const {
+		return _static_type_name();
+	}
+
+	static std::string _static_type_name() {
+		return "ConstraintClaimer";
+	}
+
+	virtual void new_decoy();
+
+	virtual bool read_tag( std::string tag, std::istream & );
+
+	virtual void add_constraints( core::pose::Pose& /*pose*/ );
+
+	ConstraintSetCOP constraints() const { return constraints_; }
+	ConstraintSetCOP fa_constraints() const { return fa_constraints_; }
+	core::Real filter_weight() const { return filter_weight_; }
+	std::string const& filter_name() const { return filter_name_; }
+	core::Size combine_ratio() const { return combine_ratio_; }
+
+private:
+	std::string filename_, fa_filename_;
+	std::string cst_filename_;
+	std::string tag_;
+	mutable core::scoring::constraints::ConstraintSetOP constraints_;
+	mutable core::scoring::constraints::ConstraintSetOP fa_constraints_;
+
+	mutable core::pose::Pose constraint_ref_pose_;
+	mutable std::string sequence_;
+
+	///@brief true if constraints are active in centroid mode
+	bool bCentroid_;
+
+	///@brief true if constraints are active in full-atom mode
+	/// if true use fa_constraints if available... normal constraints otherwise
+	bool bFullatom_;
+
+	///@brief use constraints defined via command line
+	bool bCmdFlag_;
+
+
+	///@brief combine constraints randomly into Ambiguous Constraints
+	core::Size combine_ratio_;  //default 1: no constraint combination
+	utility::vector1< bool > combine_exclude_res_;
+
+	///@brief at most one constraint per residue pair ( does not look at bounds... )
+	bool skip_redundant_;
+
+	///@brief how many residues left and right do we exclude other "redundant" constraints...
+	core::Size skip_redundant_width_;
+
+	///@brief which weight should this constraint set have when used as a filter
+	core::Real filter_weight_;
+	std::string filter_name_;
+}; //class ConstraintClaimer
+
+}
+}
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.cc patched/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.cc	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.cc	2012-06-10 16:12:40.218040553 +0200
@@ -0,0 +1,81 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file TopologyBroker
+/// @brief  top-class (Organizer) of the TopologyBroker mechanism
+/// @detailed responsibilities:
+/// @author Oliver Lange
+
+// Unit Headers
+#include <protocols/topology_broker/ConstraintEvaluatorWrapper.hh>
+
+// Package Headers
+
+// Project Headers
+#include <core/pose/Pose.hh>
+#include <core/scoring/ScoreFunction.hh>
+// ObjexxFCL Headers
+
+// Utility headers
+#include <utility/excn/Exceptions.hh>
+
+#include <basic/Tracer.hh>
+//// C++ headers
+
+#include <core/id/SequenceMapping.hh>
+#include <utility/vector1.hh>
+
+
+// option key includes
+
+static basic::Tracer tr("protocols.evaluator",basic::t_info);
+//static numeric::random::RandomGenerator RG(18828234);
+
+namespace protocols {
+namespace topology_broker {
+
+//static numeric::random::RandomGenerator RG(812739);  // <- Magic number, do not change it!
+
+using namespace core;
+using namespace scoring::constraints;
+using namespace scoring;
+ConstraintEvaluatorWrapper::ConstraintEvaluatorWrapper( std::string const& name, ConstraintClaimerCOP claimer ) :
+	name_( name ),
+	claimer_( claimer )
+{}
+
+Real ConstraintEvaluatorWrapper::apply( core::pose::Pose& pose_in ) const {
+	pose::Pose pose( pose_in );
+	claimer_->add_constraints( pose );
+
+	ScoreFunction scfxn;
+	scfxn.set_weight( scoring::atom_pair_constraint, 1.0 );
+	core::Real score( scfxn( pose ) );
+	return score;
+}
+
+void ConstraintEvaluatorWrapper::apply( core::pose::Pose& pose_in, std::string, core::io::silent::SilentStruct &pss ) const {
+	pose::Pose pose( pose_in );
+	claimer_->add_constraints( pose );
+
+	ScoreFunction scfxn;
+	scfxn.set_weight( scoring::atom_pair_constraint, 1.0 );
+	core::Real score( scfxn( pose ) );
+
+	pss.add_energy( name( 1 ), score );
+}
+
+std::string ConstraintEvaluatorWrapper::name( core::Size i ) const {
+	if ( i == 1 ) { return name_; }
+	runtime_assert( i <= 1 && i > 0 );
+	return ""; //make compiler happy
+}
+
+} //topology_broker
+} //protocols
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.fwd.hh patched/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.fwd.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.fwd.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.fwd.hh	2012-06-10 16:12:40.221039665 +0200
@@ -0,0 +1,41 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   core/kinematics/ShortestPathInFoldTree.fwd.hh
+/// @brief  kinematics::ShortestPathInFoldTree forward declarations header
+/// @author Oliver Lange
+
+
+#ifndef INCLUDED_protocols_topology_broker_ConstraintEvaluatorWrapper_fwd_hh
+#define INCLUDED_protocols_topology_broker_ConstraintEvaluatorWrapper_fwd_hh
+
+
+// Utility headers
+#include <utility/pointer/access_ptr.fwd.hh>
+#include <utility/pointer/owning_ptr.fwd.hh>
+
+
+namespace protocols {
+namespace topology_broker {
+
+// Forward
+class ConstraintEvaluatorWrapper;
+
+// Types
+typedef  utility::pointer::owning_ptr< ConstraintEvaluatorWrapper >  ConstraintEvaluatorWrapperOP;
+typedef  utility::pointer::owning_ptr< ConstraintEvaluatorWrapper const >  ConstraintEvaluatorWrapperCOP;
+
+typedef  utility::pointer::access_ptr< ConstraintEvaluatorWrapper >  ConstraintEvaluatorWrapperAP;
+typedef  utility::pointer::access_ptr< ConstraintEvaluatorWrapper const >  ConstraintEvaluatorWrapperCAP;
+
+
+} // namespace kinematics
+} // namespace core
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.hh patched/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/ConstraintEvaluatorWrapper.hh	2012-06-10 16:12:40.223069621 +0200
@@ -0,0 +1,63 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file TopologyBroker
+/// @brief  top-class (Organizer) of the TopologyBroker mechanism
+/// @detailed responsibilities:
+/// @author Oliver Lange
+
+
+#ifndef INCLUDED_protocols_topology_broker_ConstraintEvaluatorWrapper_hh
+#define INCLUDED_protocols_topology_broker_ConstraintEvaluatorWrapper_hh
+
+
+// Unit Headers
+#include <protocols/topology_broker/ConstraintEvaluatorWrapper.fwd.hh>
+
+// Package Headers
+#include <protocols/topology_broker/ConstraintClaimer.hh>
+
+// Project Headers
+#include <core/pose/Pose.fwd.hh>
+
+// ObjexxFCL Headers
+#include <protocols/evaluation/PoseEvaluator.hh>
+// Utility headers
+
+//// C++ headers
+
+// option key includes
+
+
+namespace protocols {
+namespace topology_broker {
+
+class ConstraintEvaluatorWrapper : public evaluation::PoseEvaluator {
+
+public:
+	ConstraintEvaluatorWrapper( std::string const& name, ConstraintClaimerCOP claimer ); //for factory
+
+	//sets xxx_cst and xxx_viol columns
+  virtual void apply( core::pose::Pose& pose, std::string tag, core::io::silent::SilentStruct &pss) const;
+
+	//returns constraint score
+	virtual core::Real apply( core::pose::Pose& pose ) const;
+
+	virtual core::Size size() const { return 1; }
+	virtual std::string name( core::Size i ) const;
+
+private:
+	std::string name_;
+	ConstraintClaimerCOP claimer_;
+}; //class ConstraintEvaluatorWrapper
+
+}
+}
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/CoordConstraintClaimer.cc patched/rosetta_source/src/protocols/topology_broker/CoordConstraintClaimer.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/CoordConstraintClaimer.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/CoordConstraintClaimer.cc	2012-06-10 16:12:40.226039825 +0200
@@ -151,7 +151,7 @@ void CoordConstraintClaimer::read_cst_po
 	sequence_ = "";
 }
 
-void CoordConstraintClaimer::add_constraints( core::pose::Pose& pose ) {
+void CoordConstraintClaimer::add_constraints( core::pose::Pose& pose ) const {
 	//	Size new_root;
 
 	std::string const new_sequence ( pose.annotated_sequence( true ) );
@@ -274,7 +274,7 @@ void CoordConstraintClaimer::read_constr
 	}
 }
 
-void CoordConstraintClaimer::superimpose( pose::Pose const& pose ) {
+void CoordConstraintClaimer::superimpose( pose::Pose const& pose ) const {
 	ConstraintCOPs all_cst = constraints_->get_all_constraints();
 	ConstraintSetOP new_set = new ConstraintSet;
 
@@ -368,7 +368,7 @@ void CoordConstraintClaimer::set_default
 
 bool CoordConstraintClaimer::read_tag( std::string tag, std::istream& is ) {
 	loops::LoopsFileIO loop_file_reader;
-	
+
 	if ( tag == "pdb_file" || tag == "PDB_FILE" ) {
 		is >> filename_;
 		read_cst_pose();
@@ -381,7 +381,7 @@ bool CoordConstraintClaimer::read_tag( s
 		std::string file;
 		is >> file;
 		std::ifstream infile( file.c_str() );
-		
+
 		if (!infile.good()) {
 			utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + file + "'" );
 		}
@@ -412,7 +412,7 @@ bool CoordConstraintClaimer::read_tag( s
 		std::string file;
 		is >> file;
 		std::ifstream infile( file.c_str() );
-		
+
 		if (!infile.good()) {
 			utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + file + "'" );
 		}
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/CoordConstraintClaimer.hh patched/rosetta_source/src/protocols/topology_broker/CoordConstraintClaimer.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/CoordConstraintClaimer.hh	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/CoordConstraintClaimer.hh	2012-06-10 16:12:40.229040338 +0200
@@ -78,14 +78,14 @@ public:
 	}
 
 
-	virtual void add_constraints( core::pose::Pose& /*pose*/ );
+	virtual void add_constraints( core::pose::Pose& /*pose*/ ) const;
 
 	virtual void new_decoy();
 
 	virtual void new_decoy( core::pose::Pose const& );
 
 	///@brief superimpose xyz coords in constraints_ with pose
-	void superimpose( core::pose::Pose const& );
+	void superimpose( core::pose::Pose const& ) const;
 
 protected:
 
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/JumpClaimer.cc patched/rosetta_source/src/protocols/topology_broker/JumpClaimer.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/JumpClaimer.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/JumpClaimer.cc	2012-06-10 16:12:40.232039901 +0200
@@ -48,7 +48,7 @@
 
 #include <core/fragment/Frame.hh>
 #include <utility/vector1.hh>
-
+#include <typeinfo>
 
 // option key includes
 
@@ -155,11 +155,14 @@ void JumpClaimer::init_jumps() {
 		Size attempts( 10 );
 		do {
 			current_jumps_ = jump_def_->create_jump_sample();
+			if ( tr.Debug.visible() && !current_jumps_.is_valid() ) {
+				tr.Debug << "was not able to make fold-tree for " << current_jumps_ << std::endl;
+			}
 		} while ( !current_jumps_.is_valid() && attempts-- );
 	}
 
 	if ( !current_jumps_.is_valid() ) {
-		throw utility::excn::EXCN_BadInput("not able to build valid fold-tree in JumpClaimer");
+		throw utility::excn::EXCN_BadInput("not able to build valid fold-tree from a "+jump_def_->type_name()+" in 10 attempts in JumpClaimer");
 	}
 	tr.Debug << "current_jumps " << current_jumps_ << std::endl;
 
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/MembraneTopologyClaimer.cc patched/rosetta_source/src/protocols/topology_broker/MembraneTopologyClaimer.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/MembraneTopologyClaimer.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/MembraneTopologyClaimer.cc	2012-06-10 16:12:40.234040723 +0200
@@ -42,7 +42,6 @@
 #include <basic/Tracer.hh>
 #include <numeric/random/random.hh>
 
-#include <protocols/jobdist/Jobs.hh>
 #include <utility/vector0.hh>
 #include <utility/vector1.hh>
 
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/MetalloClaimer.cc patched/rosetta_source/src/protocols/topology_broker/MetalloClaimer.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/MetalloClaimer.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/MetalloClaimer.cc	2012-06-10 16:12:40.237040302 +0200
@@ -85,7 +85,7 @@ void MetalloClaimer::initialize_residues
 	new_decoy();
 }
 
-void MetalloClaimer::add_constraints( core::pose::Pose& ) {
+void MetalloClaimer::add_constraints( core::pose::Pose& ) const {
 }
 
 void  MetalloClaimer::set_defaults() {
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/MetalloClaimer.hh patched/rosetta_source/src/protocols/topology_broker/MetalloClaimer.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/MetalloClaimer.hh	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/MetalloClaimer.hh	2012-06-10 16:12:40.240041127 +0200
@@ -104,7 +104,7 @@ public:
 		return "MetalloClaimer";
 	}
 
-	virtual void add_constraints( core::pose::Pose& /*pose*/ );
+	virtual void add_constraints( core::pose::Pose& /*pose*/ ) const;
 
 	//void set_mover( simple_moves::FragmentMoverOP mover ) {
 	//		mover_ = mover;
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/PcsEnergyController.cc patched/rosetta_source/src/protocols/topology_broker/PcsEnergyController.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/PcsEnergyController.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/PcsEnergyController.cc	2012-06-10 16:12:40.242066243 +0200
@@ -162,7 +162,7 @@ bool PcsEnergyController::read_tag( std:
 		}
 
 		if(weight < 0){
-			std::cerr << "problem while parsing the tag '" << tag << "' . Expecting 1 string followed by one POSITIF weight" << std::endl;
+			std::cerr << "problem while parsing the tag '" << tag << "' . Expecting 1 string followed by one POSITIVE weight" << std::endl;
 			utility_exit();
 		}
 		g.filenames_.push_back(filename);
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.cc patched/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.cc	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.cc	2012-06-10 16:12:40.260209214 +0200
@@ -0,0 +1,227 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file TopologyBroker
+/// @brief  top-class (Organizer) of the TopologyBroker mechanism
+/// @detailed responsibilities:
+/// @author Oliver Lange
+
+// Unit Headers
+#include <protocols/topology_broker/RepulsiveOnlyClaimer.hh>
+
+// Package Headers
+#include <core/scoring/constraints/ConstraintIO.hh>
+#include <core/scoring/constraints/util.hh>
+#include <core/kinematics/ShortestPathInFoldTree.hh>
+
+//#include <protocols/topology_broker/DofClaim.hh>
+
+// Project Headers
+#include <core/pose/Pose.hh>
+#include <protocols/loops/Loops.hh>
+#include <protocols/loops/Loops.tmpl.hh>
+#include <protocols/loops/LoopsFileIO.hh>
+// #include <core/kinematics/MoveMap.hh>
+// #include <core/fragment/FragSet.hh>
+// #include <protocols/simple_moves/FragmentMover.hh>
+
+
+#include <core/id/Exceptions.hh>
+
+// ObjexxFCL Headers
+
+// Utility headers
+#include <utility/excn/Exceptions.hh>
+//#include <utility/io/izstream.hh>
+//#include <utility/io/ozstream.hh>
+//#include <utility/io/util.hh>
+#include <basic/Tracer.hh>
+#include <basic/options/option.hh>
+#include <basic/options/keys/constraints.OptionKeys.gen.hh>
+//// C++ headers
+// AUTO-REMOVED #include <fstream>
+
+#include <core/id/SequenceMapping.hh>
+#include <utility/vector1.hh>
+
+
+// option key includes
+
+static basic::Tracer tr("protocols.topo_broker",basic::t_info);
+//static numeric::random::RandomGenerator RG(18828234);
+
+namespace protocols {
+namespace topology_broker {
+
+//static numeric::random::RandomGenerator RG(812739);  // <- Magic number, do not change it!
+
+using namespace core;
+using namespace scoring::constraints;
+RepulsiveOnlyClaimer::RepulsiveOnlyClaimer() :
+	filename_( "NO_FILE"),
+	tag_( "NO_TAG" ),
+	constraints_( NULL ),
+	bCentroid_( true ),
+	bFullatom_( false ),
+	bCmdFlag_( false ),
+	combine_ratio_( 1 ),
+	skip_redundant_( false ),
+	skip_redundant_width_( 1 )
+{}
+
+RepulsiveOnlyClaimer::RepulsiveOnlyClaimer( std::string filename, std::string tag ) :
+	filename_( filename ),
+	tag_( tag ),
+	constraints_( NULL ),
+	bCentroid_( true ),
+	bFullatom_( false ),
+	bCmdFlag_( false ),
+	combine_ratio_( 1 ),
+	skip_redundant_( false ),
+	skip_redundant_width_( 1 )
+{}
+
+RepulsiveOnlyClaimer::RepulsiveOnlyClaimer( bool CmdFlag, bool centroid, bool fullatom )
+	:	filename_( "" ),
+		tag_( "" ),
+		constraints_( NULL ),
+		bCentroid_( centroid ),
+		bFullatom_( fullatom ),
+		bCmdFlag_( CmdFlag ),
+		combine_ratio_( 1 ),
+		skip_redundant_( false ),
+		skip_redundant_width_( 1 )
+{
+	runtime_assert( CmdFlag );
+}
+
+void RepulsiveOnlyClaimer::generate_claims( DofClaims& /*new_claims*/ ) {
+}
+
+void RepulsiveOnlyClaimer::new_decoy() {
+	using namespace basic::options;
+	using namespace basic::options::OptionKeys;
+	tr.Debug << "RepulsiveOnlyClaimer::new_decoy: cst-modus: " << ( bFullatom_ ? " fullatom " : "no fullatom" )
+					 <<  ( bCentroid_ ? " centroid " : " no centroid " )
+					 << std::endl;
+	if ( bCmdFlag_ && option[ constraints::combine ].user() ) {
+		combine_ratio_ = option[ constraints::combine ]();
+	}
+
+	if ( bCmdFlag_ && ( option[ constraints::skip_redundant ]() || option[ constraints::skip_redundant_width ].user() ) ) {
+		skip_redundant_ = true;
+		skip_redundant_width_ = option[ constraints::skip_redundant_width ];
+	}
+
+
+	if ( bCmdFlag_ && option[ constraints::cst_file ].user() ) {
+		// reads and sets constraints -- this might be different each time we call this function
+		std::string old_filename = filename_;
+		filename_ = core::scoring::constraints::get_cst_file_option();
+		if ( old_filename != filename_ ) constraints_ = NULL;
+	}
+	if ( bCmdFlag_ && option[ constraints::cst_fa_file ].user() && bFullatom_ && !bCentroid_ ) {
+		std::string old_filename = filename_;
+		filename_ = core::scoring::constraints::get_cst_fa_file_option();
+		if ( old_filename != filename_ ) constraints_ = NULL;
+	}
+}
+
+
+
+void RepulsiveOnlyClaimer::add_constraints( core::pose::Pose& pose ) {
+	using namespace basic::options;
+	bool fullatom( pose.is_fullatom() );
+	if ( fullatom && !bFullatom_ ) return;
+	if ( !fullatom && !bCentroid_ ) return;
+	tr.Debug << "add constraints "<< tag_ << std::endl;
+	if ( constraints_ ) {
+		tr.Debug << " constraint set is currently for a " <<( constraint_ref_pose_.is_fullatom() ? "fullatom" : "centroid") << " pose "
+						 << "\n will now remap them to a " <<  (fullatom ? "fullatom" : "centroid") << " pose" << std::endl;
+	}
+	std::string const new_sequence ( pose.annotated_sequence( true ) );
+	if ( bCmdFlag_ && option[ OptionKeys::constraints::combine_exclude_region ].user() && combine_exclude_res_.size() == 0 && sequence_ != new_sequence ) {
+		std::string const file( option[ OptionKeys::constraints::combine_exclude_region ]() );
+		loops::LoopsFileIO loop_file_reader;
+		std::ifstream is( file.c_str() );
+
+		if (!is.good()) {
+			utility_exit_with_message( "[ERROR] Error opening RBSeg file '" + file + "'" );
+		}
+
+		loops::LoopsFileIO::SerializedLoopList loops = loop_file_reader.use_custom_legacy_file_format(is, file, false, "RIGID");
+		loops::Loops rigid_core = loops::Loops( loops );
+		combine_exclude_res_.resize( pose.total_residue(), false );
+		rigid_core.transfer_to_residue_vector( combine_exclude_res_, true );
+	}
+	if ( !constraints_ || sequence_ != new_sequence ) {
+		tr.Info << " read constraints from " << filename_ << "\n for pose " << new_sequence << "..." << std::endl;
+		constraints_ = ConstraintIO::get_instance()->read_constraints( filename_, new ConstraintSet, pose );
+		sequence_ = new_sequence;
+	} else {
+		ConstraintSetOP new_cst(NULL);
+		try {
+			new_cst = constraints_->remapped_clone( constraint_ref_pose_, pose );
+		} catch( core::id::EXCN_AtomNotFound& excn ) {
+			tr.Error << "[ERROR] failed attempt to add constraints to the "
+							 << (fullatom ? "fullatom" : "centroid") << " pose" << std::endl;
+			tr.Error << excn << std::endl;
+			if ( tr.Debug.visible() ) {
+				pose.dump_pdb("new_pose_failed_constraints.pdb");
+				constraint_ref_pose_.dump_pdb("cst_ref_pose.pdb");
+			}
+			constraints_->show_definition( tr.Error, constraint_ref_pose_ );
+			tr.Error << std::endl;
+			tr.Error << " try to recover by reading in original constraints from " << filename_ << "\n for pose " << new_sequence << "..." << std::endl;
+			new_cst = ConstraintIO::get_instance()->read_constraints( filename_, new ConstraintSet, pose );
+		}
+
+		constraints_ = new_cst;
+	}
+	constraint_ref_pose_ = pose;
+
+	scoring::constraints::ConstraintCOPs added_constraints = constraints_->get_all_constraints();
+	if ( skip_redundant_ ) scoring::constraints::skip_redundant_constraints( added_constraints, pose.total_residue(), skip_redundant_width_ );
+
+	kinematics::ShortestPathInFoldTree sp( pose.fold_tree() );
+	scoring::constraints::choose_effective_sequence_separation( sp, added_constraints );
+	scoring::constraints::combine_constraints( added_constraints, combine_ratio_, combine_exclude_res_, sp ); // if combine_ratio_ > 1 this will randomly combine constraints into multipletts with OR logic
+	pose.add_constraints( added_constraints );
+	if ( tr.Trace.visible() ) {
+		pose.constraint_set()->show_definition( tr.Trace, pose );
+	}
+
+}
+
+bool RepulsiveOnlyClaimer::read_tag( std::string tag, std::istream& is ) {
+	if ( tag == "file" || tag == "FILE" || tag == "CST_FILE" ) {
+		is >> filename_;
+	} else if ( tag == "NO_CENTROID" ) {
+		bCentroid_ = false;
+	} else if ( tag == "CENTROID" ) {
+		bCentroid_ = true;
+	} else if ( tag == "FULLATOM" ) {
+		bFullatom_ = true;
+	} else if ( tag == "SKIP_REDUNDANT" ) {
+		skip_redundant_ = true;
+		is >> skip_redundant_width_;
+		if ( !is.good() ) skip_redundant_width_ = 1;
+	} else if ( tag == "CMD_FLAG" ) {
+		bCmdFlag_ = true;
+	} else if ( tag == "COMBINE_RATIO" ) {
+		Size ratio;
+		is >> ratio;
+		combine_ratio_ = ratio;
+	} else return Parent::read_tag( tag, is );
+	return true;
+}
+
+
+} //topology_broker
+} //protocols
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.fwd.hh patched/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.fwd.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.fwd.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.fwd.hh	2012-06-10 16:12:40.263235967 +0200
@@ -0,0 +1,41 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file   core/kinematics/ShortestPathInFoldTree.fwd.hh
+/// @brief  kinematics::ShortestPathInFoldTree forward declarations header
+/// @author Oliver Lange
+
+
+#ifndef INCLUDED_protocols_topology_broker_RepulsiveOnlyClaimer_fwd_hh
+#define INCLUDED_protocols_topology_broker_RepulsiveOnlyClaimer_fwd_hh
+
+
+// Utility headers
+#include <utility/pointer/access_ptr.fwd.hh>
+#include <utility/pointer/owning_ptr.fwd.hh>
+
+
+namespace protocols {
+namespace topology_broker {
+
+// Forward
+class RepulsiveOnlyClaimer;
+
+// Types
+typedef  utility::pointer::owning_ptr< RepulsiveOnlyClaimer >  RepulsiveOnlyClaimerOP;
+typedef  utility::pointer::owning_ptr< RepulsiveOnlyClaimer const >  RepulsiveOnlyClaimerCOP;
+
+typedef  utility::pointer::access_ptr< RepulsiveOnlyClaimer >  RepulsiveOnlyClaimerAP;
+typedef  utility::pointer::access_ptr< RepulsiveOnlyClaimer const >  RepulsiveOnlyClaimerCAP;
+
+
+} // namespace kinematics
+} // namespace core
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.hh patched/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.hh	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/RepulsiveOnlyClaimer.hh	2012-06-10 16:12:40.265212019 +0200
@@ -0,0 +1,93 @@
+// -*- mode:c++;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t -*-
+// vi: set ts=2 noet:
+//
+// (c) Copyright Rosetta Commons Member Institutions.
+// (c) This file is part of the Rosetta software suite and is made available under license.
+// (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+// (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+// (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+/// @file TopologyBroker
+/// @brief  top-class (Organizer) of the TopologyBroker mechanism
+/// @detailed responsibilities:
+/// @author Oliver Lange
+
+
+#ifndef INCLUDED_protocols_topology_broker_RepulsiveOnlyClaimer_hh
+#define INCLUDED_protocols_topology_broker_RepulsiveOnlyClaimer_hh
+
+
+// Unit Headers
+#include <protocols/topology_broker/RepulsiveOnlyClaimer.fwd.hh>
+
+// Package Headers
+#include <protocols/topology_broker/TopologyClaimer.hh>
+#include <protocols/topology_broker/DofClaim.fwd.hh>
+#include <core/scoring/constraints/ConstraintSet.hh>
+
+// Project Headers
+#include <core/pose/Pose.hh>
+
+// ObjexxFCL Headers
+
+// Utility headers
+//#include <utility/io/izstream.hh>
+//#include <utility/io/ozstream.hh>
+//#include <utility/io/util.hh>
+//#include <basic/Tracer.hh>
+//#include <basic/options/option.hh>
+
+#include <utility/pointer/ReferenceCount.hh>
+
+#include <utility/vector1.hh>
+
+
+//#include <basic/options/option_macros.hh>
+
+//// C++ headers
+//#include <fstream>
+
+// option key includes
+
+
+namespace protocols {
+namespace topology_broker {
+
+class RepulsiveOnlyClaimer : public TopologyClaimer {
+	typedef TopologyClaimer Parent;
+
+public:
+	RepulsiveOnlyClaimer(); //for factory
+	RepulsiveOnlyClaimer( std::string cst_file, std::string tag = "" );
+	RepulsiveOnlyClaimer( bool CmdFlag, bool centroid = true, bool fullatom = false );
+
+	virtual TopologyClaimerOP clone() const {
+		return new RepulsiveOnlyClaimer( *this );
+	}
+
+	virtual void generate_claims( DofClaims& );
+
+	///@brief type() is specifying the output name of the TopologyClaimer
+	virtual std::string type() const {
+		return _static_type_name();
+	}
+
+	static std::string _static_type_name() {
+		return "RepulsiveOnlyClaimer";
+	}
+
+	virtual void new_decoy();
+
+	virtual bool read_tag( std::string tag, std::istream & );
+
+	virtual void add_constraints( core::pose::Pose& /*pose*/ );
+
+
+private:
+	utility::vector1< core::Size > repl_only_residues_;
+}; //class RepulsiveOnlyClaimer
+
+}
+}
+
+#endif
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/TopologyBroker.cc patched/rosetta_source/src/protocols/topology_broker/TopologyBroker.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/TopologyBroker.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/TopologyBroker.cc	2012-06-10 16:12:40.268209593 +0200
@@ -178,7 +178,7 @@ core::fragment::FragSetCOP TopologyBroke
 	return frags;
 }
 
-void TopologyBroker::add_constraints( core::pose::Pose &pose ) {
+void TopologyBroker::add_constraints( core::pose::Pose &pose ) const {
 	pose.constraint_set( NULL );
 	for ( TopologyClaimers::const_iterator top = claimers_.begin();
 					top != claimers_.end(); ++top ) {
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/TopologyBroker.hh patched/rosetta_source/src/protocols/topology_broker/TopologyBroker.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/TopologyBroker.hh	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/TopologyBroker.hh	2012-06-10 16:12:40.271240064 +0200
@@ -97,10 +97,10 @@ namespace protocols {
 namespace topology_broker {
 
 class TopologyBroker : public utility::pointer::ReferenceCount {
-	typedef utility::vector1< TopologyClaimerOP > TopologyClaimers;
 	typedef core::Size StageID;
+	typedef utility::vector1< TopologyClaimerOP > TopologyClaimers;
 public:
-
+	typedef TopologyClaimers::const_iterator const_iterator;
 	///constructor
 	TopologyBroker();
 	~TopologyBroker();
@@ -128,6 +128,14 @@ public:
 		return claimers_[i];
   }
 
+	TopologyClaimers::const_iterator begin() const {
+		return claimers_.begin();
+	}
+
+	TopologyClaimers::const_iterator end() const {
+		return claimers_.end();
+	}
+
 	/// @brief Returns the number of claimers associated with the broker
 	core::Size num_claimers() const {
 		return claimers_.size();
@@ -220,7 +228,7 @@ private:
 	void initialize_dofs( DofClaims& claims, core::pose::Pose& new_pose );
 
 	///@brief add constraints --> referred to Claimers ( e.g., ConstraintClaimer, RigidChunkClaimer )
-	void add_constraints( core::pose::Pose& );
+	void add_constraints( core::pose::Pose& ) const;
 
 private:
 	///@brief vector of Claimers --- RigidChunkClaimer, FragmentClaimer, ConstraintClaimer, etc.
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/TopologyClaimerFactory.cc patched/rosetta_source/src/protocols/topology_broker/TopologyClaimerFactory.cc
--- vanilla/rosetta_source/src/protocols/topology_broker/TopologyClaimerFactory.cc	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/TopologyClaimerFactory.cc	2012-06-06 11:38:07.193039992 +0200
@@ -29,11 +29,8 @@
 #include <protocols/topology_broker/StartStructClaimer.hh>
 #include <protocols/topology_broker/CutBiasClaimer.hh>
 #include <protocols/topology_broker/DensityScoringClaimer.hh>
-#include <protocols/topology_broker/FoldandDockClaimer.hh>
-#include <protocols/topology_broker/AsymFoldandDockClaimer.hh>
 #include <protocols/topology_broker/PseudocontactShiftEnergyController.hh>
 #include <protocols/topology_broker/PcsEnergyController.hh>
-#include <protocols/topology_broker/FibrilModelingClaimer.hh>
 
 // Utility headers
 #include <basic/Tracer.hh>
@@ -70,9 +67,9 @@ TopologyClaimerFactory::TopologyClaimerF
 	add_type(new DensityScoringClaimer());
 	add_type(new PseudocontactShiftEnergyController());
 	add_type(new PcsEnergyController());
-	add_type(new FoldandDockClaimer());
-	add_type(new FibrilModelingClaimer());
-	add_type(new AsymFoldandDockClaimer());
+//	add_type(new FoldandDockClaimer());
+//	add_type(new FibrilModelingClaimer());
+//	add_type(new AsymFoldandDockClaimer());
 }
 
 TopologyClaimerFactory::~TopologyClaimerFactory() {
diff -rupN vanilla/rosetta_source/src/protocols/topology_broker/TopologyClaimer.hh patched/rosetta_source/src/protocols/topology_broker/TopologyClaimer.hh
--- vanilla/rosetta_source/src/protocols/topology_broker/TopologyClaimer.hh	2012-03-20 19:43:17.000000000 +0100
+++ patched/rosetta_source/src/protocols/topology_broker/TopologyClaimer.hh	2012-06-10 16:12:40.274040388 +0200
@@ -116,7 +116,7 @@ public:
 	}
 
 	///@brief add constraints to pose...  might make this stage dependent as with movers...
-	virtual void add_constraints( core::pose::Pose& /*pose*/ ) {};//some constraints are loaded...
+	virtual void add_constraints( core::pose::Pose& /*pose*/ ) const {};//some constraints are loaded...
 
 	///@brief return fragments that can be used for loop-sampling... unfortunately some loop-samplers need fragments, rather then fragmovers
 	/// (e.g. short-loop closure since it remaps them on a short pose containing only the loop-residues. )
diff -rupN vanilla/rosetta_source/src/protocols.1.src.settings patched/rosetta_source/src/protocols.1.src.settings
--- vanilla/rosetta_source/src/protocols.1.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols.1.src.settings	2012-06-06 11:41:45.274040919 +0200
@@ -78,6 +78,8 @@ sources = {
 		"ArchiveManager",
 		"EvaluatedArchive",
 		"MPIArchiveJobDistributor",
+		"NormalizedEvaluatedArchive",
+                "VarianceStatisticsArchive",
 	],
 	"protocols/jd2/parser": [
 		"BluePrint",
diff -rupN vanilla/rosetta_source/src/protocols.3.src.settings patched/rosetta_source/src/protocols.3.src.settings
--- vanilla/rosetta_source/src/protocols.3.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols.3.src.settings	2012-06-06 11:36:27.676956393 +0200
@@ -290,8 +290,8 @@ sources = {
 		"WobbleMover",
 	],
 	"protocols/simple_moves/asym_fold_and_dock": [
-		"AsymFoldandDockMoveRbJumpMover",
-		"AsymFoldandDockRbTrialMover",
+#		"AsymFoldandDockMoveRbJumpMover",
+#		"AsymFoldandDockRbTrialMover",
 	],
 	"protocols/simple_moves/rational_mc": [
 		"RationalMonteCarlo",
diff -rupN vanilla/rosetta_source/src/protocols.6.src.settings patched/rosetta_source/src/protocols.6.src.settings
--- vanilla/rosetta_source/src/protocols.6.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols.6.src.settings	2012-06-06 01:01:44.468982750 +0200
@@ -10,160 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-"protocols/enzdes": [
-	"AddorRemoveCsts",
-	"BackboneSampler",
-	"DesignVsNativeComparison",
-	"enzdes_util",
-	"EnzdesBaseProtocol",
-	"EnzdesFixBBProtocol",
-	"EnzdesFlexBBProtocol",
-	"EnzdesJobInputter",
-	"EnzdesJobOutputter",
-	"EnzdesMovers",
-	"EnzdesTaskOperations",
-	"EnzFilters",
-	"EnzRepackMinimize",
-	"ModifyStoredLigandRBConfsMovers",
-	"SecondaryMatchProtocol",
-],
-"protocols/hotspot_hashing": [
-	"HotspotStub",
-"HotspotStubSet",
-],
-"protocols/match": [
-	"BumpGrid",
-	"Hit",
-	"Matcher",
-	"MatcherMover",
-	"MatcherTask",
-	"MatchPositionModifiers",
-	"MatchSet",
-	"OccupiedSpaceHash",
-	"VoxelSetIterator",
-],
-"protocols/match/downstream": [
-	"ActiveSiteGrid",
-	"ClassicMatchAlgorithm",
-	"DownstreamAlgorithm",
-	"DownstreamBuilder",
-	"GeometrySecMatchRPE",
-	"LigandConformerBuilder",
-	"RigidLigandBuilder",
-	"ScoringSecMatchRPE",
-	"SecMatchEvaluatorFactory",
-	"SecMatchResiduePairEvaluator",
-	"SecondaryMatcherToDownstreamResidue",
-	"SecondaryMatcherToUpstreamResidue",
-],
-"protocols/match/output": [
-	"DownstreamRMSEvaluator",
-	"LimitHitsPerRotamerFilter",
-	"MatchConsolidator",
-	"MatchEvaluator",
-	"MatchFilter",
-	"MatchGrouper",
-	"MatchOutputter",
-	"MatchProcessor",
-	"OutputWriter",
-	"PDBWriter",
-	"PoseInserter",
-	"ProcessorFactory",
-	"SameChiBinComboGrouper",
-	"SameRotamerComboGrouper",
-	"SameSequenceGrouper",
-	"UpstreamCollisionFilter",
-	"UpstreamDownstreamCollisionFilter",
-	"UpstreamHitCacher",
-	"WriteKinemageOutputter",
-	"WriteUpstreamCoordinateKineamge",
-],
-"protocols/match/upstream": [
-	"OriginalScaffoldBuildPoint",
-	"ProteinSCSampler",
-	"ProteinUpstreamBuilder",
-	"ScaffoldBuildPoint",
-	"UpstreamBuilder",
-	"UpstreamResTypeGeometry",
-],
-	"protocols/protein_interface_design": [
-		"design_utils",
-		"DockDesignFilterFactory",
-		"ParserJobInputter",
-		"read_patchdock",
-		"ReportPSSMDifference",
-		"util",
-	],
-	"protocols/protein_interface_design/filters": [
-		"AverageDegreeFilter",
-		"BindingStrainFilter",
-		"BoltzmannFilter",
-		"DeltaFilter",
-		"DesignableResiduesFilter",
-		"DisulfideFilter",
-		"FilterScan",
-		"HbondsToResidueFilter",
-		"InterfaceHolesFilter",
-		"RelativePoseFilter",
-		"RelativeSegmentFilter",
-		"RmsdFilter",
-		"SequenceRecoveryFilter",
-		"StubScoreFilter",
-		"TorsionFilter",
-	],
-	"protocols/protein_interface_design/movers": [
-		"AddChainBreak",
-		"AddSidechainConstraintsToHotspots",
-		"BackrubDDMover",
-		"BestHotspotCstMover",
-		"BuildAlaPose",
-		"DesignMinimizeHbonds",
-		"DisulfideMover",
-		"DockAndRetrieveSidechains",
-		"DumpPdb",
-		"FavorNativeResiduePreCycle",
-		"FavorNonNativeResiduePreCycle",
-		"HotspotDisjointedFoldTreeMover",
-		"HotspotHasherMover",
-		"InterfaceRecapitulationMover",
-		"LoopFinder",
-		"LoopLengthChange",
-		"LoopMoverFromCommandLine",
-		"LoopOver",
-		"LoopRemodel",
-		"MapHotspot",
-		"PeptideStapleDesignMover",
-		"PlacementAuctionMover",
-		"PlacementMinimizationMover",
-		"PlaceOnLoop",
-		"PlaceSimultaneouslyMover",
-		"PlaceStubMover",
-		"PlaceUtils",
-		"PrepackMover",
-		"ProteinInterfaceMultiStateDesignMover",
-		"RandomMutation",
-		"RepackMinimize",
-		"SaveAndRetrieveSidechains",
-		"SetAtomTree",
-		"SetTemperatureFactor",
-		"SetupHotspotConstraintsMover",
-		"SpinMover",
-		"SubroutineMover",
-		"TaskAwareCsts",
-		"TryRotamers",
-		"VLB",
-	],
-"protocols/seeded_abinitio": [
-	"CAcstGenerator",
-	"CloseFold",
-	"CoordinateCst",
-	"DefineMovableLoops",
-	"GrowPeptides",
-	"SeededAbinitio_util",
-	"SeedFoldTree",
-	"SeedSetupMover",
-	"SwapSegment",
-],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols.7.src.settings patched/rosetta_source/src/protocols.7.src.settings
--- vanilla/rosetta_source/src/protocols.7.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols.7.src.settings	2012-06-06 01:18:56.769988647 +0200
@@ -21,7 +21,6 @@ library_path = [
 libraries = [
 ]
 subprojects = [
-	"protocols.6",
 	"protocols_f.5",
 	"protocols_e.5",
 	"protocols_d.5",
diff -rupN vanilla/rosetta_source/src/protocols_a.4.src.settings patched/rosetta_source/src/protocols_a.4.src.settings
--- vanilla/rosetta_source/src/protocols_a.4.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_a.4.src.settings	2012-06-06 11:16:51.198039769 +0200
@@ -10,63 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/anchored_design": [
-		"Anchor",
-		"AnchorMovers",
-		"AnchorMoversData",
-	],
-	"protocols/dna": [
-		"DesignProteinBackboneAroundDNA",
-		"DnaChains",
-		"DnaDesignDef",
-		"DnaInterfaceFinder",
-		"DnaInterfaceMinMover",
-		"DnaInterfaceMultiStateDesign",
-		"DnaInterfacePacker",
-		"PDBOutput",
-		"RestrictDesignToProteinDNAInterface",
-		"RotamerDNAHBondFilter",
-		"SeparateDnaFromNonDna",
-		"util",
-		"WatsonCrickRotamerCouplings",
-	],
-	"protocols/motifs": [
-		"BuildPosition",
-		"IRCollection",
-		"LigandMotifSearch",
-		"Motif",
-		"motif_utils",
-		"MotifDnaPacker",
-		"MotifHit",
-		"MotifLibrary",
-		"MotifSearch",
-		"SingleMotif",
-	],
-	"protocols/multistate_design": [
-		"MetricCalculatorFitnessFunction",
-		"MultiStateAggregateFunction",
-		"MultiStateEntity",
-		"MultiStateFitnessFunction",
-		"MultiStatePacker",
-		"PackingState",
-		"PartitionAggregateFunction",
-		"SingleState",
-		"SingleStateEntityData",
-		"SingleStateFitnessFunction",
-		"util",
-	],
-	"protocols/pack_daemon": [
-		"DynamicAggregateFunction",
-		"EntityCorrespondence",
-		"MultistateAggregateFunction",
-		"MultistateFitnessFunction",
-		"PackDaemon",
-	],
-	"protocols/vip": [
-		"VIP_Mover",
-		"VIP_Report",
-		"VIP_Utils",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_a.5.src.settings patched/rosetta_source/src/protocols_a.5.src.settings
--- vanilla/rosetta_source/src/protocols_a.5.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_a.5.src.settings	2012-06-06 10:54:42.009039821 +0200
@@ -10,29 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/antibody": [
-		"AntibodyClass",
-		"AntibodyModeler",
-		"CDRH3Modeler",
-		"GraftMover",
-		"Ubiquitin_E2C_Modeler",
-	],
-	"protocols/antibody2": [
-                "Ab_TemplateInfo",
-                "Ab_Info",
-                "Ab_Assemble_Templates",
-                "Ab_GraftOneCDR_Mover",
-                "Ab_CloseOneCDR_Mover",
-                "Ab_RelaxCDRs_Mover",
-		"Ab_ModelCDRH3",
-		"Ab_H3_cter_insert_mover",
-                "CDRH3Modeler2",
-		"Ab_LH_RepulsiveRamp_Mover",
-		"Ab_LH_SnugFit_Mover",
-		"Ab_util",
-		"Ab_Relax_a_CDR_FullAtom",
-		"Ab_H3_perturb_ccd_build",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_b.4.src.settings patched/rosetta_source/src/protocols_b.4.src.settings
--- vanilla/rosetta_source/src/protocols_b.4.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_b.4.src.settings	2012-06-06 11:17:08.970985838 +0200
@@ -14,52 +14,6 @@ sources = {
 		"APCluster",
 		"cluster",
 	],
-	"protocols/forge/build": [
-		"Bridge",
-		"BuildInstruction",
-		"BuildManager",
-		"ConnectRight",
-		"GrowLeft",
-		"GrowRight",
-		"RelativeConnectRight",
-		"SegmentInsert",
-		"SegmentRebuild",
-		"SegmentSwap",
-	],
-	"protocols/forge/components": [
-		"BDR",
-		"VarLengthBuild",
-	],
-	"protocols/forge/constraints": [
-		"ConstraintFileRCG",
-		"InverseRotamersRCG",
-		"NtoC_RCG",
-	],
-	"protocols/forge/methods": [
-		"chainbreak_eval",
-		"fold_tree_functions",
-		"fragment_functions",
-		"pose_mod",
-		"util",
-	],
-	"protocols/forge/remodel": [
-		"RemodelAccumulator",
-		"RemodelConstraintGenerator",
-		"RemodelData",
-		"RemodelDesignMover",
-		"RemodelEnzdesCstModule",
-		"RemodelLoopMover",
-		"RemodelMover",
-		"RemodelRotamerLinks",
-		"RemodelWorkingSet",
-		"ResidueVicinityRCG",
-	],
-	"protocols/pockets": [
-		"Fingerprint",
-		"FingerprintMultifunc",
-		"PocketConstraint",
-		"PocketGrid",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_b.5.src.settings patched/rosetta_source/src/protocols_b.5.src.settings
--- vanilla/rosetta_source/src/protocols_b.5.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_b.5.src.settings	2012-06-06 11:44:35.734039805 +0200
@@ -76,27 +76,8 @@ sources = {
 		"StructureIndependentPeakCalibrator",
 		"util",
 	],
-        "protocols/surface_docking": [
-                "CentroidRelaxMover",
-                "FullatomRelaxMover",
-                "SlideIntoSurface",
-                "SurfaceDockingProtocol",
-                "SurfaceOrientMover",
-                "SurfaceParameters",
-        ],
-	"protocols/symmetric_docking": [
-		"SymDockBaseProtocol",
-		"SymDockingHiRes",
-		"SymDockingLowRes",
-		"SymDockProtocol",
-		"SymFoldandDockMoveRbJumpMover",
-		"SymFoldandDockRbTrialMover",
-		"SymFoldandDockSlideTrialMover",
-		"SymRestrictTaskForDocking",
-		"SymSidechainMinMover",
-	],
 	"protocols/topology_broker": [
-		"AsymFoldandDockClaimer",
+		#"AsymFoldandDockClaimer",
 		"ClaimerMessage",
 		"ConstraintClaimer",
 		"CoordConstraintClaimer",
@@ -104,8 +85,9 @@ sources = {
 		"DensityScoringClaimer",
 		"DisulfJumpClaimer",
 		"DofClaim",
-		"FibrilModelingClaimer",
-		"FoldandDockClaimer",
+		"ConstraintEvaluatorWrapper",	
+#	"FibrilModelingClaimer",
+	#	"FoldandDockClaimer",
 		"FragmentClaimer",
 		"JumpClaimer",
 		"LoopFragmentClaimer",
diff -rupN vanilla/rosetta_source/src/protocols_c.4.src.settings patched/rosetta_source/src/protocols_c.4.src.settings
--- vanilla/rosetta_source/src/protocols_c.4.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_c.4.src.settings	2012-06-06 11:17:20.397039686 +0200
@@ -10,102 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/features": [
-		"AtomAtomPairFeatures",
-		"AtomAtomPairFeaturesCreator",
-		"AtomInResidueAtomInResiduePairFeatures",
-		"AtomInResidueAtomInResiduePairFeaturesCreator",
-		"AtomTypesFeatures",
-		"AtomTypesFeaturesCreator",
-		"BetaTurnDetectionFeatures",
-		"BetaTurnDetectionFeaturesCreator",
-		"DatabaseFilters",
-		"DatabaseJobInputter",
-		"DatabaseJobOutputter",
-		"DatabaseStatements",
-		"FeaturesReporter",
-		"FeaturesReporterFactory",
-		"GeometricSolvationFeatures",
-		"GeometricSolvationFeaturesCreator",
-		"HBondFeatures",
-		"HBondFeaturesCreator",
-		"HBondParameterFeatures",
-		"HBondParameterFeaturesCreator",
-		"JobDataFeatures",
-		"JobDataFeaturesCreator",
-		"LoopAnchorFeatures",
-		"LoopAnchorFeaturesCreator",
-		"OrbitalsFeatures",
-		"OrbitalsFeaturesCreator",
-		"PairFeatures",
-		"PairFeaturesCreator",
-		"PdbDataFeatures",
-		"PdbDataFeaturesCreator",
-		"PoseCommentsFeatures",
-		"PoseCommentsFeaturesCreator",
-		"PoseConformationFeatures",
-		"PoseConformationFeaturesCreator",
-		"ProteinBackboneAtomAtomPairFeatures",
-		"ProteinBackboneAtomAtomPairFeaturesCreator",
-		"ProteinBackboneTorsionAngleFeatures",
-		"ProteinBackboneTorsionAngleFeaturesCreator",
-		"ProteinResidueConformationFeatures",
-		"ProteinResidueConformationFeaturesCreator",
-		"ProteinRMSDFeatures",
-		"ProteinRMSDFeaturesCreator",
-		"ProteinSilentReport",
-		"ProtocolFeatures",
-		"ProtocolFeaturesCreator",
-		"RadiusOfGyrationFeatures",
-		"RadiusOfGyrationFeaturesCreator",
-		"Report",
-		"ReportToDB",
-		"ResidueBurialFeatures",
-		"ResidueBurialFeaturesCreator",
-		"ResidueConformationFeatures",
-		"ResidueConformationFeaturesCreator",
-		"ResidueFeatures",
-		"ResidueFeaturesCreator",
-		"ResidueScoresFeatures",
-		"ResidueScoresFeaturesCreator",
-		"ResidueSecondaryStructureFeatures",
-		"ResidueSecondaryStructureFeaturesCreator",
-		"ResidueTypesFeatures",
-		"ResidueTypesFeaturesCreator",
-		"RotamerBoltzmannWeightFeatures",
-		"RotamerBoltzmannWeightFeaturesCreator",
-		"RotamerRecoveryFeatures",
-		"RotamerRecoveryFeaturesCreator",
-		"SaltBridgeFeatures",
-		"SaltBridgeFeaturesCreator",
-		"ScoreTypeFeatures",
-		"ScoreTypeFeaturesCreator",
-		"StructureFeatures",
-		"StructureFeaturesCreator",
-		"StructureScoresFeatures",
-		"StructureScoresFeaturesCreator",
-	],
-	"protocols/features/helixAssembly": [
-		"HelixBundleFeatures",
-		"HelixBundleFeaturesCreator",
-		"HelicalFragment",
-	],
-	"protocols/rotamer_recovery": [
-		"RotamerRecovery",
-		"RotamerRecoveryCreator",
-		"RotamerRecoveryFactory",
-		"RotamerRecoveryMover",
-		"RRComparer",
-		"RRComparerAutomorphicRMSD",
-		"RRProtocol",
-		"RRProtocolReferenceStructure",
-		"RRProtocolMinPack",
-		"RRProtocolMover",
-		"RRProtocolRTMin",
-		"RRReporter",
-		"RRReporterHuman",
-		"RRReporterSQLite",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_c.5.src.settings patched/rosetta_source/src/protocols_c.5.src.settings
--- vanilla/rosetta_source/src/protocols_c.5.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_c.5.src.settings	2012-06-06 10:55:12.767041144 +0200
@@ -10,27 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/flexpep_docking": [
-		"FlexPepDockingAbInitio",
-		"FlexPepDockingFlags",
-		"FlexPepDockingLowRes",
-		"FlexPepDockingPoseMetrics",
-		"FlexPepDockingProtocol",
-	],
-	"protocols/loophash": [
-		"BackboneDB",
-		"FastGapMover",
-		"LocalInserter",
-		"LoopHashLibrary",
-		"LoopHashMap",
-		"LoopHashMoverWrapper",
-		"LoopHashSampler",
-		"Mover_LoopHashRefine",
-		"MPI_LoopHashRefine",
-		"MPI_LoopHashRefine_Emperor",
-		"MPI_LoopHashRefine_Master",
-		"WorkUnit_LoopHash",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_d.4.src.settings patched/rosetta_source/src/protocols_d.4.src.settings
--- vanilla/rosetta_source/src/protocols_d.4.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_d.4.src.settings	2012-06-06 11:17:29.965039715 +0200
@@ -10,15 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/cartesian": [
-		"md",
-	],
-	"protocols/unfolded_state_energy_calculator": [
-		"UnfoldedStateEnergyCalculatorJobDistributor",
-		"UnfoldedStateEnergyCalculatorMover",
-		"UnfoldedStateEnergyCalculatorMPIWorkPoolJobDistributor",
-		"UnfoldedStateEnergyCalculatorUtil",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_d.5.src.settings patched/rosetta_source/src/protocols_d.5.src.settings
--- vanilla/rosetta_source/src/protocols_d.5.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_d.5.src.settings	2012-06-06 10:55:27.783043292 +0200
@@ -10,83 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/coarse_rna": [
-		"CoarseRNA_DeNovoProtocol",
-		"CoarseRNA_Fragments",
-		"CoarseRNA_LoopCloser",
-	],
-	"protocols/rna": [
-		"FullAtomRNA_Fragments",
-		"MultipleDomainMover",
-		"RNA_BasePairClassifier",
-		"RNA_ChunkLibrary",
-		"RNA_DataReader",
-		"RNA_DeNovoProtocol",
-		"RNA_FragmentMover",
-		"RNA_Fragments",
-		"RNA_HelixAssembler",
-		"RNA_JumpLibrary",
-		"RNA_LoopCloser",
-		"RNA_Minimizer",
-		"RNA_ProtocolUtil",
-		"RNA_Relaxer",
-		"RNA_SecStructInfo",
-		"RNA_StructureParameters",
-	],
-	"protocols/swa": [
-		"InputStreamWithResidueInfo",
-		"PoseFilter_RMSD_Screen",
-		"RigidBodySampler",
-		"StepWiseClusterer",
-		"StepWiseCombineSampleGenerator",
-		"StepWiseDoNothingSampleGenerator",
-		"StepWiseIdentitySampleGenerator",
-		"StepWiseJobParameters",
-		"StepWisePoseCombineSampleGenerator",
-		"StepWisePoseSetup",
-		"StepWiseUtil",
-	],
-	"protocols/swa/protein": [
-		"MainChainTorsionSet",
-		"StepWiseBetaAntiParallelJumpSampleGenerator",
-		"StepWiseBetaAntiParallelUtil",
-		"StepWiseProteinCCD_Closer",
-		"StepWiseProteinFilterer",
-		"StepWiseProteinFragmentSampleGenerator",
-		"StepWiseProteinJumpSampleGenerator",
-		"StepWiseProteinLoopBridger",
-		"StepWiseProteinMainChainSampleGenerator",
-		"StepWiseProteinPacker",
-		"StepWiseProteinPoseMinimizer",
-		"StepWiseProteinPoseSetup",
-		"StepWiseProteinResidueSampler",
-		"StepWiseProteinScreener",
-		"StepWiseProteinUtil",
-	],
-
-	"protocols/swa/rna": [
-		"StepWiseRNA_BaseCentroidScreener",
-		"StepWiseRNA_Base_Sugar_Rotamer",
-		"StepWiseRNA_Clusterer",
-		"StepWiseRNA_CombineLongLoopFilterer", 
-		"StepWiseRNA_FloatingBase_Sampler_Util",
-		"StepWiseRNA_JobParameters_Setup",
-		"StepWiseRNA_JobParameters",
-		"StepWiseRNA_Minimizer",
-		"StepWiseRNA_OutputData", 
-		"StepWiseRNA_PoseSetup",
-		"StepWiseRNA_ResidueInfo",
-		"StepWiseRNA_ResidueSampler",
-		"StepWiseRNA_RotamerGenerator",
-		"StepWiseRNA_RotamerGenerator_Wrapper",
-		"StepWiseRNA_Util",
-		"StepWiseRNA_VDW_Bin_Screener",
-		"StepWiseRNA_VirtualRiboseSampler", 
-		"RNA_AnalyticLoopCloser",
-		"RNA_LoopCloseSampler",
-		"StepWiseRNA_AnalyticalLoopCloseSampler",
-	],
-
 
 }
 include_path = [
diff -rupN vanilla/rosetta_source/src/protocols_e.4.src.settings patched/rosetta_source/src/protocols_e.4.src.settings
--- vanilla/rosetta_source/src/protocols_e.4.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_e.4.src.settings	2012-06-06 11:17:36.964039659 +0200
@@ -10,10 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/pmut_scan": [
-		"Mutant",
-		"PointMutScanDriver",
-	],
 	"protocols/sparta": [
 		"ANN",
 		"ChemicalShiftEvaluator",
diff -rupN vanilla/rosetta_source/src/protocols_e.5.src.settings patched/rosetta_source/src/protocols_e.5.src.settings
--- vanilla/rosetta_source/src/protocols_e.5.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_e.5.src.settings	2012-06-06 10:55:36.873039582 +0200
@@ -10,38 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/medal": [
-		"MedalExchangeMover",
-		"MedalMain",
-		"MedalMover",
-		"util",
-	],
-	"protocols/nonlocal": [
-		"BiasedFragmentMover",
-		"Chunk",
-		"HelixRotate",
-		"PolicyFactory",
-		"Region",
-		"SheetTranslate",
-		"SimpleTreeBuilder",
-		"SingleFragmentMover",
-		"SingleFragmentMoverCreator",
-		"SmoothPolicy",
-		"StarTreeBuilder",
-		"TreeBuilderFactory",
-		"UniformPolicy",
-		"util",
-	],
-	"protocols/star" : [
-                "Extender",
-		"StarAbinitio",
-                "StarAbinitioMain",
-                "util",
-	],
-	"protocols/frag_picker/nonlocal": [
-		"NonlocalFrags",
-		"NonlocalFragsMain",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_f.4.src.settings patched/rosetta_source/src/protocols_f.4.src.settings
--- vanilla/rosetta_source/src/protocols_f.4.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_f.4.src.settings	2012-06-06 11:17:50.332039611 +0200
@@ -10,33 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/contact_map": [
-		"ContactMap",
-	],
-	"protocols/ddg": [
-		"ddG_main",
-		"ddGData",
-		"ddGMover",
-	],
-	"protocols/kinmatch": [
-		"FunGroupTK",
-	],
-	"protocols/make_rot_lib": [
-		"MakeRotLib",
-		"RotData",
-	],
-	"protocols/optimize_weights": [
-		"DDGBindOptEData",
-		"DGBindOptEData",
-		"IterativeOptEDriver",
-		"NestedEnergyTermOptEData",
-		"OptEData",
-		"OptEMultifunc",
-		"PNatLigPoseOptEData",
-	],
-	"protocols/RotamerDump": [
-		"RotamerDumpMover",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_f.5.src.settings patched/rosetta_source/src/protocols_f.5.src.settings
--- vanilla/rosetta_source/src/protocols_f.5.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_f.5.src.settings	2012-06-06 00:20:32.158040100 +0200
@@ -10,59 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/fldsgn": [
-		"BluePrintBDR",
-		"CircularPermutation",
-		"NcontactsCalculator",
-		"SheetConstraintsRCG",
-	],
-	"protocols/fldsgn/filters": [
-		"CoreDunbrackFilter",
-		"FragQualFilter",
-		"HelixKinkFilter",
-		"HelixPairingFilter",
-		"HSSTripletFilter",
-		"InterlockingAromaFilter",
-		"NcontactsFilter",
-		"ParallelBetaPairingPreferenceFilter",
-		"SecondaryStructureFilter",
-		"SheetTopologyFilter",
-	],
-	"protocols/fldsgn/potentials": [
-		"AACompositionEnergy",
-		"SetAACompositionPotential",
-		"SetSecStructEnergies",
-	],
-	"protocols/fldsgn/potentials/sspot": [
-		"HSPairPotential",
-		"NatbiasHelicesSheetPotential",
-		"NatbiasHelixPairPotential",
-		"NatbiasSecondaryStructureEnergy",
-		"NatbiasStrandPairPotential",
-		"SSPairPotential",
-		"util",
-	],
-	"protocols/fldsgn/topology": [
-		"BB_Pos",
-		"BetaAlphaBetaMotif",
-		"DimerPairing",
-		"HelixPairing",
-		"HSSTriplet",
-		"Sheet",
-		"SheetFoldTypeManager",
-		"SS_Info2",
-		"StrandPairing",
-		"util",
-	],
-	"protocols/flxbb": [
-		"DesignTask",
-		"FilterStructs",
-		"FlxbbDesign",
-		"FlxbbDesign_main",
-		"InterlockAroma",
-		"LayerDesignOperation",
-		"utility",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_g.4.src.settings patched/rosetta_source/src/protocols_g.4.src.settings
--- vanilla/rosetta_source/src/protocols_g.4.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_g.4.src.settings	2012-06-06 11:18:12.027040504 +0200
@@ -50,21 +50,6 @@ sources = {
 		"WeightedFragmentTrialMover",
 		"util",
 	],
-	"protocols/domain_assembly": [
-		"AddAssemblyConstraints",
-		"AssembleLinkerMover",
-		"CombineChainsMover",
-		"PostDockAssemblyScorer",
-	],
-	"protocols/rbsegment_relax": [
-		"AutoRBRelaxMover",
-		"FragInsertAndAlignMover",
-		"RBSegment",
-		"RBSegmentMover",
-		"RBSegmentRelax",
-		"RBSegmentRelax_main",
-		"util",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/protocols_h.4.src.settings patched/rosetta_source/src/protocols_h.4.src.settings
--- vanilla/rosetta_source/src/protocols_h.4.src.settings	2012-03-20 19:44:23.000000000 +0100
+++ patched/rosetta_source/src/protocols_h.4.src.settings	2012-06-06 10:53:50.722040144 +0200
@@ -10,94 +10,6 @@
 ########### KEEP DIRECTORIES AND FILES IN ALPHABETICAL ORDER ###########
 
 sources = {
-	"protocols/docking": [
-		"ConformerSwitchMover",
-		"DockFilters",
-		"DockingEnsemble",
-		"DockingEnsemblePrepackProtocol",
-		"DockingHighRes",
-		"DockingHighResLegacy",
-		"DockingInitialPerturbation",
-		"DockingLowRes",
-		"DockingPrepackProtocol",
-		"DockingProtocol",
-		"DockMCMCycle",
-		"DockMCMProtocol",
-		"DockMinMover",
-		"DockSetupMover",
-		"DockTaskFactory",
-		"metrics",
-		"SidechainMinMover",
-		"TemperedDocking",
-		"util",
-	],
-	"protocols/docking/stateless": [
-		"SaneDockingProtocol",
-	],
-	"protocols/ligand_docking": [
-		"AddHydrogen",
-		"AddHydrogens",
-		"AtomCountFilter",
-		"CompleteConnectionsFilter",
-		"CompoundTranslate",
-		"DistributionMap",
-		"FinalMinimizer",
-		"grid_functions",
-		"GrowLigand",
-		"HBondAcceptorFilter",
-		"HBondDonorFilter",
-		"HeavyAtomFilter",
-		"HighResDocker",
-		"InterfaceBuilder",
-		"InterfaceScoreCalculator",
-		"ligand_dock_impl",
-		"ligand_functions",
-		"ligand_scores",
-		"LigandArea",
-		"LigandBaseProtocol",
-		"LigandDesign",
-		"LigandDockingLoaders",
-		"LigandDockProtocol",
-		"MinimizeBackbone",
-		"MinimizeLigand",
-		"MoveMapBuilder",
-		"RandomConformerMover",
-		"RandomConformers",
-		"ResidueTorsionRestraints",
-		"RigidSearchMover",
-		"Rotate",
-		"Rotates",
-		"SlideTogether",
-		"StartFrom",
-		"TetherLigand",
-		"Transform",
-		"Translate",
-		"UnconstrainedTorsionsMover",
-	],
-	"protocols/ligand_docking/ligand_options": [
-		"Interface",
-		"interface_distance_functions",
-	],
-	"protocols/qsar": [
-		"qsarMap",
-		"qsarMover",
-		"qsarOptFunc",
-		"RenderGridsToKinemage",
-	],
-	"protocols/qsar/scoring_grid": [
-		"AtrGrid",
-		"GridBase",
-		"GridCreator",
-		"GridFactory",
-		"GridManager",
-        "ClassicGrid",
-		"HbaGrid",
-		"HbdGrid",
-		"polarizGrid",
-		"RepGrid",
-		"ScoringGridLoader",
-		"VdwGrid",
-	],
 }
 include_path = [
 ]
diff -rupN vanilla/rosetta_source/src/utility/io/mpistream.ipp patched/rosetta_source/src/utility/io/mpistream.ipp
--- vanilla/rosetta_source/src/utility/io/mpistream.ipp	2012-03-20 19:43:02.000000000 +0100
+++ patched/rosetta_source/src/utility/io/mpistream.ipp	2012-06-10 16:12:40.187039743 +0200
@@ -31,10 +31,10 @@ namespace mpi_stream {
 		typename ByteAT
 	>
 	basic_mpi_streambuf< Elem, Tr, ElemA, ByteT, ByteAT >::basic_mpi_streambuf(
-    std::string filename,
+    std::string MPI_ONLY( filename ),
 		size_t buffer_size_,
 		int master_rank,
-		bool append
+		bool MPI_ONLY( append )
 	) :	m_buffer( buffer_size_, 0 ), master_rank_( master_rank )
 	{
 		//find channel_id_;
Binary files vanilla/rosetta_source/tools/build/__init__.pyc and patched/rosetta_source/tools/build/__init__.pyc differ
Binary files vanilla/rosetta_source/tools/build/nvcc.pyc and patched/rosetta_source/tools/build/nvcc.pyc differ
Binary files vanilla/rosetta_source/tools/build/settings.pyc and patched/rosetta_source/tools/build/settings.pyc differ
Binary files vanilla/rosetta_source/tools/build/setup_platforms.pyc and patched/rosetta_source/tools/build/setup_platforms.pyc differ
diff -rupN vanilla/rosetta_source/tools/build/site.settings patched/rosetta_source/tools/build/site.settings
--- vanilla/rosetta_source/tools/build/site.settings	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/tools/build/site.settings	2012-06-08 12:03:47.598099112 +0200
@@ -0,0 +1,101 @@
+# -*- mode:python;indent-tabs-mode:nil;show-trailing-whitespace:t; -*-
+#
+# Copy this file into site.settings:
+#
+#   cp site.settings.template site.settings
+#
+# and customize to fit your site's environment
+# DO NOT make changes to this template
+# DO NOT try and check in site.settings
+# (c) Copyright Rosetta Commons Member Institutions.
+# (c) This file is part of the Rosetta software suite and is made available under license.
+# (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+# (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+# (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+
+# Settings here are added to the combined build settings, after all basic
+# settings, to allow you to override anything you need to.  They can in turn
+# be overriden by user settings and project settings respectively.
+#
+# Typically you want to prepend to one of the settings listed to expand your
+# paths, but you can also append, override, or remove settings.
+#
+# NOTE: At some point this file will allow you to have multiple site settings
+# to select between.  For now there is only the "site" settings.
+import os
+openmpiversion="1.4.2"
+root="/cm/shared/apps/openmpi/open64/64/"+openmpiversion
+root2="/cm/shared/apps/openmpi/gcc/64/"+openmpiversion
+root3="/cm/shared/apps/gcc/4.3.4/"
+
+settings = {
+    "gcc, mpi" : { 
+	"overrides" : {
+	   "cxx" : "mpicxx"
+        },
+        "appends" : {
+            "defines"       : [ "USEMPI" ],
+        },
+    },	 	
+     
+	   
+    "site" : {
+        "prepends" : {
+            "program_path" : [
+                "/home/lange/bin/"
+            ],
+
+         },
+        "appends" : {
+
+            # Location of standard and system binaries
+#            "program_path" : [
+         #       root+"/bin",
+         #       root2+"/bin",
+                # Path to GCC compiler if not in the os rule
+                # Path to Intel C++ compiler if not in the os rule
+ #           ],
+            # Location of standard and system header files if not in the os rule
+            "include_path" : [
+                #
+            ],
+            # Location of standard and system libraries if not in the os rule.
+            "library_path" : [
+ #                root+"/lib64",
+ ##               root2+"/lib",
+ #               root2+"/lib64",
+ #               root3+"/lib",
+ #               root3+"/lib64",
+#$/cm/shared/apps/gcc/4.3.4/lib:
+ #               /cm/shared/apps/gcc/4.3.4/lib64:/
+                #
+            ],
+        },
+        "removes" : {
+		"library_path" : [ "/usr/lib", "/usr/local/lib" ],
+        },
+        "overrides" : {
+ #               "MPI_HOME":root2,
+ #               "MPI_RUN":root+"/bin/mpirun",
+ #               "LD_LIBRARY_PATH":os.environ["LD_LIBRARY_PATH"],
+ #               "Path":os.environ["PATH"],
+                "ENV":{
+#"PATH":"/home/lange/bin/:/usr/local/bin:/usr/bin:/bin:/cm/shared/apps/openmpi/gcc/64/1.4.2/bin",
+"PATH":os.environ["PATH"],
+"LD_LIBRARY_PATH":os.environ["LD_LIBRARY_PATH"],
+#"LIBRARY_PATH":os.environ["LIBRARY_PATH"],
+#"NLSPATH":os.environ["NLSPATH"],
+#"MKLPATH":os.environ["MKLPATH"],
+#"FPATH":os.environ["FPATH"],
+#"CPATH":os.environ["CPATH"],
+        },
+}
+},
+    "mpi" : { 
+        "overrides" : {
+            "cxx"           : "mpicxx"
+        },
+    },
+}
+
diff -rupN vanilla/rosetta_source/tools/build/site.settings.langelab patched/rosetta_source/tools/build/site.settings.langelab
--- vanilla/rosetta_source/tools/build/site.settings.langelab	1970-01-01 01:00:00.000000000 +0100
+++ patched/rosetta_source/tools/build/site.settings.langelab	2012-06-05 22:11:01.104415383 +0200
@@ -0,0 +1,101 @@
+# -*- mode:python;indent-tabs-mode:nil;show-trailing-whitespace:t; -*-
+#
+# Copy this file into site.settings:
+#
+#   cp site.settings.template site.settings
+#
+# and customize to fit your site's environment
+# DO NOT make changes to this template
+# DO NOT try and check in site.settings
+# (c) Copyright Rosetta Commons Member Institutions.
+# (c) This file is part of the Rosetta software suite and is made available under license.
+# (c) The Rosetta software is developed by the contributing members of the Rosetta Commons.
+# (c) For more information, see http://www.rosettacommons.org. Questions about this can be
+# (c) addressed to University of Washington UW TechTransfer, email: license@u.washington.edu.
+
+
+# Settings here are added to the combined build settings, after all basic
+# settings, to allow you to override anything you need to.  They can in turn
+# be overriden by user settings and project settings respectively.
+#
+# Typically you want to prepend to one of the settings listed to expand your
+# paths, but you can also append, override, or remove settings.
+#
+# NOTE: At some point this file will allow you to have multiple site settings
+# to select between.  For now there is only the "site" settings.
+import os
+openmpiversion="1.4.2"
+root="/cm/shared/apps/openmpi/open64/64/"+openmpiversion
+root2="/cm/shared/apps/openmpi/gcc/64/"+openmpiversion
+root3="/cm/shared/apps/gcc/4.3.4/"
+
+settings = {
+    "gcc, mpi" : { 
+	"overrides" : {
+	   "cxx" : "mpicxx"
+        },
+        "appends" : {
+            "defines"       : [ "USEMPI" ],
+        },
+    },	 	
+     
+	   
+    "site" : {
+        "prepends" : {
+            "program_path" : [
+                "/home/lange/bin/"
+            ],
+
+         },
+        "appends" : {
+
+            # Location of standard and system binaries
+#            "program_path" : [
+         #       root+"/bin",
+         #       root2+"/bin",
+                # Path to GCC compiler if not in the os rule
+                # Path to Intel C++ compiler if not in the os rule
+ #           ],
+            # Location of standard and system header files if not in the os rule
+            "include_path" : [
+                #
+            ],
+            # Location of standard and system libraries if not in the os rule.
+            "library_path" : [
+ #                root+"/lib64",
+ ##               root2+"/lib",
+ #               root2+"/lib64",
+ #               root3+"/lib",
+ #               root3+"/lib64",
+#$/cm/shared/apps/gcc/4.3.4/lib:
+ #               /cm/shared/apps/gcc/4.3.4/lib64:/
+                #
+            ],
+        },
+        "removes" : {
+		"library_path" : [ "/usr/lib", "/usr/local/lib" ],
+        },
+        "overrides" : {
+ #               "MPI_HOME":root2,
+ #               "MPI_RUN":root+"/bin/mpirun",
+ #               "LD_LIBRARY_PATH":os.environ["LD_LIBRARY_PATH"],
+ #               "Path":os.environ["PATH"],
+                "ENV":{
+#"PATH":"/home/lange/bin/:/usr/local/bin:/usr/bin:/bin:/cm/shared/apps/openmpi/gcc/64/1.4.2/bin",
+"PATH":os.environ["PATH"],
+"LD_LIBRARY_PATH":os.environ["LD_LIBRARY_PATH"],
+#"LIBRARY_PATH":os.environ["LIBRARY_PATH"],
+#"NLSPATH":os.environ["NLSPATH"],
+#"MKLPATH":os.environ["MKLPATH"],
+#"FPATH":os.environ["FPATH"],
+#"CPATH":os.environ["CPATH"],
+        },
+}
+},
+    "mpi" : { 
+        "overrides" : {
+            "cxx"           : "mpicxx"
+        },
+    },
+}
+
Binary files vanilla/rosetta_source/tools/build/utility.pyc and patched/rosetta_source/tools/build/utility.pyc differ
Binary files vanilla/rosetta_source/tools/__init__.pyc and patched/rosetta_source/tools/__init__.pyc differ
