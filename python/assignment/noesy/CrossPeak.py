#!/usr/bin/env python2.7
##-*- mode:python;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t;python-indent:2 -*-'

from PeakAssignment import PeakAssignment
from CrossPeakInfo import CrossPeakInfo
from Atom import Atom
from Calibrator import FixCalibrator
from random import randrange,sample
#CrossPeak stands for a 2,3 or 4 dimensional tupel of frequencies in NOESY spectrum
#a cross-peak can have PeakAssignments which are generated by calling assign_resonances
# main information are: the frequencies, the volume, its id and dimensionality
# the CrossPeak Info keeps the information that equal for a bunch of cross-peaks like
# which column corresponds to which atom type : direct/indirect H, label.
# CrossPeak._dim is redundant with cross-peak-info and could be removed, but CrossPeak.dim()
# will stay.
#
# many accessors use dim as variable, this can be 1 or 2, it does not correspond to the column in the cross-peak file
# but is a selector for the proton, protons can be labelled or not, the label_resonance(1) thus returns the
# resonance of the label of proton 1 or it returns None (or exception? )
#
class CrossPeak:
	def __init__( self, id, info=None, dim=3 ):
		self._dim=dim
		if info: dim=info.dim()
		self._freq=[ 999.9 for d in range(0, dim) ]
		self._assignments=[]
		self._id=id
		self._volume=None
		if info: assert isinstance(info,CrossPeakInfo), 'info argument is required to be of type CrossPeakInfo'
		self._info=info
		self.cpinfo_str=None
		self.comment=''
		self._eliminated=0

		#self._store_lines

#	def __deepcopy__( self, memo ):
#		new_one = self.__class__(self._dim, self._id)
#		memo[id(self)] = new_one
#		new_one._freq=self._freq
#		from copy import deepcopy
#		new_one._assignment=deepcopy(self._assignments,memo)
#		new_one._info1=self._info1
#		new_one._info2=self._info2
#		new_one._volume=self._volume
#		return new_one
	def eliminated( self ):
		return self._eliminated

  #frequency of proton
	def proton_resonance( self, dim ):
		assert dim==1 or dim==2
		return self._freq[ self._info.spin(dim).atom_col-1 ]

	#frequency of label (where available)
	def label_resonance( self, dim ):
		assert dim==1 or dim==2
		return self._freq[ self._info.spin(dim).label_col-1 ]

	def info(self):
		return self._info

	def spin_info(self,dim):
		return self._info.spin(dim)

	def freq(self):
		return self._freq

	def volume(self):
		return self._volume

	#given the column in the peak file, give me the assigned spin-number (1,2), second number is atom=1, label=2
	def col2spin(self,col):
		if self._info.spin(1).atom_col==col: return 1,1
		if self._info.spin(1).label_col==col: return 1,2
		if self._info.spin(2).atom_col==col: return 2,1
		if self._info.spin(2).label_col==col: return 2,2


	#set the 'header'-information
	def set_info( self, info ):
		assert len( self._freq )==info.dim()
		self._info=info

	def __str__( self ):
		s='%5d'%self._id
		for f in self._freq:
			s+=' %8.3f'%f
		s+='   1 U'
		s+=' %10.3e 0.00 e 0  '%self._volume
		indent=len(s)
		first=True
		for a in self._assignments:
			s+=str(a)
			if first and self.cpinfo_str:
				s+=' | ' + self.cpinfo_str
				first=False
			s+='\n'+' '*indent
		return s.rstrip()

	#number of assignments
	def nassign(self):
		return len(self._assignments)

#yield the assignments
	def iter_assignments(self):
		for a in self._assignments:
			yield a
	#number of columns 2,3,4

# store the original assignments
	def keep_assignments(self):
		self._origin_assignments=self._assignments

	def random_out_assignments(self):
		self._ex_assignments=self._assignments
		try:
			assert self._origin_assignments,'should store the origin assignments firstly'
			if len(self._origin_assignments)>1:
				assign_size=len(self._origin_assignments)
				rand_size=randrange(1,assign_size)
				sub_assignments=sample(self._origin_assignments,rand_size)
				self._assignments=sub_assignments
		except:
			pass

	def inverse_random_out_assignments(self):
		self._assignments=self._ex_assignments

	def dim(self):
		try:
			return self._info.dim()
		except AttributeError:
			return self._dim

	#id of peak in original file
	def id( self ):
		return self._id

	#add a PeakAssignment (no error control)
	def add_assignment( self, assignment ):
		self._assignments.append( assignment )
		return self

	#remove all current assignments
	def clear_assignments( self ):
		self._assignments=[]
		return self

	def __iter__( self ):
		for a in self._assignments:
			yield a

	def front( self ):
		return self._assignments[0]

	#assign atoms in ResonanceList, generate PeakAssignment for each combination of matches
	def assign_resonances( self, resonances ):
		#find possible matches for spin-group 1 and 2
		matches1 = self.assign_spin( resonances, 1 )
		matches2 = self.assign_spin( resonances, 2 )

		#combine all matches into PeakAssignments
		for j in matches1:
			for k in matches2:
				pa=PeakAssignment(self._info.dim())
				if self.has_label( 1 ):
					pa.assign_atom( self._info.spin(1).atom_col, j[0].atom() )
					pa.assign_atom( self._info.spin(1).label_col, j[1].atom() )
				else:
					pa.assign_atom( self._info.spin(1).atom_col, j.atom() )

				if self.has_label( 2 ):
					pa.assign_atom( self._info.spin(2).atom_col, k[0].atom() )
					pa.assign_atom( self._info.spin(2).label_col, k[1].atom() )
				else:
					pa.assign_atom( self._info.spin(2).atom_col, k.atom() )
				self.add_assignment( pa )

	#this gave a speed up of 1s from 30s total.  <5%
  #def assign_spin99( self, resonances, dim):
	#	matches=[]
	#	spin_info = self._info.spin( dim )
	#	for r in resonances.itervalues():
	#		if not r.match( self.label_resonance( dim ), spin_info.label_tolerance, spin_info.label_folder ): continue
#		#								 and r.atom().elem() == 'H' ]
	#		aa=resonances.aa_from_atom( r.atom() )
	#		for rit in resonances.by_residue( r.resid() ):
	#			if rit.atom().elem()=='H':
	#				label=spin_info.label_atom( rit.atom().name(), aa )
	#				if label==r.name():
	#					matches.append( (rit,r) )
	#	return matches

	#find all resonances that match a particular spin-group:
				# spin-group is either a single unlabelled proton, or its the proton with its corresponding label-atom
				# note that 99 tolerance used in pseudo4D spectra (i.e., C-C-H, which is written as H(>99)-C-C-H with
				# big tolerance such that the hidden  proton doesn't matter when matching
				# )
	def assign_spin( self, resonances, dim ):
		matches=[]
		spin_info = self._info.spin( dim )
		if spin_info.proton_tolerance>99:
      ##leave out the expensive computation for frequency matching if it is super high anyway. (speed up 20% !!!)
			# just match all resonances that are protons
			matches=[ r for r in resonances.itervalues() if r.atom().elem() == 'H' ]
		else:
			#tight tolerance: match protons that match the resonance
			matches=[ r for r in resonances.itervalues() \
									if r.match( self.proton_resonance( dim ), spin_info.proton_tolerance, spin_info.proton_folder ) \
									and r.atom().elem() == 'H' ]

		#if this is an unlabelled spin-group we are done
    if not self.has_label( dim ):
			return matches
		else:
			#if this is labelled spin-group we need to filter for matches where also the label-resonance agrees
			filtered_matches = []
			for r in matches:
				label=spin_info.label_atom( r.atom().name(), resonances.aa_from_atom( r.atom() ) )
				if not label: continue #no label --> this match cannot be matched to this cross-peak
				label_atom = Atom( label, r.atom().resid() )
				label_r=resonances.by_atom( label_atom )
				if not label_r: #label should exist but isn't in ResonanceList --> can't blame the cross-peak, make up new Resonance and assign
					print 'WARNING: cannot find label atom %s in resonance list'%label_atom
					label_r=r.__class__( atom=label_atom, error=9999 )
					resonances.add_resonance( label_r )
					print 'created new resonance... %s\n'%label_r
					filtered_matches.append( (r,label_r) )
				else: #label found in resonance-list, let's check if it matches
					match_result = label_r.match( self.label_resonance( dim ), spin_info.label_tolerance, spin_info.label_folder )
					if match_result:
						filtered_matches.append( (r,label_r) )
			return filtered_matches

	#query if spin-group 1 or 2 has label
	def has_label( self, dim ):
		return not self._info.spin( dim ).label is None

	#generate ROSETTA constraint from assignments, use calibrator to translate volume to upl
	def generate_rosetta_cst(self,calibrator = FixCalibrator() ):
		if self.nassign()==0:
			return None
		if self.nassign()==1:
			col1=self._info.spin(1).atom_col
			col2=self._info.spin(2).atom_col
			asg=self._assignments[ 0 ]
			upl=calibrator.eval( asg.atom(col1), asg.atom(col2), self._volume )
			cst="AmbiguousNMRDistance %s %s BOUNDED 1.5 %8.3f %8.3f automatic NOE Peak %s Volume %8.3f"%(asg.atom(col1),asg.atom(col2),upl, 1.0, self._id, self._volume )
		else:
			cst="STUBBED OUT"
		return cst


	#generate CrossPeak from lines
	@classmethod
	def read_from_lines( obj, lines, ignore_assignments=False, resonances=None ):
		tags=lines[0].split()
		id=int(tags[0])
		if tags[0][0]<='9' and tags[0][0]>='0':
			try:
				dim=tags.index('U')-2
			except ValueError:
				import library
				raise library.InconsistentInput('expected U in line: %s'%lines[0])
			#print dim
			obj=CrossPeak( id, dim=dim )
		else:
			print('wrong lines for one crosspeak\n')
			assert(False)
		#read frequencies
		obj._freq=[ float(x) for x in tags[1:dim+1]]
		obj._volume=float(tags[dim+3])
		#find end of line with the assignment
		if len(tags)<=dim+12: #sometimes, there are more columns in peak files.
			return obj

		#this is the e 0 columns
		end_marker=tags[8-3+dim]+' '+tags[9-3+dim]

		start_assignment=lines[0].index(end_marker)+len(end_marker)
		end_of_line=lines[0][start_assignment:].strip()
		if '|' in end_of_line:
			tt=end_of_line.split('|')
			end_of_line=tt[0]
			cpinfo=tt[1].split()
			obj.cum_peak_vol=float(cpinfo[0])
			obj.prob=float(cpinfo[1])
			obj.class_id=int(cpinfo[2])
			obj.class_str=cpinfo[3]
			obj.min_viol=float(cpinfo[4])
			obj.comment=" ".join(cpinfo[5:])
			obj.cpinfo_str=tt[1]
			if obj.comment.find('eliminated')>=0:
				obj._eliminated=1

		if len(end_of_line):
			asg1=PeakAssignment.read_from_str(end_of_line, resonances )
			if asg1 and not ignore_assignments: obj.add_assignment( asg1 )

		#read additional assignments
		for line in lines[1:]:
			if len(line)<2: continue
			asg=PeakAssignment.read_from_str(line, resonances )
			if asg and not ignore_assignments: obj.add_assignment( asg )
		return obj


def unit_test():
 	s='83   42.598    8.995    1.792  1 U 1.673E+05  0.000E+00  e 0  CB    5      H   56    HB3    5   #VC 0.000 #W 0.069 1.000 1.000 0.200 0.000 0.000 14.578\n'
 	s+='CB    5      H   73    HB3    5   #VC 0.000 #W 0.053 10.000 1.000 0.200 0.000 0.000 19.928\n'
  s+='CB    5      H   85    HB3    5   #VC 0.000 #W 0.032 1.000 1.000 0.200 0.000 0.000 21.969 \n'
 	s+='CB    5      H   90    HB3    5   #VC 1.000 #W 0.053 10.000 1.000 0.200 1.197 6.357 24.454\n'
 	s+='CB    5      H  129    HB3    5   #VC 0.000 #W 0.032 10.000 1.000 0.200 0.000 0.000 9.937\n\n\n'
 	cp=CrossPeak.read_from_lines( s.split('\n'))
	assert cp.nassign()==5, "should be 5"
	assert cp.dim()==3, 'should be 3'
	print cp

	s='83   42.598    8.995    1.792  1 U 1.673E+05  0.000E+00'
	cp2=CrossPeak.read_from_lines( s.split('\n'))

	assert cp2.dim()==3
	assert cp2.nassign()==0

	import copy
	cp_inf=CrossPeakInfo()
	cp_inf._dim=3
	cp.set_info( cp_inf )
	cp_copy=copy.copy(cp)
	assert str(cp_copy.clear_assignments())==str(cp2), 'check equality after removing assignments'
	cp.keep_assignments()
	for i in range(10):
		cp.random_out_assignments()
		print cp.nassign()
# proof that info1 info2 is kept as reference even though objects are copied and behave as such (e.g., assignmen-list is independent)
#...
# 	print id(cp._info1)
# 	print 'id of original', id(cp)
# 	print 'id of copy', id(cp_copy)

