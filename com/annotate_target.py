#!/usr/bin/env python2.7
##-*- mode:python;tab-width:2;indent-tabs-mode:t;show-trailing-whitespace:t;rm-trailing-spaces:t;python-indent:2 -*-'

from os.path import basename
import argparse
import sys
import os
import library
from math import exp
import subprocess
from silent_lib import ReadSilentData
from fasta import read_fasta
#from median import getMedian

def sigmoid(x,tau,m,sign):#sigmoid function
	assert (sign in [1,-1]),'sign has to be either + or - 1'
	if sign==1:
		S=1.0/(1+exp(-1.0/tau*5*(x-m)))
	elif sign==-1:
		S=1-1.0/(1+exp(-1.0/tau*5*(x-m)))
	return S

def execute_job(newpath,com,param):#run command in newpath
	global verbose
	saved_path = os.getcwd()
	os.chdir(newpath)
	if isinstance(param,str):
		if verbose: print 'execute system command: '+com+' '+param+' ...'
		os.system(com+' '+param)
	else:
		if verbose: print 'execute system command: '+com+' '+' '.join(param)+' ...'
		os.system(com+' '.join(param))
	os.chdir(saved_path)

def read_silent_head(silent_file,columns):#read the head lines of silent file
	output=[]
	names = columns.split()
	infile = open(silent_file,'r')
  sfd = ReadSilentData( names )
  for l in infile:
    data=sfd.read_line( l )
    if data:
      if isinstance( data, str ):
        output.append(data)
      else:
        output.append(" ".join(data))
	return output

def getMedian(numericValues):#return median value of such number group
  theValues = sorted(numericValues)
  if len(theValues) % 2 == 1:
    Q2= theValues[(len(theValues)+1)/2-1]
  else:
    lower = theValues[len(theValues)/2-1]
    upper = theValues[len(theValues)/2]
    Q2= (float(lower + upper)) / 2
  L1=int((len(theValues)*25.0/100))
  L2=int((len(theValues)*75.0/100))
  Q1=(theValues[L1-1]+theValues[L1])/2
  Q3=(theValues[L2-1]+theValues[L2])/2
  return (Q2,Q1,Q3)

def score_gap_energy(silent_file,key='low'):
	rms_score_str=read_silent_head(silent_file,'rms_sel_2 score')
	score_value=[]
	for r in rms_score_str:
		tags=r.split()
		if key=='low':
			if float(tags[0])<2:
				score_value.append(float(tags[1]))
		elif key=='high':
			if float(tags[0])>4:
				score_value.append(float(tags[1]))
	score_value.sort()
	scores=[]
	for r in score_value[0:10]:
		scores.append(r)
	(q2,q1,q3)=getMedian(scores)
	return q2

ENV_ROSETTA_BIN='ROSETTA3_BIN'
ENV_ROSETTA_DB='ROSETTA3_DB'
try:
	rosetta_bin=os.environ[ENV_ROSETTA_BIN]
	rosetta_db=os.environ[ENV_ROSETTA_DB]
except KeyError:
	print '\n'+'*'*60
	print 'WARNING: Cannot find ROSETTA_XXX Environment variables'
	print '*'*60+'\n'
	rosetta_db=None
	rosetta_bin=None

parser = argparse.ArgumentParser( description='This script is used to classify the calculation of CS-Rasrec.'\
																		'The result can be either WEAK or STRONG.'\
																		'STRONG means the structure calculation is reliable, WEAK: not reliable.'\
																		'copyright: Oliver Lange\'s Lab',
																	add_help=True)
parser.add_argument("-type", help="type of structure calculation performed: abrelax, rasrec ",default='rasrec');
parser.add_argument("-pred", help="pred.tab generated by talos+",default=None);
parser.add_argument("-fasta", help="Fasta-formatted sequence file",default=None);
parser.add_argument("-run_folder", help="the run folder of CS-Rosetta calculation",default=None)
parser.add_argument("-bin", help="rosetta binaries location", default=rosetta_bin);
parser.add_argument("-platform", help="which platform", choices=['linux','macos'], default='linux' );
parser.add_argument("-comp", help="which compiler", choices=['gcc','icc'], default='gcc' );
parser.add_argument("-extras", help="which extras", choices=['default','static','mpi'], default='mpi' );
parser.add_argument("-j", help="number of processors for rescoring",type=int, default=1 );
parser.add_argument("-verbose", help="print output for system command executions", action='store_true', default=False)

args = parser.parse_args()
global verbose
global verbose_flags
verbose=args.verbose
if verbose:
	verbose_flags=' -out:levels all:warning jd2:info'
else:
	verbose_flags=' -out:levels all:error'

final_decoys_dir='/fullatom_pool/'

CM_EXEC_EXT=args.extras+'.'+args.platform+args.comp+'release'
if args.type=='rasrec':
	if args.run_folder[0]=='~':
		score_gap_path=os.getenv("HOME")+args.run_folder[1:]+'/score_gap/'
		final_decoys_path=os.getenv("HOME")+args.run_folder[1:]+final_decoys_dir
	elif args.run_folder[0] !='/':
		score_gap_path=os.getcwd()+'/'+args.run_folder+'/score_gap/'
		final_decoys_path=os.getcwd()+'/'+args.run_folder+final_decoys_dir
	else:
		score_gap_path=args.run_folder+'/score_gap/'
		final_decoys_path=args.run_folder+final_decoys_dir
elif args.type=='abrelax':
	if args.run_folder[0]=='~':
		final_decoys_path=os.getenv("HOME")+args.run_folder[1:]
	elif args.run_folder[0] !='/':
		final_decoys_path=os.getcwd()+'/'+args.run_folder
	else:
		final_decoys_path=args.run_folder

pred_list=open(args.pred,'r').readlines()

#-----------------parameter 1: quality of chemical shift input---------#
def get_cs_consensus(pred_list):
	length=0.0
	good_cs=0.0
	vars={}
	for line in pred_list:
		tags=line.split()
		if len(tags)<3 or ( tags[0] in ['REMARK','DATA','FORMAT'] ): continue
		if tags[0]=='VARS':
			for i,var in enumerate(tags[1:]):
			#print i,var
				vars[var]=i
		else:
			length+=1
			if float(tags[vars['COUNT']])>7:#count residues with reliable prediction. more than 7 triplets
				good_cs+=1
	return good_cs

#-----------------parameter 1: class of chemical shift input---------#
def get_cs_class(pred_list):
	length=0.0
	good_cs=0.0
	vars={}
	for line in pred_list:
		tags=line.split()
		if len(tags)<3 or ( tags[0] in ['REMARK','DATA','FORMAT'] ): continue
		if tags[0]=='VARS':
			for i,var in enumerate(tags[1:]):
			#print i,var
				vars[var]=i
		else:
			length+=1
			if tags[vars['CLASS']]=='Good':#count residues with reliable prediction. more than 7 triplets
				good_cs+=1
	return good_cs

#-----------------sequence length---------#
def get_seq_len(fasta):
	return len(read_fasta(fasta))


def generate_sel_2(final_decoys_path,bin_dir,CM_EXEC_EXT):
	if not os.path.exists(final_decoys_path+'/low_30.out'):
		execute_job(final_decoys_path,'extract_decoys',' decoys.out -score 30 > low_30.out')#calculate the rigid region based on lowest 30 structures.
	if not os.path.exists(final_decoys_path+'/sel_2.rigid'):
		execute_job(final_decoys_path,bin_dir+'/ensemble_analysis.'+CM_EXEC_EXT,' -in:file:silent low_30.out -wRMSD 2 -rigid:cutoff 2 -rigid:out sel_2.rigid -out:levels all:error >> analyse.log')#Rosetta command

#-----------------parameter 2: convergence of calculation---------#
def get_convergence(final_decoys_path,bin_dir,CM_EXEC_EXT):
	sel_2_list=open(final_decoys_path+'/sel_2.rigid','r').readlines()
	rigid_len=0.0
	for line in sel_2_list:
		tags=line.split()
		if tags[0]=='RIGID':
			rigid_len+=int(tags[2])-int(tags[1])+1
	return rigid_len

#-----------------parameter 3: score gap---------#
def get_score_gap_rasrec(final_decoys_path,score_gap_path,bin_dir,CM_EXEC_EXT):
	global verbose_flags
  if not os.path.exists(final_decoys_path+'/low_1.out'):#generate the virtual reference
	  execute_job(final_decoys_path,'extract_decoys',' decoys.out -score 1 > low_1.out')
  status_list=open(final_decoys_path+'STATUS','r').readlines()
  for line in status_list:
	  tags=line.split()
	  if 'first_fullatom_batch' in line:#find batches in fullatom score
		  first_full=int(tags[5])

	#find last batch from list of batch directories
	from glob import glob
	os.chdir(final_decoys_path+'/../')
#	print os.getcwd()
	batch_list=sorted([x.replace('batch_','') for x in glob('batch_00*') ])
#	print batch_list
	last_full=int(batch_list[-1])

  os.system('mkdir -p '+score_gap_path)
  if not os.path.exists(score_gap_path+'/ref_low_1.pdb'):#generate the virtual referenc
  	execute_job(score_gap_path,'ln',' -s '+final_decoys_path+'/low_1.out .')
	  execute_job(score_gap_path,bin_dir+'/extract_pdbs.'+CM_EXEC_EXT,' -in:file:silent low_1.out -out:levels all:error')
	  execute_job(score_gap_path,'silent_data',' low_1.out description > tag')
	  tag_list=open(score_gap_path+'tag','r').readlines()
	  description=tag_list[0].split()[0]
	  execute_job(score_gap_path,'ln',' -s '+description+'.pdb ref_low_1\.pdb;')
  if not os.path.exists(score_gap_path+'/rescore_high_energy_sel_2.out'):#generate the high eneregy decoys
		files = [ f for f in os.listdir(args.run_folder) if 'batch_' in f ]
		for f in files:
			batch_num=int( f.split('_')[1] )
			if  batch_num >=first_full and batch_num<=last_full:
				execute_job(final_decoys_path+'/../','cat ',f+'/decoys.out >> score_gap/fullatom.out;')
		rosetta_input=[' -silent_print_all_score_headers ',
									 ' -in:file:silent fullatom.out ',
									 ' -evaluation:rmsd  ref_low_1.pdb _sel_2 '+final_decoys_path+'/sel_2.rigid',
									 ' -out:file:silent rescore_high_energy_sel_2.out',
									 verbose_flags]
		#execute_job(score_gap_path,'mpirun -np %d '%(args.j)+bin_dir+'/score_jd2.'+CM_EXEC_EXT,rosetta_input)
		execute_job(score_gap_path,bin_dir+'/score_jd2.'+CM_EXEC_EXT,rosetta_input)
	if not os.path.exists(score_gap_path+'/rescore_low_energy_sel_2.out'):#generate the low eneregy decoys
		rosetta_input=[' -silent_print_all_score_headers ',
									 ' -in:file:silent  '+final_decoys_path+'/decoys.out',
									 ' -evaluation:rmsd  ref_low_1.pdb _sel_2 '+final_decoys_path+'/sel_2.rigid',
									 ' -out:file:silent rescore_low_energy_sel_2.out',
									 verbose_flags ]
		#execute_job(score_gap_path,'mpirun -np %d '%(args.j)+bin_dir+'/score_jd2.'+CM_EXEC_EXT,rosetta_input)
		execute_job(score_gap_path,bin_dir+'/score_jd2.'+CM_EXEC_EXT,rosetta_input)
	try:
		score_gap=score_gap_energy(score_gap_path+'/rescore_high_energy_sel_2.out','high')-score_gap_energy(score_gap_path+'/rescore_low_energy_sel_2.out','low')
	except:
		score_gap=0.0
	return score_gap

#-----------------parameter 3: score gap---------#
def get_score_gap_abrelax(final_decoys_path,bin_dir,CM_EXEC_EXT):
	global verbose_flags
	if not os.path.exists(final_decoys_path+'/low_1.out'):#generate the virtual reference
	  execute_job(final_decoys_path,'extract_decoys',' decoys.out -score 1 > low_1.out')
  if not os.path.exists(final_decoys_path+'/ref_low_1.pdb'):#generate the virtual referenc
	  execute_job(final_decoys_path,bin_dir+'/extract_pdbs.'+CM_EXEC_EXT,' -in:file:silent low_1.out'+verbose_flags)
	  execute_job(final_decoys_path,'silent_data',' low_1.out description > tag')
	  tag_list=open(final_decoys_path+'tag','r').readlines()
	  description=tag_list[0].split()[0]
	  execute_job(final_decoys_path,'ln',' -s '+description+'.pdb ref_low_1\.pdb;')

	if not os.path.exists(final_decoys_path+'/rescore_sel_2.out'):#generate the low eneregy decoys
		rosetta_input=[' -silent_print_all_score_headers ',
									 ' -in:file:silent decoys.out',
									 ' -evaluation:rmsd  ref_low_1.pdb _sel_2 sel_2.rigid',
									 ' -out:file:silent rescore_sel_2.out',
									 verbose_flags ]
		execute_job(final_decoys_path,'mpirun -np %d '%(args.j)+bin_dir+'/score_jd2.'+CM_EXEC_EXT,rosetta_input)
	try:
		score_gap=score_gap_energy(final_decoys_path+'/rescore_sel_2.out','high')-score_gap_energy(final_decoys_path+'/rescore_sel_2.out','low')
	except:
		score_gap=0.0
	return score_gap

consensus_cs=get_cs_consensus(pred_list)
class_cs=get_cs_class(pred_list)
seq_len=get_seq_len(args.fasta)
generate_sel_2(final_decoys_path,args.bin,CM_EXEC_EXT)
rigid_len=get_convergence(final_decoys_path,args.bin,CM_EXEC_EXT)
if args.type=='rasrec':
	score_gap=get_score_gap_rasrec(final_decoys_path,score_gap_path,args.bin,CM_EXEC_EXT)
elif args.type=='abrelax':
	score_gap=get_score_gap_abrelax(final_decoys_path,args.bin,CM_EXEC_EXT)

if args.type=='abrelax':
	print '%20s %20s %20s %20s %20s'%('cs-class','convergence','energy gap','sum','annotation')
	sum_value=0.08*class_cs/seq_len+0.54*rigid_len/seq_len+0.38*sigmoid(score_gap,25,5,1)
	if  sum_value >0.69:
		print '%20.3f %20.3f %20.3f %20.3f %20s'%(class_cs/seq_len,rigid_len/seq_len,sigmoid(score_gap,25,5,1),sum_value,'strong')
	else:
		print '%20.3f %20.3f %20.3f %20.3f %20s'%(class_cs/seq_len,rigid_len/seq_len,sigmoid(score_gap,25,5,1),sum_value,'weak')

if args.type=='rasrec':
	print '%20s %20s %20s %20s %20s'%('cs-consensus','convergence','energy gap','sum','annotation')
	sum_value= 0.58*consensus_cs/seq_len+0.29*rigid_len/seq_len+0.13*sigmoid(score_gap/seq_len,0.4,0.05,1)
	if  sum_value>0.82:
		print '%20.3f %20.3f %20.3f %20.3f %20s'%(consensus_cs/seq_len,rigid_len/seq_len,sigmoid(score_gap/seq_len,0.4,0.05,1),sum_value,'strong')

	else:
		print '%20.3f %20.3f %20.3f %20.3f %20s'%(consensus_cs/seq_len,rigid_len/seq_len,sigmoid(score_gap/seq_len,0.4,0.05,1),sum_value,'weak')

